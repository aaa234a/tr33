<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Rail Builder Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
    />
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <!-- GeoTIFF.js を追加 -->
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    <!-- LZ-String を追加: セーブデータを圧縮・解凍するために使用 -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>

    <style>
      /* 基本的なスタイル */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f8f9fa; /* 全体の背景色 */
        color: #333;
        overflow: hidden; /* チュートリアル表示時にスクロールバーが出ないように */
      }
      #map {
        height: 100%;
        width: 100%;
        cursor: default;
      }
      /* 建設モード中のカーソル */
      #map.build-mode-cursor {
        cursor: crosshair;
      }

      /* カスタムスクロールバー (Webkit系ブラウザ) */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      /* トップレベルのパネル (left-panel, finance-panel) */
      .panel {
        position: absolute;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95); /* 背景を少し不透明に */
        padding: 15px; /* パディングを増やす */
        border-radius: 10px; /* 角を丸く */
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2); /* 影を強調 */
        border: 1px solid #e0e0e0; /* 軽いボーダー */
        transition: all 0.3s ease-out; /* 開閉アニメーション用 */
      }
      #left-panel {
        top: 15px;
        left: 15px;
        width: 280px; /* 幅を少し広げる */
        max-height: calc(100% - 30px); /* 画面の高さに合わせて最大高さを設定 */
        overflow-y: auto; /* 内容が多い場合にスクロール可能に */
        display: flex;
        flex-direction: column;
        gap: 15px; /* 子パネル間のスペースを増やす */
      }
      #left-panel.collapsed {
        width: 60px; /* 最小幅をボタンより大きく変更 */
        height: 60px; /* max-heightではなくheightで固定に変更 */
        overflow: hidden;
        padding: 0;
      }
      #left-panel.collapsed > *:not(.panel-toggle-btn) {
        display: none; /* 開閉ボタン以外を非表示 */
      }

      .panel-toggle-btn {
        position: absolute;
        top: 0px;
        right: 0px;
        width: 40px;
        height: 40px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 0 10px 0 10px;
        cursor: pointer;
        font-size: 1.2em;
        line-height: 40px;
        text-align: center;
        transition: background 0.2s;
        z-index: 1001; /* パネルコンテンツより手前 */
      }
      .panel-toggle-btn:hover {
        background: #0056b3;
      }
      #left-panel.collapsed .panel-toggle-btn {
        border-radius: 10px; /* 全体が丸くなるように */
        top: 10px; /* 閉じた状態でのボタンの位置調整 */
        right: 10px; /* 閉じた状態でのボタンの位置調整 */
      }

      #finance-panel {
        top: 15px;
        right: 15px;
        width: 220px; /* 幅を少し広げる */
        text-align: right; /* テキストを右寄せ */
        font-size: 1.1em;
        font-weight: bold;
        color: #007bff; /* 強調色 */
      }
      #finance-panel span {
        color: #28a745; /* 資産の色 */
      }
      #message-bar {
        position: absolute;
        bottom: 25px; /* 下からの位置を少し上げる */
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.85); /* 背景をより濃く */
        color: white;
        padding: 10px 20px; /* パディングを増やす */
        border-radius: 25px; /* 角をさらに丸く */
        font-size: 1.1em;
        opacity: 0;
        transition: opacity 0.4s ease-in-out, background-color 0.3s, color 0.3s; /* トランジションを長く */
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
      #message-bar.success {
        background-color: rgba(40, 167, 69, 0.9);
      }
      #message-bar.warning {
        background-color: rgba(255, 193, 7, 0.9);
        color: #333;
      }
      #message-bar.error {
        background-color: rgba(220, 53, 69, 0.9);
      }

      /* left-panel の子要素のパネル (build-menu, finance-panel) */
      /* これらはFlexアイテムとしてレイアウトされるため、positionはstatic */
      #left-panel > .panel {
        background: #fdfdfd; /* 子パネルの背景色 */
        padding: 15px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* 軽い影 */
        position: static; /* 絶対配置を解除 */
        width: auto; /* 幅を親に合わせる */
        margin-bottom: 0; /* gapでスペースを確保するため不要 */
        border: 1px solid #f0f0f0;
      }
      #left-panel > .panel h3 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #007bff;
        font-size: 1.2em;
        border-bottom: 2px solid #eee;
        padding-bottom: 8px;
        border-left: 5px solid #007bff; /* パネルヘッダーの強調 */
        padding-left: 10px;
      }
      #left-panel > .panel h4 {
        margin-top: 15px;
        margin-bottom: 10px;
        color: #555;
        font-size: 1em;
      }

      /* マップ上の表示物 */
      /* 線路のレール */
      .track-rail {
        color: #b0b0b0; /* レール色 */
        weight: 2;
        opacity: 0.9;
        lineCap: butt; /* 端を四角に */
        z-index: 10; /* 枕木より上 */
      }
      /* 線路の枕木 */
      .track-sleeper {
        color: #5a4b40; /* 枕木色 */
        weight: 8; /* 枕木は太く */
        opacity: 0.9;
        dashArray: "1 10"; /* 短い線と長い間隔で枕木を表現 */
        lineCap: butt;
        z-index: 5; /* レールより下 */
      }

      /* 高架線路の見た目 */
      .track-viaduct-rail {
        color: #c0c0c0;
      }
      .track-viaduct-sleeper {
        color: #706050;
      }
      /* トンネル線路の見た目 */
      .track-tunnel-rail {
        color: #808080;
      }
      .track-tunnel-sleeper {
        color: #403020;
      }

      /* 駅ホーム本体 */
      .station-platform-body {
        color: #a0a0a0; /* コンクリート色 */
        weight: 10; /* ホーム本体は太く */
        opacity: 0.9;
        lineCap: butt;
        z-index: 15; /* レールより上 */
      }
      /* 駅ホームの縁 */
      .station-platform-edge {
        color: #ffffff; /* 白線 */
        weight: 2; /* 細い縁 */
        opacity: 1;
        lineCap: butt;
        z-index: 20; /* ホーム本体より上 */
      }

      .station-marker {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #d9534f;
        border: 2px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        transition: transform 0.1s ease-out; /* ホバー時のアニメーション */
        display: flex; /* 中央に数字を配置 */
        justify-content: center;
        align-items: center;
        font-size: 0.8em;
        font-weight: bold;
        color: white;
      }
      .station-marker:hover {
        transform: scale(1.2); /* ホバーで少し拡大 */
      }
      .station-marker.selected-for-line {
        background: #007bff; /* 路線設定で選択された駅の色 */
        border-color: #007bff;
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.7);
      }
      /* 路線設定で選択された駅マーカーのスタイルをさらに調整（駅クリック時に適用される）*/
      .station-marker-selectable {
        cursor: pointer;
      }

      /* 駅名ツールチップ */
      .station-name-tooltip {
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 4px 8px;
        font-size: 0.9em;
        white-space: nowrap;
        pointer-events: none; /* クリックイベントを通過させる */
      }
      .station-name-tooltip::before {
        border-top-color: rgba(0, 0, 0, 0.7) !important;
      }

      /* 解体モードで選択されたオブジェクトのスタイル */
      .selected-for-demolition {
        animation: pulse 1s infinite alternate; /* 点滅アニメーション */
      }
      @keyframes pulse {
        from {
          outline: 3px solid rgba(220, 53, 69, 0.5);
          box-shadow: 0 0 10px rgba(220, 53, 69, 0.3);
        }
        to {
          outline: 3px solid rgba(220, 53, 69, 1);
          box-shadow: 0 0 15px rgba(220, 53, 69, 0.8);
        }
      }

      .station-marker.selected-for-demolition {
        background: #dc3545; /* マーカーも赤く */
        border-color: #dc3545;
      }

      .line-color {
        weight: 5;
        dasharray: "";
        opacity: 0.8;
      }

      /* ボタンのスタイル */
      button {
        margin: 4px 0; /* マージンを調整 */
        padding: 10px 15px; /* パディングを増やす */
        border-radius: 5px; /* 角を丸く */
        cursor: pointer;
        border: 1px solid #007bff; /* メインカラーのボーダー */
        background: #007bff; /* メインカラーの背景 */
        color: white; /* 文字色を白に */
        font-weight: bold;
        transition: background 0.2s, color 0.2s, border-color 0.2s,
          box-shadow 0.2s, transform 0.2s;
        width: 100%;
        box-sizing: border-box;
        box-shadow: 0 2px 4px rgba(0, 123, 255, 0.2);
        display: flex; /* アイコンとテキストを中央揃え */
        align-items: center;
        justify-content: center;
      }
      button i {
        margin-right: 8px; /* アイコンとテキストの間隔 */
      }
      button:hover {
        background: #0056b3; /* ホバーで少し暗く */
        border-color: #0056b3;
        box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
        transform: translateY(-2px); /* 浮き上がるエフェクト */
      }
      button.active {
        background: #28a745; /* アクティブなボタンは緑色に */
        border-color: #28a745;
        box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        transform: translateY(0); /* 浮き上がりをリセット */
      }
      button.active:hover {
        background: #218838;
        border-color: #218838;
      }
      button:disabled {
        background: #e9ecef;
        color: #6c757d;
        cursor: not-allowed;
        border-color: #dee2e6;
        box-shadow: none;
        transform: translateY(0);
      }
      /* 特定のボタンのスタイル調整 */
      #confirm-build,
      #confirm-line-build,
      #confirm-demolition {
        background: #ffc107; /* 確定ボタンは警告色 */
        border-color: #ffc107;
        color: #333;
      }
      #confirm-build:hover,
      #confirm-line-build:hover,
      #confirm-demolition:hover {
        background: #e0a800;
        border-color: #e0a800;
      }
      #cancel-line-build,
      #cancel-demolition {
        background: #dc3545; /* キャンセルボタンは危険色 */
        border-color: #dc3545;
      }
      #cancel-line-build:hover,
      #cancel-demolition:hover {
        background: #c82333;
        border-color: #c82333;
      }
      #demolition-mode-btn {
        background: #6c757d; /* 解体モードは灰色 */
        border-color: #6c757d;
      }
      #demolition-mode-btn:hover {
        background: #5a6268;
        border-color: #5a6268;
      }
      #demolition-mode-btn.active {
        background: #dc3545; /* アクティブな解体モードは赤 */
        border-color: #dc3545;
      }
      #demolition-mode-btn.active:hover {
        background: #c82333;
        border-color: #c82333;
      }

      /* ゲーム速度ボタンの調整 */
      #game-speed-control button {
        width: calc(25% - 5px); /* 4つ並べる */
        display: inline-flex; /* flexに変更 */
        margin-right: 5px;
      }
      #game-speed-control button:last-child {
        margin-right: 0;
      }

      hr {
        border: none;
        border-top: 1px solid #eee;
        margin: 15px 0;
      }

      /* 列車ショップ */
      #train-list,
      #bought-trains-list {
        max-height: 250px; /* 高さを調整 */
        overflow-y: auto;
        border: 1px solid #ddd; /* ボーダーを調整 */
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 10px;
        background: #fff;
      }
      .train-item {
        display: flex;
        align-items: center;
        padding: 10px;
        margin-bottom: 6px;
        border: 1px solid #eee;
        border-radius: 5px;
        cursor: pointer;
        background: #f9f9f9;
        transition: background 0.2s, border-color 0.2s, box-shadow 0.2s;
      }
      .train-item:hover {
        background: #f0f0f0;
        border-color: #ccc;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }
      .train-item.selected {
        border-color: #007bff;
        background: #e7f3ff;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
      }
      .train-item i {
        font-size: 1.5em;
        margin-right: 12px;
        color: #666;
      }
      .train-item-color-box {
        width: 24px; /* サイズを少し大きく */
        height: 24px;
        border-radius: 4px;
        margin-right: 12px;
        border: 1px solid #ccc;
        flex-shrink: 0; /* 縮まないように */
      }
      .train-item-details {
        flex-grow: 1;
      }
      .train-item-details h4 {
        margin: 0;
        font-size: 1.1em;
        color: #333;
      }
      .train-item-details p {
        margin: 0;
        font-size: 0.85em;
        color: #666;
      }

      /* 路線設定 */
      #selected-stations-list {
        max-height: 180px; /* 高さを調整 */
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 10px;
        background: #fff;
      }
      .selected-station-item {
        padding: 8px;
        margin-bottom: 5px;
        background: #f0f8ff; /* 選択された駅の背景色 */
        border: 1px solid #b0e0e6;
        border-radius: 4px;
        font-size: 0.95em;
        color: #444;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .selected-station-item span {
        font-weight: bold;
        margin-right: 8px;
        color: #007bff;
      }
      .selected-station-item button {
        width: auto;
        padding: 4px 10px;
        font-size: 0.8em;
        margin: 0;
        background: #dc3545;
        color: white;
        border: none;
        box-shadow: none;
      }
      .selected-station-item button:hover {
        background: #c82333;
      }

      /* 列車車両 */
      .train-car-container {
        /* L.divIconのルート要素。iconSizeで指定されるサイズ */
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: none; /* マップ操作の邪魔にならないように */
      }
      .train-car-body {
        /* 実際の車両の長方形 */
        border-radius: 2px;
        box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(0, 0, 0, 0.2); /* 車両の境界線 */
        position: relative;
      }
      .train-car-body.front-car::after {
        content: "";
        position: absolute;
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 12px solid white; /* 矢印の色 */
        top: -12px; /* 車両の少し上に配置 */
        left: 50%;
        transform: translateX(-50%);
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.3);
      }

      /* 建設コスト表示ツールチップ */
      .construction-cost-tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 0.9em;
        white-space: nowrap;
        pointer-events: none;
        z-index: 1000;
        transform: translate(-50%, -120%); /* マウスカーソルから少しずらす */
      }

      /* ロード中のスピナー */
      #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        color: white;
        font-size: 1.5em;
        flex-direction: column;
        gap: 20px;
        transition: opacity 0.3s ease-in-out;
      }
      .spinner {
        border: 8px solid #f3f3f3; /* Light grey */
        border-top: 8px solid #3498db; /* Blue */
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 2s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* チュートリアルモーダル */
      #tutorial-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      }
      #tutorial-overlay.show {
        opacity: 1;
        visibility: visible;
      }
      #tutorial-modal {
        background: #fff;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        max-width: 600px;
        width: 90%;
        text-align: center;
        transform: translateY(-20px);
        transition: transform 0.3s ease-in-out;
      }
      #tutorial-overlay.show #tutorial-modal {
        transform: translateY(0);
      }
      #tutorial-modal h2 {
        color: #007bff;
        font-size: 2em;
        margin-bottom: 20px;
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }
      #tutorial-modal p {
        font-size: 1.1em;
        line-height: 1.6;
        color: #555;
        margin-bottom: 20px;
      }
      .tutorial-navigation-buttons button {
        width: auto;
        padding: 10px 20px;
        margin: 0 10px;
        font-size: 1em;
      }
      #tutorial-skip-btn {
        background-color: #6c757d;
        border-color: #6c757d;
      }
      #tutorial-skip-btn:hover {
        background-color: #5a6268;
        border-color: #5a6268;
      }

      /* モバイル対応 */
      @media (max-width: 768px) {
        /* ブレークポイントを調整 */
        #left-panel {
          width: calc(100% - 30px); /* 左右15pxマージン */
          left: 15px;
          right: 15px;
          top: 15px;
          max-height: calc(70% - 30px); /* 画面の70%に制限 */
          flex-direction: column;
        }
        #finance-panel {
          width: calc(100% - 30px);
          right: 15px;
          top: auto; /* 上からの位置指定を解除 */
          bottom: 15px; /* 下に配置 */
          text-align: center; /* 中央寄せ */
          padding: 10px;
          font-size: 1em;
        }
        #message-bar {
          bottom: 10px; /* さらに下げる */
          font-size: 0.9em;
          padding: 8px 15px;
        }
        .panel {
          padding: 10px;
        }
        #left-panel > .panel {
          padding: 10px;
        }
        button {
          padding: 8px 12px;
          font-size: 0.9em;
        }
        select {
          padding: 8px;
          font-size: 0.9em;
        }
        .train-item {
          padding: 8px;
        }
        .train-item-details h4 {
          font-size: 1em;
        }
        .train-item-details p {
          font-size: 0.8em;
        }
        .selected-station-item {
          padding: 6px;
          font-size: 0.85em;
        }
        .selected-station-item button {
          padding: 3px 8px;
          font-size: 0.75em;
        }
        #game-speed-control button {
          width: calc(25% - 4px);
          margin-right: 4px;
        }
        #tutorial-modal {
          padding: 20px;
        }
        #tutorial-modal h2 {
          font-size: 1.5em;
        }
        #tutorial-modal p {
          font-size: 1em;
        }
        .tutorial-navigation-buttons button {
          padding: 8px 15px;
          margin: 0 5px;
          font-size: 0.9em;
        }
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div id="left-panel" class="panel">
      <button id="toggle-left-panel" class="panel-toggle-btn">
        <i class="fas fa-chevron-left"></i>
      </button>

      <div id="build-menu" class="panel">
        <h3>建設メニュー</h3>
        <button id="build-ground">
          <i class="fas fa-road"></i> 地上線 ($<span id="cost-ground"></span>/m)
        </button>
        <button id="build-viaduct">
          <i class="fas fa-bridge"></i> 高架線 ($<span id="cost-viaduct"></span
          >/m)
        </button>
        <button id="build-tunnel">
          <i class="fas fa-tunnel"></i> トンネル ($<span id="cost-tunnel"></span
          >/m)
        </button>
        <!-- 駅のコスト表示を基本料金と1mあたりの料金に変更 -->
        <button id="build-station">
          <i class="fas fa-train-station"></i> 駅 (基本 $250,000 + $5,000/m)
        </button>
        <hr />
        <button id="confirm-build" disabled>建設確定</button>
      </div>

      <div id="train-shop" class="panel">
        <h3>列車ショップ</h3>
        <h4>購入可能な列車</h4>
        <div id="train-list">
          <!-- 列車アイテムがここに追加される -->
        </div>
        <button id="buy-train-btn" disabled>
          <i class="fas fa-cart-shopping"></i> 選択した列車を購入
        </button>
        <hr />
        <h4>購入済み列車</h4>
        <div id="bought-trains-list">
          <!-- 購入済み列車アイテムがここに追加される -->
        </div>
        <select
          id="line-select-for-assignment"
          style="
            width: 100%;
            margin-top: 5px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
          "
        ></select>
        <button id="assign-train-to-line-btn" disabled>
          <i class="fas fa-share-nodes"></i> 選択した列車を路線に割り当てる
        </button>
      </div>

      <div id="line-builder" class="panel">
        <h3>路線設定</h3>
        <button id="start-line-build">
          <i class="fas fa-route"></i> 路線設定開始
        </button>
        <div id="selected-stations-list">
          <!-- 選択された駅がここに追加される -->
        </div>
        <!-- 路線確定ボタンのコスト表示を基本料金と1mあたりの料金に変更 -->
        <button id="confirm-line-build" disabled>
          <i class="fas fa-check"></i> 路線確定 (基本 $50,000 + $2,500/m)
        </button>
        <button id="cancel-line-build">
          <i class="fas fa-xmark"></i> キャンセル
        </button>
      </div>

      <!-- 解体メニューを追加 -->
      <div id="demolition-menu" class="panel">
        <h3>解体メニュー</h3>
        <button id="demolition-mode-btn">
          <i class="fas fa-hammer"></i> 解体モード
        </button>
        <div
          id="demolition-info"
          style="margin-top: 10px; font-size: 0.9em; color: #555"
        >
          <p>マップ上の線路や駅をクリックして選択してください。</p>
          <p id="selected-demolition-target"></p>
        </div>
        <button id="confirm-demolition" disabled>
          <i class="fas fa-trash-can"></i> 解体確定
        </button>
        <button id="cancel-demolition">
          <i class="fas fa-ban"></i> 解体キャンセル
        </button>
      </div>

      <!-- セーブ/ロードメニューを追加 -->
      <div id="save-load-menu" class="panel">
        <h3>セーブ/ロード</h3>
        <button id="save-game-btn">
          <i class="fas fa-save"></i> ゲームをセーブ (ローカル)
        </button>
        <button id="load-game-btn">
          <i class="fas fa-folder-open"></i> ゲームをロード (ローカル)
        </button>
        <hr />
        <button id="export-save-btn">
          <i class="fas fa-file-export"></i> セーブデータを出力
        </button>
        <textarea
          id="save-data-textarea"
          rows="5"
          placeholder="セーブデータJSONをここに入力/表示"
        ></textarea>
        <button id="import-save-btn">
          <i class="fas fa-file-import"></i> セーブデータを入力
        </button>
      </div>

      <!-- ゲーム速度コントロールを追加 -->
      <div id="game-speed-control" class="panel">
        <h3>ゲーム速度</h3>
        <button data-speed="1" class="speed-btn active">1x</button>
        <button data-speed="2" class="speed-btn">2x</button>
        <button data-speed="4" class="speed-btn">4x</button>
        <button data-speed="8" class="speed-btn">8x</button>
      </div>
    </div>

    <div id="finance-panel" class="panel">
      <p>資産: <span id="assets-display">$0</span></p>
      <p>時間: <span id="game-time-display">0日 00:00</span></p>
    </div>

    <div id="message-bar"></div>

    <!-- ロード中のスピナーオーバーレイ -->
    <div id="loading-overlay" style="display: none">
      <div class="spinner"></div>
      <p id="loading-message">データを読み込み中...</p>
    </div>

    <!-- チュートリアルモーダル -->
    <div id="tutorial-overlay">
      <div id="tutorial-modal">
        <h2 id="tutorial-title"></h2>
        <i id="tutorial-icon" class="tutorial-icon"></i>
        <p id="tutorial-text"></p>
        <div class="tutorial-navigation-buttons">
          <button id="tutorial-prev-btn" disabled>
            <i class="fas fa-chevron-left"></i> 前へ
          </button>
          <button id="tutorial-next-btn">
            <i class="fas fa-chevron-right"></i> 次へ
          </button>
          <button id="tutorial-skip-btn">
            <i class="fas fa-forward"></i> スキップ
          </button>
        </div>
      </div>
    </div>

    <script>
      // ===================================================================
      // ES5互換性対応: ポリフィル相当の定義 (変更なし)
      // ===================================================================

      if (!Array.prototype.find) {
        Array.prototype.find = function (predicate) {
          var list = Object(this);
          var length = list.length >>> 0;
          if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
          }
          for (var i = 0; i < length; i++) {
            var value = list[i];
            if (predicate.call(arguments, value, i, list)) {
              return value;
            }
          }
          return undefined;
        };
      }
      if (!Array.prototype.includes) {
        Array.prototype.includes = function (searchElement /*, fromIndex */) {
          var O = Object(this);
          var len = O.length >>> 0;
          if (len === 0) {
            return false;
          }
          var n =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : 0;
          var k;
          if (n >= 0) {
            k = n;
          } else {
            k = len - Math.abs(n);
          }
          while (k < len) {
            var element = O[k];
            if (
              element === searchElement ||
              (element !== element && searchElement !== searchElement)
            ) {
              return true;
            }
            k++;
          }
          return false;
        };
      }
      if (!Array.prototype.findIndex) {
        Array.prototype.findIndex = function (predicate) {
          var list = Object(this);
          var length = list.length >>> 0;
          if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
          }
          for (var i = 0; i < length; i++) {
            var value = list[i];
            if (predicate.call(arguments, value, i, list)) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!L.Polyline.prototype.getLatLngs) {
        // For older Leaflet versions if needed
        L.Polyline.prototype.getLatLngs = function () {
          return this._latlngs;
        };
      }
      if (!L.Polyline.prototype.setLatLngs) {
        // For older Leaflet versions if needed
        L.Polyline.prototype.setLatLngs = function (latlngs) {
          this._latlngs = this._convertLatLngs(latlngs);
          return this.redraw();
        };
      }
      if (!("equals" in L.LatLng.prototype)) {
        L.LatLng.prototype.equals = function (otherLatLng, margin) {
          if (!otherLatLng) {
            return false;
          }
          otherLatLng = L.latLng(otherLatLng);
          var margin = Math.max(
            Math.abs(this.lat - otherLatLng.lat),
            Math.abs(this.lng - otherLatLng.lng)
          );
          return margin <= (margin === undefined ? 1.0e-9 : margin);
        };
      }

      // ===================================================================
      // Custom RotatedMarker: 列車車両の回転を可能にするLeafletマーカー
      // ===================================================================
      L.RotatedMarker = L.Marker.extend({
        options: {
          rotation: 0,
        },

        onAdd: function (map) {
          L.Marker.prototype.onAdd.call(this, map);
          this.updateRotation();
        },

        updateRotation: function () {
          if (this._icon) {
            this._icon.style[L.DomUtil.TRANSFORM + "Origin"] = "center center";
            var currentTransform = this._icon.style[L.DomUtil.TRANSFORM];
            var newTransform =
              currentTransform.replace(/rotate\([^)]*\)/g, "").trim() +
              " rotate(" +
              this.options.rotation +
              "deg)";
            this._icon.style[L.DomUtil.TRANSFORM] = newTransform;
          }
        },

        setRotation: function (rotation) {
          this.options.rotation = rotation;
          this.updateRotation();
          return this;
        },

        _setPos: function (pos) {
          L.Marker.prototype._setPos.call(this, pos);
          this.updateRotation();
        },
      });

      L.rotatedMarker = function (latlng, options) {
        return new L.RotatedMarker(latlng, options);
      };

      // ===================================================================
      // CONFIG: ゲームの設定値 (const -> var)
      // ===================================================================
      var CONFIG = {
        initialAssets: 50000000, // 初期資産を増額
        costs: {
          // 各種建設コストを増額
          ground: { perMeter: 50 }, // 1mあたり50ドル
          viaduct: { perMeter: 150 }, // 1mあたり150ドル
          tunnel: { perMeter: 300 }, // 1mあたり300ドル
          station: {
            // 駅のコストは基本料金とプラットフォーム長に応じた費用
            base: 250000, // 基本料金を増額
            perMeter: 5000, // 1メートルあたりの費用を増額
          },
          line: {
            // 路線のコストは基本料金と総距離に応じた費用
            base: 50000, // 基本料金を増額
            perMeter: 2500, // 1メートルあたりの費用を増額
          },
        },
        // revenuePerStationStop: 10000, // 駅に停車するたびに得られる基本収益 (廃止)
        passengerCapacityPerCar: 50, // 1車両あたりの乗客容量
        basePassengerGeneration: 15, // ★修正: 駅で生成される乗客の基本量 (人口密度倍率適用前) を100から15に減らしました
        passengerRevenuePerPerson: 100, // 1人あたりの乗客収益（降車時）
        passengerGenerationInterval: 10000, // 乗客を生成する間隔 (ms)
        passengerMaxDestinationAttempts: 5, // 乗客の目的地を決定する際の試行回数
        maxWaitingPassengersPerMeterOfPlatform: 2, // ★修正: プラットフォーム1mあたりの最大待機乗客数を10から2に減らしました
        optimalCarsPerLineSegment: 10, // 1路線セグメントあたりの最適な車両数（乗客生成の供給係数調整用）

        // 列車種類を実在のものに修正
        trains: [
          {
            id: "e233",
            name: "E233系通勤電車",
            cars: 10,
            cost: 1000000,
            color: "#007bff",
            defaultSpeed: 100,
          },
          {
            id: "e259",
            name: "E259系成田エクスプレス",
            cars: 6,
            cost: 1500000,
            color: "#d9534f",
            defaultSpeed: 130,
          },
          {
            id: "n700s",
            name: "N700S系新幹線",
            cars: 16,
            cost: 5000000,
            color: "#5cb85c",
            defaultSpeed: 285,
          },
          {
            id: "485",
            name: "485系特急電車",
            cars: 8,
            cost: 2000000,
            color: "#f0ad4e",
            defaultSpeed: 120,
          },
          {
            id: "kiha40",
            name: "キハ40系気動車",
            cars: 4,
            cost: 800000,
            color: "#6f42c1",
            defaultSpeed: 95,
          },
          {
            id: "e6",
            name: "E6系スーパーこまち",
            cars: 7,
            cost: 3000000,
            color: "#d63384",
            defaultSpeed: 320,
          },
          {
            id: "h5",
            name: "H5系北海道新幹線",
            cars: 10,
            cost: 4000000,
            color: "#20c997",
            defaultSpeed: 260,
          },
          {
            id: "shinkansen-e7",
            name: "E7系北陸新幹線",
            cars: 12,
            cost: 4500000,
            color: "#6610f2",
            defaultSpeed: 275,
          },
          {
            id: "shinkansen-e3",
            name: "E3系つばさ",
            cars: 7,
            cost: 2800000,
            color: "#fd7e14",
            defaultSpeed: 275,
          },
          {
            id: "sunrise",
            name: "寝台特急サンライズ瀬戸・出雲",
            cars: 14,
            cost: 3500000,
            color: "#20c997",
            defaultSpeed: 110,
          },
          {
            id: "torokko",
            name: "嵯峨野トロッコ列車",
            cars: 5,
            cost: 1200000,
            color: "#ffc107",
            defaultSpeed: 50,
          },
          {
            id: "local",
            name: "地方普通列車",
            cars: 3,
            cost: 500000,
            color: "#6c757d",
            defaultSpeed: 80,
          },
        ],

        trainCarDimensionsMeters: {
          // 車両のサイズ (メートル)
          length: 20, // 車両の進行方向の長さ
          width: 3, // 車両の幅
        },
        lineColors: [
          "#FF0000",
          "#0000FF",
          "#00FF00",
          "#FFFF00",
          "#00FFFF",
          "#FF00FF",
          "#FF8C00",
          "#8A2BE2",
        ], // 路線に割り当てる色
        trainStopDuration: 5000, // 駅での停車時間 (ms) - 乗降時間を考慮して延長
        updateInterval: 50, // 列車の位置更新間隔 (ms)
        snapThresholdPixels: 15, // スナップ判定のピクセル距離
        snapThresholdMeters: 20, // 線路接続判定のメートル距離
        gameTimeInterval: 1000, // ゲーム内時間更新間隔 (ms)
        gameTimeScale: 60, // リアル1秒がゲーム内60秒に相当
      };

      // --- GAME STATE: ゲームの現在の状態を保持するオブジェクト (let -> var) ---
      var state = {
        assets: CONFIG.initialAssets, // 現在の資産
        tracks: [], // 建設済みの線路オブジェクトの配列
        stations: [], // 建設済みの駅オブジェクトの配列
        lines: [], // 確定した路線オブジェクトの配列
        trains: [], // 購入済み列車オブジェクトの配列
        planning: {
          // 線路・駅建設モードの状態
          type: null, // 'ground', 'viaduct', 'tunnel'
          points: [], // 建設中の点の配列 (LatLng)
          ghost: null, // 建設中の仮ポリライン/マーカー (Leaflet Layer)
          costTooltip: null, // 建設コスト表示ツールチップ
        },
        lineBuildingMode: false, // 路線設定モードかどうか
        selectedStationsForLine: [], // 路線設定中に選択された駅のIDリスト
        currentLineGhost: null, // 路線設定中の仮ポリライン (Leaflet Layer)
        selectedTrainToBuyId: null, // ショップで選択中の列車ID
        currentLineColorIndex: 0, // 次の路線に割り当てる色のインデックス
        selectedTrainToAssignId: null, // 路線に割り当てるために選択中の列車ID
        demolitionMode: false, // 解体モードかどうか
        selectedForDemolition: null, // 解体モードで選択されたオブジェクト { type: 'track'|'station', id: string }
        gameSpeedMultiplier: 1, // 新規追加: ゲーム速度倍率
        trainUpdateIntervalId: null, // 新規追加: 列車の更新setInterval ID
        passengerGenerationIntervalId: null, // 新規追加: 乗客生成setInterval ID
        gameTime: 0, // 新規追加: ゲーム内時間 (ミリ秒)
        gameTimeIntervalId: null, // 新規追加: ゲーム時間更新setInterval ID
      };

      // --- MAP: Leafletマップの初期化 ---
      var map = L.map("map", { preferCanvas: true }).setView(
        [36.2048, 138.2529],
        7
      ); // 日本の中心付近を初期表示、ズームレベル7
      L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r.png}",
        {
          attribution: "&copy; CARTO",
          maxZoom: 19,
        }
      ).addTo(map);

      // --- UI ELEMENTS: UI要素への参照とUI操作関数 ---
      var ui = {
        assetsDisplay: document.getElementById("assets-display"),
        gameTimeDisplay: document.getElementById("game-time-display"), // 新規追加
        messageBar: document.getElementById("message-bar"),
        buildButtons: document.querySelectorAll(
          "#build-menu button:not(#confirm-build)"
        ),
        confirmBuildButton: document.getElementById("confirm-build"),
        trainListDiv: document.getElementById("train-list"),
        buyTrainButton: document.getElementById("buy-train-btn"),
        startLineBuildButton: document.getElementById("start-line-build"),
        selectedStationsListDiv: document.getElementById(
          "selected-stations-list"
        ),
        confirmLineBuildButton: document.getElementById("confirm-line-build"),
        cancelLineBuildButton: document.getElementById("cancel-line-build"),
        boughtTrainsListDiv: document.getElementById("bought-trains-list"),
        assignTrainToLineButton: document.getElementById(
          "assign-train-to-line-btn"
        ),
        lineSelectForAssignment: document.getElementById(
          "line-select-for-assignment"
        ),
        demolitionModeButton: document.getElementById("demolition-mode-btn"),
        selectedDemolitionTargetDisplay: document.getElementById(
          "selected-demolition-target"
        ),
        confirmDemolitionButton: document.getElementById("confirm-demolition"),
        cancelDemolitionButton: document.getElementById("cancel-demolition"),
        saveGameButton: document.getElementById("save-game-btn"),
        loadGameButton: document.getElementById("load-game-btn"),
        costGround: document.getElementById("cost-ground"),
        costViaduct: document.getElementById("cost-viaduct"),
        costTunnel: document.getElementById("cost-tunnel"),
        // 新しいUI要素への参照
        exportSaveButton: document.getElementById("export-save-btn"),
        importSaveButton: document.getElementById("import-save-btn"),
        saveDataTextarea: document.getElementById("save-data-textarea"),
        loadingOverlay: document.getElementById("loading-overlay"), // 新規追加
        loadingMessage: document.getElementById("loading-message"), // 新規追加
        toggleLeftPanelButton: document.getElementById("toggle-left-panel"), // 新規追加

        /**
         * ユーザーにメッセージを表示する。
         * @param {string} msg - 表示するメッセージ。
         * @param {string} [type='info'] - メッセージのタイプ ('info', 'success', 'warning', 'error')。
         * @param {boolean} [persistent=false] - メッセージを永続的に表示するかどうか。
         * @param {number} [duration=3000] - メッセージを表示する時間 (ミリ秒)。
         */
        showMessage: function (msg, type, persistent, duration) {
          if (type === undefined) type = "info";
          if (persistent === undefined) persistent = false;
          if (duration === undefined) duration = 3000;

          this.messageBar.textContent = msg;
          this.messageBar.className = "message-bar " + type; // クラスを更新
          this.messageBar.style.opacity = 1;
          if (!persistent) {
            clearTimeout(this.messageBar.hideTimeout); // 既存のタイマーをクリア
            this.messageBar.hideTimeout = setTimeout(function () {
              ui.messageBar.style.opacity = 0;
            }, duration);
          }
        },

        /** 資産表示を更新する。 */
        updateFinance: function () {
          this.assetsDisplay.textContent =
            "$" + Math.floor(state.assets).toLocaleString();
        },

        /** ゲーム時間表示を更新する。 */
        updateGameTimeDisplay: function () {
          var totalMinutes = Math.floor(state.gameTime / 60000); // ミリ秒から分へ
          var days = Math.floor(totalMinutes / (24 * 60));
          var hours = Math.floor((totalMinutes % (24 * 60)) / 60);
          var minutes = totalMinutes % 60;
          this.gameTimeDisplay.textContent =
            days +
            "日 " +
            String(hours).padStart(2, "0") +
            ":" +
            String(minutes).padStart(2, "0");
        },

        /** 列車ショップのUIを更新する。 */
        renderTrainShop: function () {
          var self = this;

          // 購入可能な列車リストの更新
          this.trainListDiv.innerHTML = "";
          var i, trainConfig;
          for (i = 0; i < CONFIG.trains.length; i++) {
            trainConfig = CONFIG.trains[i];
            var trainItem = document.createElement("div");
            trainItem.className = self.trainItemClass(trainConfig.id, "buy");
            trainItem.dataset.trainId = trainConfig.id;
            trainItem.innerHTML =
              '<i class="fas fa-train"></i>' + // 列車アイコンを追加
              '<div class="train-item-details">' +
              "<h4>" +
              trainConfig.name +
              "</h4>" +
              "<p>" +
              trainConfig.cars +
              "両 - $" +
              trainConfig.cost.toLocaleString() +
              "</p>" +
              "</div>";

            trainItem.onclick = function () {
              selectTrainToBuy(this.dataset.trainId);
            };
            this.trainListDiv.appendChild(trainItem);
          }

          var selectedTrainCost = state.selectedTrainToBuyId
            ? CONFIG.trains.find(function (t) {
                return t.id === state.selectedTrainToBuyId;
              }).cost
            : null;

          this.buyTrainButton.disabled =
            !state.selectedTrainToBuyId || state.assets < selectedTrainCost;
          this.buyTrainButton.textContent = state.selectedTrainToBuyId
            ? "選択した列車を購入 ($" +
              (selectedTrainCost ? selectedTrainCost.toLocaleString() : "0") +
              ")"
            : "選択した列車を購入";

          // 購入済み列車リストの更新
          this.boughtTrainsListDiv.innerHTML = "";
          if (state.trains.length === 0) {
            this.boughtTrainsListDiv.innerHTML =
              '<p style="text-align:center; color:#999; font-size:0.9em;">購入済みの列車はありません。</p>';
          }

          for (i = 0; i < state.trains.length; i++) {
            var train = state.trains[i];
            var trainItem = document.createElement("div");
            trainItem.className = self.trainItemClass(train.id, "assign");
            trainItem.dataset.trainId = train.id;
            var assignedLine = train.currentLineId
              ? getLineById(train.currentLineId)
              : null;
            trainItem.innerHTML =
              '<i class="fas fa-train"></i>' + // 列車アイコンを追加
              '<div class="train-item-details">' +
              "<h4>" +
              train.name +
              "</h4>" +
              "<p>" +
              (assignedLine ? "路線: " + assignedLine.name : "未割り当て") +
              "</p>" +
              // 乗客数と最大容量を追加
              "<p>乗客: " +
              train.currentPassengers.length +
              "/" +
              train.maxCapacity +
              "人</p>" +
              "</div>";

            trainItem.onclick = function () {
              selectTrainToAssign(this.dataset.trainId);
            };
            this.boughtTrainsListDiv.appendChild(trainItem);
          }

          // 割り当て用路線選択ドロップダウンの更新
          this.lineSelectForAssignment.innerHTML =
            '<option value="">路線を選択...</option>';
          var line;
          for (i = 0; i < state.lines.length; i++) {
            line = state.lines[i];
            var option = document.createElement("option");
            option.value = line.id;
            option.textContent = line.name;
            this.lineSelectForAssignment.appendChild(option);
          }

          // 現在選択されている路線があればそれを選択状態にする
          if (state.selectedTrainToAssignId) {
            var selectedTrain = state.trains.find(function (t) {
              return t.id === state.selectedTrainToAssignId;
            });
            if (selectedTrain && selectedTrain.currentLineId) {
              this.lineSelectForAssignment.value = selectedTrain.currentLineId;
            } else {
              this.lineSelectForAssignment.value = "";
            }
          } else {
            this.lineSelectForAssignment.value = "";
          }

          this.assignTrainToLineButton.disabled =
            !state.selectedTrainToAssignId ||
            !this.lineSelectForAssignment.value;
        },

        trainItemClass: function (id, type) {
          var baseClass = "train-item";
          if (type === "buy" && state.selectedTrainToBuyId === id)
            baseClass += " selected";
          if (type === "assign" && state.selectedTrainToAssignId === id)
            baseClass += " selected";
          return baseClass;
        },

        /** 路線設定モードで選択された駅リストを更新する。 */
        updateSelectedStationsForLine: function () {
          var self = this;
          this.selectedStationsListDiv.innerHTML = "";
          if (state.selectedStationsForLine.length === 0) {
            this.selectedStationsListDiv.innerHTML =
              '<p style="text-align:center; color:#999; font-size:0.9em;">駅を選択してください</p>';
          }

          for (var i = 0; i < state.selectedStationsForLine.length; i++) {
            var stationId = state.selectedStationsForLine[i];
            var station = getStationById(stationId);
            if (station) {
              var item = document.createElement("div");
              item.className = "selected-station-item";
              item.innerHTML =
                "<span>" +
                (i + 1) +
                ".</span> " +
                station.name +
                ' <button data-station-id="' +
                stationId +
                '"><i class="fas fa-xmark"></i> 削除</button>';

              item.querySelector("button").onclick = function (e) {
                e.stopPropagation(); // 親要素のクリックイベントが発火しないように
                removeStationFromLineBuilding(this.dataset.stationId);
              };
              this.selectedStationsListDiv.appendChild(item);
            }
          }

          // 路線確定ボタンのテキストと有効/無効状態を動的に更新
          var potentialLineLength = 0;
          var pathFound = true;
          if (state.selectedStationsForLine.length >= 2) {
            for (var j = 0; j < state.selectedStationsForLine.length - 1; j++) {
              var startStation = getStationById(
                state.selectedStationsForLine[j]
              );
              var endStation = getStationById(
                state.selectedStationsForLine[j + 1]
              );
              if (startStation && endStation) {
                var segmentPath = findPathBetweenStations_GraphSearch(
                  startStation.latlng,
                  endStation.latlng
                );
                if (segmentPath) {
                  potentialLineLength += calculatePathDistance(segmentPath);
                } else {
                  pathFound = false;
                  break;
                }
              }
            }
          }
          var potentialLineCost =
            CONFIG.costs.line.base +
            CONFIG.costs.line.perMeter * potentialLineLength;

          this.confirmLineBuildButton.disabled =
            state.selectedStationsForLine.length < 2 ||
            state.assets < potentialLineCost ||
            !pathFound;
          this.confirmLineBuildButton.textContent =
            "路線確定 ($" + Math.round(potentialLineCost).toLocaleString() + ")";
        },

        /** 建設メニューのボタンのアクティブ状態を設定する。 */
        setBuildModeActive: function (type) {
          var i, btn;
          for (i = 0; i < this.buildButtons.length; i++) {
            btn = this.buildButtons[i];
            if (btn.id === "build-" + type) {
              btn.classList.add("active");
            } else {
              btn.classList.remove("active");
            }
          }
          // 建設確定ボタンは、点を配置するまで無効
          this.confirmBuildButton.disabled = true;
          this.confirmBuildButton.textContent = "建設確定";
        },

        /** 建設メニューのボタンのアクティブ状態をリセットする。 */
        resetBuildModeActive: function () {
          var i, btn;
          for (i = 0; i < this.buildButtons.length; i++) {
            btn = this.buildButtons[i];
            btn.classList.remove("active");
          }
          this.confirmBuildButton.disabled = true;
          this.confirmBuildButton.textContent = "建設確定";
        },

        /** 路線設定関連UIの表示/非表示を切り替える。 */
        setLineBuildModeActive: function (active) {
          if (active) {
            this.startLineBuildButton.classList.add("active");
            this.confirmLineBuildButton.style.display = "flex"; // flexに変更
            this.cancelLineBuildButton.style.display = "flex"; // flexに変更
            this.selectedStationsListDiv.style.display = "block";
          } else {
            this.startLineBuildButton.classList.remove("active");
            this.confirmLineBuildButton.style.display = "none";
            this.cancelLineBuildButton.style.display = "none";
            this.selectedStationsListDiv.style.display = "none";
          }
        },

        /** 解体モード関連UIの表示/非表示を切り替える。 */
        setDemolitionModeActive: function (active) {
          if (active) {
            this.demolitionModeButton.classList.add("active");
            this.confirmDemolitionButton.style.display = "flex"; // flexに変更
            this.cancelDemolitionButton.style.display = "flex"; // flexに変更
            this.selectedDemolitionTargetDisplay.style.display = "block";
          } else {
            this.demolitionModeButton.classList.remove("active");
            this.confirmDemolitionButton.style.display = "none";
            this.cancelDemolitionButton.style.display = "none";
            this.selectedDemolitionTargetDisplay.style.display = "none";
            this.selectedDemolitionTargetDisplay.textContent = ""; // 表示をクリア
          }
          this.confirmDemolitionButton.disabled = !state.selectedForDemolition;
        },

        /** ロードオーバーレイの表示/非表示 */
        showLoadingOverlay: function (message) {
          this.loadingMessage.textContent = message || "データを読み込み中...";
          this.loadingOverlay.style.display = "flex";
          // opacityをtransitionさせるために少し遅延させる
          setTimeout(function () {
            ui.loadingOverlay.style.opacity = 1;
          }, 10);
        },

        hideLoadingOverlay: function () {
          this.loadingOverlay.style.opacity = 0;
          setTimeout(function () {
            ui.loadingOverlay.style.display = "none";
          }, 300); // transitionの時間と合わせる
        },
      };

      // --- INITIAL LOAD ---
      ui.updateFinance();
      ui.updateGameTimeDisplay();
      ui.renderTrainShop();
      ui.setLineBuildModeActive(false); // 初期は非表示
      ui.setDemolitionModeActive(false); // 初期は非表示
      ui.costGround.textContent = CONFIG.costs.ground.perMeter;
      ui.costViaduct.textContent = CONFIG.costs.viaduct.perMeter;
      ui.costTunnel.textContent = CONFIG.costs.tunnel.perMeter;

      // --- HELPER FUNCTIONS: 汎用ユーティリティ関数 ---

      /** ユニークなIDを生成する。 */
      function generateUniqueId() {
        return "_" + Math.random().toString(36).substr(2, 9);
      }

      /** IDに基づいて駅オブジェクトを検索する。 */
      function getStationById(id) {
        var i;
        for (i = 0; i < state.stations.length; i++) {
          if (state.stations[i].id === id) {
            return state.stations[i];
          }
        }
        return undefined;
      }

      /** IDに基づいて路線オブジェクトを検索する。 */
      function getLineById(id) {
        var i;
        for (i = 0; i < state.lines.length; i++) {
          if (state.lines[i].id === id) {
            return state.lines[i];
          }
        }
        return undefined;
      }

      /** IDに基づいて線路オブジェクトを検索する。 */
      function getTrackById(id) {
        var i;
        for (i = 0; i < state.tracks.length; i++) {
          if (state.tracks[i].id === id) {
            return state.tracks[i];
          }
        }
        return undefined;
      }

      /**
       * パス(LatLng配列)上の始点からの指定された距離にある点と、その点での進行方向を計算する。
       * @param {L.LatLng[]} latlngs - パスを構成するLatLngの配列。
       * @param {number} distance - パスの始点からの距離(メートル)。
       * @returns {{latlng: L.LatLng, heading: number}|null} - 緯度経度と進行方向(度)。パスの範囲外の場合はnull。
       */
      function getPointAtDistance(latlngs, distance) {
        if (!latlngs || latlngs.length < 2) {
          return null
        }
        var currentDist = 0;
        for (var i = 0; i < latlngs.length - 1; i++) {
          var p1 = latlngs[i];
          var p2 = latlngs[i + 1];
          var segmentDist = p1.distanceTo(p2);
          if (currentDist + segmentDist >= distance) {
            var distIntoSegment = distance - currentDist;
            var ratio = segmentDist === 0 ? 0 : distIntoSegment / segmentDist;
            var lat = p1.lat + (p2.lat - p1.lat) * ratio;
            var lng = p1.lng + (p2.lng - p1.lng) * ratio;
            return {
              latlng: L.latLng(lat, lng),
              heading: getHeading(p1, p2),
            };
          }
          currentDist += segmentDist;
        }
        // 距離がパスの全長を超える場合は、最後の点を返す
        var lastP1 = latlngs[latlngs.length - 2];
        var lastP2 = latlngs[latlngs.length - 1];
        return {
          latlng: lastP2,
          heading: getHeading(lastP1, lastP2),
        };
      }

      /**
       * LatLngの配列で構成されるパス上の指定された進行度におけるLatLngと進行方向を計算する。
       * @param {L.LatLng[]} latlngs - パスを構成するLatLngの配列。
       * @param {number} progress - 0.0から1.0までの進行度。
       * @returns {{latlng: L.LatLng, heading: number}} - 緯度経度と進行方向（度）。
       */
      function getLatLngAtProgressOnPath(latlngs, progress) {
        if (!latlngs || latlngs.length < 2) {
          return { latlng: latlngs ? latlngs[0] : L.latLng(0, 0), heading: 0 };
        }

        var totalLength = 0;
        var segmentLengths = [];
        var i;
        for (i = 0; i < latlngs.length - 1; i++) {
          var segmentLength = latlngs[i].distanceTo(latlngs[i + 1]);
          segmentLengths.push(segmentLength);
          totalLength += segmentLength;
        }

        if (totalLength === 0) {
          return { latlng: latlngs[0], heading: 0 };
        }

        var targetDistance = totalLength * progress;

        // getPointAtDistance を再利用
        return getPointAtDistance(latlngs, targetDistance);
      }

      /**
       * 2点間の進行方向（角度）を計算する。
       * @param {L.LatLng} p1 - 始点。
       * @param {L.LatLng} p2 - 終点。
       * @returns {number} - 進行方向（度、北を0度として時計回り）。
       */
      function getHeading(p1, p2) {
        var toRad = Math.PI / 180;
        var toDeg = 180 / Math.PI;

        var lat1 = p1.lat * toRad;
        var lon1 = p1.lng * toRad;
        var lat2 = p2.lat * toRad;
        var lon2 = p2.lng * toRad;

        var dLon = lon2 - lon1;

        var y = Math.sin(dLon) * Math.cos(lat2);
        var x =
          Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

        var bearing = Math.atan2(y, x) * toDeg;
        bearing = (bearing + 360) % 360; // 0-360度の範囲に変換
        return bearing;
      }

      /**
       * メートル単位の長さを現在の地図のズームレベルと緯度に基づいてピクセルに変換する。
       * @param {number} meters - メートル単位の長さ。
       * @param {L.LatLng} latlng - 変換を行う緯度経度。
       * @returns {number} - ピクセル単位の長さ。
       */
      function metersToPixels(meters, latlng) {
        var point1 = map.latLngToLayerPoint(latlng);
        var metersPerDegreeLng =
          111320 * Math.cos((latlng.lat * Math.PI) / 180);
        var latlng2 = L.latLng(
          latlng.lat,
          latlng.lng + meters / metersPerDegreeLng
        );
        var point2 = map.latLngToLayerPoint(latlng2);
        return point1.distanceTo(point2);
      }

      /**
       * パス (LatLngの配列) の総距離をメートルで計算する。
       * @param {L.LatLng[]} pathLatLngs - パスを構成するLatLngの配列。
       * @returns {number} - パスの総距離 (メートル)。
       */
      function calculatePathDistance(pathLatLngs) {
        var distance = 0;
        var i;
        for (i = 0; i < pathLatLngs.length - 1; i++) {
          distance += pathLatLngs[i].distanceTo(pathLatLngs[i + 1]);
        }
        return distance;
      }
      /**
       * 緯度経度に基づいて駅オブジェクトを検索する（中心座標で比較）。
       * @param {L.LatLng} latlng - 検索する緯度経度。
       * @returns {object|null} - 見つかった駅オブジェクト、またはnull。
       */
      function findStationByLatLng(latlng) {
        for (var i = 0; i < state.stations.length; i++) {
          // L.LatLng.equals() を使って座標を比較
          if (state.stations[i].latlng.equals(latlng)) {
            return state.stations[i];
          }
        }
        return null;
      }
      /**
       * 2つの駅間を接続する既存の線路パスを探索し、そのパスを構成するLatLngsを返す。
       * グラフ探索（BFS）により、連続した線路・駅プラットフォームを繋ぐ。
       * @param {L.LatLng} startStationLatLng - 始点駅の中心緯度経度。
       * @param {L.LatLng} endStationLatLng - 終点駅の中心緯度経度。
       * @returns {L.LatLng[]|null} - 見つかった線路パスのLatLng配列。見つからない場合はnullを返す。
       */
      function findPathBetweenStations_GraphSearch(
        startStationLatLng,
        endStationLatLng
      ) {
        var thresholdMeters = CONFIG.snapThresholdMeters;

        var startStationObj = findStationByLatLng(startStationLatLng);
        var endStationObj = findStationByLatLng(endStationLatLng);

        // 駅が見つからない、または同じ駅同士の探索は無効
        if (
          !startStationObj ||
          !endStationObj ||
          startStationObj.id === endStationObj.id
        ) {
          return null;
        }

        // 1. 探索のためのグラフ構造（隣接リスト）を作成
        var adj = {};
        var nodes = {};

        function addNode(id, latlng) {
          if (!adj[id]) {
            adj[id] = [];
            nodes[id] = { latlng: latlng };
          }
        }
        function addEdge(u, v, path) {
          adj[u].push({ to: v, path: path });
          adj[v].push({ to: u, path: [].concat(path).reverse() }); // 逆方向も追加
        }

        var i;
        // 線路をグラフに追加
        for (i = 0; i < state.tracks.length; i++) {
          var track = state.tracks[i];
          if (!track.latlngs || track.latlngs.length < 2) continue;
          var trackStartId = "track_" + track.id + "_start";
          var trackEndId = "track_" + track.id + "_end";
          addNode(trackStartId, track.latlngs[0]);
          addNode(trackEndId, track.latlngs[track.latlngs.length - 1]);
          addEdge(trackStartId, trackEndId, track.latlngs);
        }

        // 駅のプラットフォームをグラフに追加
        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (!station.latlngs || station.latlngs.length < 2) continue;
          var stationStartId = "station_" + station.id + "_start";
          var stationEndId = "station_" + station.id + "_end";
          addNode(stationStartId, station.latlngs[0]);
          addNode(stationEndId, station.latlngs[station.latlngs.length - 1]);
          addEdge(stationStartId, stationEndId, station.latlngs);
        }

        // ノード間の接続（線路同士、駅と線路など）をエッジとして追加
        var nodeIds = Object.keys(nodes);
        for (i = 0; i < nodeIds.length; i++) {
          for (var j = i + 1; j < nodeIds.length; j++) {
            var id1 = nodeIds[i];
            var id2 = nodeIds[j];
            var parts1 = id1.split("_");
            var parts2 = id2.split("_");

            // 同じオブジェクト（線路 or 駅）の端点同士は接続しない
            // IDは'type__randomid_endpoint'の形式なので、ID部分は2番目以降
            if (
              parts1[0] === parts2[0] &&
              parts1.length > 2 &&
              parts2.length > 2 &&
              parts1[2] === parts2[2]
            ) {
              continue;
            }

            if (
              nodes[id1].latlng.distanceTo(nodes[id2].latlng) < thresholdMeters
            ) {
              addEdge(id1, id2, [nodes[id1].latlng, nodes[id2].latlng]);
            }
          }
        }

        // 2. BFSで始点駅の端から終点駅の端への経路を探索
        var startNodeIds = [
          "station_" + startStationObj.id + "_start",
          "station_" + startStationObj.id + "_end",
        ];
        var endNodeIds = [
          "station_" + endStationObj.id + "_start",
          "station_" + endStationObj.id + "_end",
        ];

        var queue = [];
        var visited = {};

        // 始点駅の両端をキューの初期値として追加
        for (i = 0; i < startNodeIds.length; i++) {
          var startId = startNodeIds[i];
          if (nodes[startId]) {
            queue.push({ id: startId, path: [nodes[startId].latlng] });
            visited[startId] = true;
          }
        }

        while (queue.length > 0) {
          var current = queue.shift();

          // 終点駅のどちらかの端に到達したら成功
          if (endNodeIds.includes(current.id)) {
            return current.path;
          }

          var neighbors = adj[current.id] || [];
          for (i = 0; i < neighbors.length; i++) {
            var neighbor = neighbors[i];
            if (!visited[neighbor.to]) {
              visited[neighbor.to] = true;

              var newPath = [].concat(current.path);
              var segmentPath = neighbor.path;

              // 接続点で座標が重複しないようにパスを結合
              if (
                newPath.length > 0 &&
                segmentPath.length > 0 &&
                newPath[newPath.length - 1].equals(segmentPath[0])
              ) {
                Array.prototype.push.apply(newPath, segmentPath.slice(1));
              } else {
                Array.prototype.push.apply(newPath, segmentPath);
              }

              queue.push({ id: neighbor.to, path: newPath });
            }
          }
        }

        return null; // パスが見つからなかった場合
      }

      /**
       * 全てのモードを非アクティブにするヘルパー関数
       */
      function deactivateAllModes() {
        if (state.planning.type) {
          if (state.planning.ghost) {
            map.removeLayer(state.planning.ghost);
            state.planning.ghost = null;
          }
          if (state.planning.costTooltip) {
            map.removeLayer(state.planning.costTooltip);
            state.planning.costTooltip = null;
          }
          state.planning.points = [];
          state.planning.type = null;
          ui.resetBuildModeActive();
        }
        if (state.lineBuildingMode) {
          cancelLineBuilding();
        }
        if (state.demolitionMode) {
          cancelDemolition();
        }
        map.dragging.enable(); // マップドラッグを有効化
        map.getContainer().classList.remove("build-mode-cursor"); // カーソルを元に戻す
      }

      // --- EVENT LISTENERS: 各種UIイベントハンドラの設定 ---

      // 建設ボタン
      document.getElementById("build-ground").onclick = function () {
        deactivateAllModes();
        startPlanning("ground");
      };
      document.getElementById("build-viaduct").onclick = function () {
        deactivateAllModes();
        startPlanning("viaduct");
      };
      document.getElementById("build-tunnel").onclick = function () {
        deactivateAllModes();
        startPlanning("tunnel");
      };
      document.getElementById("build-station").onclick = function () {
        deactivateAllModes();
        startPlanning("station");
      };
      ui.confirmBuildButton.onclick = confirmBuild;

      // 列車ショップボタン
      ui.buyTrainButton.onclick = buySelectedTrain;
      ui.assignTrainToLineButton.onclick = assignSelectedTrainToLine;
      ui.lineSelectForAssignment.onchange = function () {
        ui.assignTrainToLineButton.disabled =
          !state.selectedTrainToAssignId || !ui.lineSelectForAssignment.value;
      };

      // 路線設定ボタン
      ui.startLineBuildButton.onclick = function () {
        deactivateAllModes();
        startLineBuilding();
      };
      ui.confirmLineBuildButton.onclick = confirmLineBuilding;
      ui.cancelLineBuildButton.onclick = cancelLineBuilding;

      // 解体ボタン
      ui.demolitionModeButton.onclick = function () {
        deactivateAllModes();
        startDemolitionMode();
      };
      ui.confirmDemolitionButton.onclick = confirmDemolition;
      ui.cancelDemolitionButton.onclick = cancelDemolition;

      // セーブ/ロードボタン (既存)
      ui.saveGameButton.onclick = saveGame;
      ui.loadGameButton.onclick = loadGame;

      // セーブデータ出力/入力ボタン
      ui.exportSaveButton.onclick = exportSaveData;
      ui.importSaveButton.onclick = importSaveData;
      // ui.generateShareUrlButton.onclick = generateShareUrl; // 削除

      // ゲーム速度ボタン
      var speedButtons = document.querySelectorAll(
        "#game-speed-control .speed-btn"
      );
      for (var i = 0; i < speedButtons.length; i++) {
        speedButtons[i].onclick = function () {
          setGameSpeed(parseInt(this.dataset.speed));
        };
      }

      // 左パネル開閉ボタン
      ui.toggleLeftPanelButton.onclick = function () {
        document.getElementById("left-panel").classList.toggle("collapsed");
        var icon = this.querySelector("i");
        if (icon.classList.contains("fa-chevron-left")) {
          icon.classList.remove("fa-chevron-left");
          icon.classList.add("fa-chevron-right");
        } else {
          icon.classList.remove("fa-chevron-right");
          icon.classList.add("fa-chevron-left");
        }
      };

      // --- PLANNING (TRACK/STATION CONSTRUCTION): 線路・駅建設モードのロジック ---
      var dragging = false; // マップドラッグ中かどうかのフラグ

      /**
       * 建設モードを開始または終了する。
       * @param {string} type - 建設タイプ ('ground', 'viaduct', 'tunnel', 'station').
       */
      function startPlanning(type) {
        if (state.planning.type === type) {
          // 同じボタンを再度押したら解除
          deactivateAllModes(); // 全モードを解除
          ui.showMessage("建設モードを解除しました。", "info");
          return;
        }

        // 新しい建設モードを開始
        deactivateAllModes();
        state.planning.type = type;
        state.planning.points = [];
        if (state.planning.ghost) {
          map.removeLayer(state.planning.ghost);
        } // 既存のゴーストをクリア
        state.planning.ghost = null;
        map.dragging.disable(); // 建設中はマップドラッグを無効化
        map.getContainer().classList.add("build-mode-cursor"); // カーソルを変更
        ui.showMessage(
          (type === "station" ? "駅" : "線路") +
            "建設モード: マップをドラッグして建設します。",
          "info",
          true
        );
        ui.setBuildModeActive(type);
      }

      // --- MAP EVENTS FOR CONSTRUCTION ---
      map.on("mousedown", function (e) {
        if (!state.planning.type) return; // 建設モードでない場合は何もしない

        dragging = true;
        var snappedPoint = snapPoint(e.latlng);
        state.planning.points = [snappedPoint]; // 最初の点を設定

        // ゴースト表示を更新
        if (state.planning.ghost) {
          map.removeLayer(state.planning.ghost);
        }
        if (state.planning.type === "station") {
          state.planning.ghost = L.polyline(
            [snappedPoint, snappedPoint],
            ghostStyle("station")
          ).addTo(map);
        } else {
          state.planning.ghost = L.polyline(
            [snappedPoint, snappedPoint],
            ghostStyle(state.planning.type)
          ).addTo(map);
        }

        // コストツールチップの作成
        if (!state.planning.costTooltip) {
          state.planning.costTooltip = L.divIcon({
            className: "construction-cost-tooltip",
            html: "ドラッグして長さを決定",
            iconAnchor: [0, 0], // 後で位置を調整
          });
          state.planning.costTooltip = L.marker(e.latlng, {
            icon: state.planning.costTooltip,
          }).addTo(map);
        }
      });

      map.on("mousemove", function (e) {
        if (
          dragging &&
          state.planning.type &&
          state.planning.points.length > 0
        ) {
          var snappedPoint = snapPoint(e.latlng);
          state.planning.ghost.setLatLngs([
            state.planning.points[0],
            snappedPoint,
          ]);

          // コストツールチップの更新
          if (state.planning.costTooltip) {
            var len = state.planning.points[0].distanceTo(snappedPoint);
            var cost = 0;
            if (state.planning.type === "station") {
              cost =
                CONFIG.costs.station.base + CONFIG.costs.station.perMeter * len;
            } else {
              cost = CONFIG.costs[state.planning.type].perMeter * len;
            }
            state.planning.costTooltip.setLatLng(e.latlng);
            state.planning.costTooltip
              .getIcon()
              .options.html =
              "長さ: " +
              len.toFixed(1) +
              "m<br>コスト: $" +
              Math.round(cost).toLocaleString();
            state.planning.costTooltip.redraw(); // アイコンのHTML変更を反映
          }
        }
      });

      map.on("mouseup", function (e) {
        if (
          dragging &&
          state.planning.type &&
          state.planning.points.length > 0
        ) {
          dragging = false;
          var snappedPoint = snapPoint(e.latlng);

          if (!state.planning.points[0].equals(snappedPoint)) {
            state.planning.points.push(snappedPoint);
          } else {
            if (state.planning.type === "station") {
              // 1点しかクリックされなかった場合、デフォルトのプラットフォーム長を生成
              var defaultLength = 20; // メートル
              var angle = 45; // 北東
              var latOffset = defaultLength / 111111;
              var lngOffset =
                defaultLength /
                (111111 * Math.cos((snappedPoint.lat * Math.PI) / 180));
              state.planning.points.push(
                L.latLng(
                  snappedPoint.lat +
                    latOffset * Math.cos((angle * Math.PI) / 180),
                  snappedPoint.lng +
                    lngOffset * Math.sin((angle * Math.PI) / 180)
                )
              );
            } else {
              ui.showMessage(
                "線路は2つの異なる点で構成する必要があります。",
                "warning",
                false,
                3000
              );
              if (state.planning.ghost) {
                map.removeLayer(state.planning.ghost);
                state.planning.ghost = null;
              }
              state.planning.points = [];
              ui.confirmBuildButton.disabled = true;
              ui.confirmBuildButton.textContent = "建設確定";
              // コストツールチップを削除
              if (state.planning.costTooltip) {
                map.removeLayer(state.planning.costTooltip);
                state.planning.costTooltip = null;
              }
              return;
            }
          }

          var cost = 0;
          var len = state.planning.points[0].distanceTo(
            state.planning.points[1]
          );
          if (state.planning.type === "station") {
            cost =
              CONFIG.costs.station.base + CONFIG.costs.station.perMeter * len;
          } else {
            cost = CONFIG.costs[state.planning.type].perMeter * len;
          }
          ui.confirmBuildButton.textContent =
            "建設確定 ($" + Math.round(cost).toLocaleString() + ")";
          ui.confirmBuildButton.disabled = state.assets < cost;

          // コストツールチップを削除
          if (state.planning.costTooltip) {
            map.removeLayer(state.planning.costTooltip);
            state.planning.costTooltip = null;
          }
        }
      });

      // --- SNAP TO NEARBY TRACK/STATION ---
      /**
       * 最も近い既存の線路の端点や駅に緯度経度をスナップさせる。
       * @param {L.LatLng} latlng - スナップ対象の緯度経度。
       * @returns {L.LatLng} - スナップされた緯度経度、または元の緯度経度。
       */
      function snapPoint(latlng) {
        var closest = { point: latlng, dist: Infinity };
        var currentPointPx = map.latLngToLayerPoint(latlng);
        var i;
        var snapCandidates = [];

        // 既存の線路の端点
        for (i = 0; i < state.tracks.length; i++) {
          snapCandidates.push(state.tracks[i].latlngs[0]);
          snapCandidates.push(
            state.tracks[i].latlngs[state.tracks[i].latlngs.length - 1]
          );
        }

        // 既存の駅のプラットフォームの端点をスナップ候補に追加
        for (i = 0; i < state.stations.length; i++) {
          // snapCandidates.push(state.stations[i].latlng); // 中心点ではなく端点を候補にする
          if (
            state.stations[i].latlngs &&
            state.stations[i].latlngs.length >= 2
          ) {
            snapCandidates.push(state.stations[i].latlngs[0]);
            snapCandidates.push(
              state.stations[i].latlngs[state.stations[i].latlngs.length - 1]
            );
          }
        }

        for (i = 0; i < snapCandidates.length; i++) {
          var p = snapCandidates[i];
          var d = currentPointPx.distanceTo(map.latLngToLayerPoint(p));
          if (d < closest.dist && d < CONFIG.snapThresholdPixels) {
            closest = { point: p, dist: d };
          }
        }

        return closest.point;
      }
      // --- GHOST STYLE ---
      /**
       * 建設モードの仮表示（ゴースト）のスタイルを返す。
       * @param {string} type - 建設タイプ。
       * @returns {object} - Leafletのポリラインスタイルオブジェクト。
       */
      function ghostStyle(type) {
        var styles = {
          ground: { color: "#007bff", weight: 4, dashArray: "10,10" },
          viaduct: { color: "#0a0", weight: 4, dashArray: "5,5" },
          tunnel: { color: "#a0a", weight: 4, dashArray: "2,8" },
          station: {
            color: "#d9534f",
            weight: 6,
            opacity: 0.7,
            dashArray: "5, 10",
          },
          lineGhost: { color: "#888", weight: 5, dashArray: "5,10" }, // 路線設定中の仮線
        };
        return styles[type] || { color: "#000", weight: 4 };
      }

      // --- CONFIRM BUILD (TRACK/STATION): 建設の確定ロジック ---
      function confirmBuild() {
        if (!state.planning.type) {
          ui.showMessage("建設モードが選択されていません。", "warning");
          return;
        }
        if (state.planning.points.length < 2) {
          ui.showMessage("建設点が不足しています。", "warning", false, 3000);
          return;
        }

        var type = state.planning.type;
        var actualCost;
        var buildMessage;
        var points = state.planning.points;
        var len = points[0].distanceTo(points[1]);

        if (type === "station") {
          actualCost =
            CONFIG.costs.station.base + CONFIG.costs.station.perMeter * len;
          buildMessage = "プラットフォーム長 " + len.toFixed(1) + "m の駅";
        } else {
          actualCost = CONFIG.costs[type].perMeter * len;
          buildMessage =
            (type === "ground"
              ? "地上線"
              : type === "viaduct"
              ? "高架線"
              : "トンネル") +
            " (" +
            len.toFixed(1) +
            "m)";
        }

        if (state.assets < actualCost) {
          ui.showMessage("資金不足: 建設できません。", "error", false, 5000);
          return;
        }

        state.assets -= actualCost;

        if (type === "station") {
          var stationId = generateUniqueId();
          var stationName = "無名駅" + (state.stations.length + 1);
          var stationCenter = points[0];

          // 駅ホーム本体レイヤー
          var platformBodyLayer = L.polyline(points, {
            className: "station-platform-body",
            id: stationId,
          }).addTo(map);
          // 駅ホーム縁レイヤー
          var platformEdgeLayer = L.polyline(points, {
            className: "station-platform-edge",
            id: stationId,
          }).addTo(map);

          var marker = L.marker(stationCenter, {
            icon: L.divIcon({
              className: "station-marker",
              iconSize: [16, 16],
              html: "", // 路線設定モードで数字が入る
            }),
            id: stationId,
          }).addTo(map);

          var newStation = {
            id: stationId,
            name: stationName,
            latlng: stationCenter,
            latlngs: points,
            platformLength: len,
            bodyLayer: platformBodyLayer, // レイヤーを分割
            edgeLayer: platformEdgeLayer, // レイヤーを分割
            marker: marker,
            revenueMultiplier: 1.0, // 初期値は1.0、後で人口密度で更新
            passengersWaiting: [], // 新規追加: 駅で待機中の乗客リスト
            maxWaitingPassengers: Math.floor(
              len * CONFIG.maxWaitingPassengersPerMeterOfPlatform
            ), // 新規追加
          };
          state.stations.push(newStation);

          // 駅名ツールチップをバインド
          marker.bindTooltip(newStation.name, {
            permanent: true,
            direction: "top",
            className: "station-name-tooltip",
          });
          marker.getTooltip()._container.style.display =
            map.getZoom() >= 13 ? "block" : "none"; // ズームレベルに応じて表示/非表示

          marker.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var currentId = e.target.options.id;
            if (state.lineBuildingMode) {
              handleStationClickForLineBuilding(currentId);
            } else if (state.demolitionMode) {
              selectForDemolition("station", currentId);
            } else {
              // 修正2: 通常クリック時にポップアップを開く
              e.target.openPopup();
            }
          });
          platformBodyLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var currentId = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", currentId);
            }
          });
          platformEdgeLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var currentId = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", currentId);
            }
          });

          fetch(
            "https://nominatim.openstreetmap.org/reverse?format=json&lat=" +
              stationCenter.lat +
              "&lon=" +
              stationCenter.lng +
              "&zoom=18&addressdetails=1"
          )
            .then(function (response) {
              return response.json();
            })
            .then(function (data) {
              var resolvedName =
                "無名駅 (" + stationCenter.lat.toFixed(4) + ")";
              // var revenueMultiplier = 1.0; // 既存の地名APIからの収益倍率ロジックは削除

              if (data && data.address) {
                var addr = data.address;
                // 地名APIからの収益倍率設定ロジックは削除
                var nameCandidate =
                  addr.station ||
                  addr.railway ||
                  addr.town ||
                  addr.village ||
                  addr.suburb ||
                  addr.neighbourhood ||
                  addr.city;
                if (nameCandidate) {
                  resolvedName = nameCandidate.match(/(区|市|町|村|郡)$/)
                    ? nameCandidate
                    : nameCandidate + "駅";
                }
              }

              newStation.name = resolvedName;
              // newStation.revenueMultiplier = revenueMultiplier; // 既存の地名APIからの収益倍率設定ロジックは削除

              // 人口密度に基づいて収益倍率を設定
              setStationRevenueMultiplier(newStation);
              newStation.marker.getTooltip().setContent(newStation.name); // ツールチップも更新

              ui.showMessage(
                resolvedName +
                  "を建設しました！ (" +
                  buildMessage +
                  ", $" +
                  Math.round(actualCost).toLocaleString() +
                  ")",
                "success",
                false,
                2500
              );
              ui.renderTrainShop();
            })
            .catch(function (error) {
              console.error("地名APIの取得に失敗しました:", error);
              // 地名APIが失敗しても人口密度は設定する
              newStation.name = "無名駅 (" + stationCenter.lat.toFixed(4) + ")";
              setStationRevenueMultiplier(newStation);
              newStation.marker.getTooltip().setContent(newStation.name); // ツールチップも更新
              ui.showMessage(
                "地名取得失敗: " +
                  newStation.name +
                  "を建設しました。 (" +
                  buildMessage +
                  ", $" +
                  Math.round(actualCost).toLocaleString() +
                  ")",
                "warning",
                false,
                2500
              );
            });
        } else {
          // 線路建設
          var trackId = generateUniqueId();
          var railLayer = L.polyline(points, {
            className: "track-rail track-" + type + "-rail",
            id: trackId,
          }).addTo(map);
          var sleeperLayer = L.polyline(points, {
            className: "track-sleeper track-" + type + "-sleeper",
            id: trackId,
          }).addTo(map);

          state.tracks.push({
            id: trackId,
            latlngs: points,
            railLayer: railLayer, // レイヤーを分割
            sleeperLayer: sleeperLayer, // レイヤーを分割
            type: type,
          });

          railLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", this.options.id);
            }
          });
          sleeperLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", e.target.options.id);
            }
          });

          ui.showMessage(
            buildMessage +
              "を建設しました！ ($" +
              Math.round(actualCost).toLocaleString() +
              ")",
            "success",
            false,
            2000
          );
        }

        if (state.planning.ghost) {
          map.removeLayer(state.planning.ghost);
          state.planning.ghost = null;
        }
        state.planning.points = [];
        state.planning.type = null;
        map.dragging.enable();
        map.getContainer().classList.remove("build-mode-cursor"); // カーソルを元に戻す
        ui.resetBuildModeActive();
        ui.updateFinance();
      }

      // ズームレベルに応じて駅名ツールチップの表示/非表示を切り替える
      map.on("zoomend", function () {
        var currentZoom = map.getZoom();
        for (var i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (station.marker && station.marker.getTooltip()) {
            station.marker.getTooltip()._container.style.display =
              currentZoom >= 13 ? "block" : "none";
          }
        }
      });

      // --- TRAIN SHOP LOGIC: 列車ショップの機能 ---

      /** 購入する列車を選択する。 */
      function selectTrainToBuy(trainId) {
        state.selectedTrainToBuyId = trainId;
        ui.renderTrainShop();
      }

      /** 選択された列車を購入する。 */
      function buySelectedTrain() {
        var trainToBuyConfig = CONFIG.trains.find(function (t) {
          return t.id === state.selectedTrainToBuyId;
        });
        if (!trainToBuyConfig) {
          ui.showMessage("列車が選択されていません。", "warning");
          return;
        }
        if (state.assets < trainToBuyConfig.cost) {
          ui.showMessage("資金不足: 列車を購入できません。", "error", false, 5000);
          return;
        }

        state.assets -= trainToBuyConfig.cost;
        var newTrain = {
          id: generateUniqueId(),
          type: trainToBuyConfig.id,
          name: trainToBuyConfig.name,
          cars: trainToBuyConfig.cars,
          cost: trainToBuyConfig.cost,
          color: trainToBuyConfig.color,
          speed: trainToBuyConfig.defaultSpeed,
          totalLength:
            trainToBuyConfig.cars * CONFIG.trainCarDimensionsMeters.length,
          currentStationId: null,
          currentLineId: null,
          currentSegmentIndex: 0,
          direction: 1,
          progress: 0,
          isStopped: false,
          stopTimer: null,
          carMarkers: [], // 変更: carLayersからcarMarkersへ
          currentLatLng: null,
          currentHeading: 0,
          currentPassengers: [], // 変更: 乗客オブジェクトの配列
          maxCapacity: trainToBuyConfig.cars * CONFIG.passengerCapacityPerCar, // 新規追加: 最大乗客容量
        };
        state.trains.push(newTrain);

        ui.updateFinance();
        ui.showMessage(trainToBuyConfig.name + "を購入しました！", "success", false, 2000);
        state.selectedTrainToBuyId = null;
        ui.renderTrainShop();
      }

      /** 路線に割り当てる列車を選択する。 */
      function selectTrainToAssign(trainId) {
        state.selectedTrainToAssignId = trainId;
        ui.renderTrainShop();
      }

      /**
       * 指定された路線の総車両数と総列車数を更新する。
       * 列車が路線に割り当てられたり、割り当てが解除されたりするたびに呼び出す。
       * @param {string} lineId - 路線のID。
       */
      function updateLineTrainCounts(lineId) {
        var line = getLineById(lineId);
        if (!line) return;

        line.totalTrainsOnLine = 0;
        line.totalCarsOnLine = 0;

        for (var i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];
          if (train.currentLineId === lineId) {
            line.totalTrainsOnLine++;
            line.totalCarsOnLine += train.cars;
          }
        }
      }

      /** 選択された列車を路線に割り当てる。 */
      function assignSelectedTrainToLine() {
        var trainId = state.selectedTrainToAssignId;
        var lineId = ui.lineSelectForAssignment.value;

        if (!trainId || !lineId) {
          ui.showMessage("列車と路線を選択してください。", "warning");
          return;
        }

        var train = state.trains.find(function (t) {
          return t.id === trainId;
        });
        var line = getLineById(lineId);

        if (!train || !line) {
          ui.showMessage("無効な列車または路線です。", "error");
          return;
        }
        if (line.segments.length === 0) {
          ui.showMessage("選択された路線には有効なセグメントがありません。", "warning");
          return;
        }

        // 以前の路線から列車を外す
        if (train.currentLineId) {
          var oldLine = getLineById(train.currentLineId);
          if (oldLine && oldLine.assignedTrainIds) {
            oldLine.assignedTrainIds = oldLine.assignedTrainIds.filter(
              function (id) {
                return id !== train.id;
              }
            );
            updateLineTrainCounts(oldLine.id); // 以前の路線の列車数を更新
          }
          // 列車が路線から外れる際に、マップ上のマーカーを削除
          if (train.carMarkers) {
            for (var k = 0; k < train.carMarkers.length; k++) {
              if (train.carMarkers[k] && map.hasLayer(train.carMarkers[k])) {
                map.removeLayer(train.carMarkers[k]);
              }
            }
          }
          train.carMarkers = []; // マーカー配列をクリア
        }

        train.currentLineId = line.id;
        train.currentSegmentIndex = 0;
        train.direction = 1;
        train.progress = 0;
        train.isStopped = false;
        train.stopTimer = null;
        train.currentStationId = null;
        train.currentPassengers = []; // 路線割り当て時に乗客をリセット

        var firstSegment = line.segments[0];
        if (firstSegment && firstSegment.latlngs.length > 0) {
          train.currentLatLng = firstSegment.latlngs[0];
          train.currentHeading = getHeading(
            firstSegment.latlngs[0],
            firstSegment.latlngs[1] || firstSegment.latlngs[0]
          );
        } else {
          console.warn("路線の最初のセグメントが見つかりません。");
          train.currentLineId = null;
          return;
        }

        if (!line.assignedTrainIds) {
          line.assignedTrainIds = [];
        }
        line.assignedTrainIds.push(train.id);

        updateLineTrainCounts(line.id); // 新しい路線の列車数を更新

        ui.showMessage(
          train.name + "を路線 " + line.name + "に割り当てました。",
          "success",
          false,
          2000
        );
        state.selectedTrainToAssignId = null;
        ui.renderTrainShop();
        renderTrains(); // 列車が割り当てられたらレンダリングを更新
      }

      // --- LINE BUILDING LOGIC: 路線設定の機能 ---

      /** 路線設定モードを開始する。 */
      function startLineBuilding() {
        if (state.lineBuildingMode) {
          cancelLineBuilding();
          return;
        }

        deactivateAllModes();
        state.lineBuildingMode = true;
        state.selectedStationsForLine = [];
        if (state.currentLineGhost) {
          map.removeLayer(state.currentLineGhost);
          state.currentLineGhost = null;
        }
        ui.showMessage(
          "路線設定モードを開始しました。駅をクリックして路線に追加してください。",
          "info",
          true
        );
        ui.setLineBuildModeActive(true);
        map.dragging.disable();

        var i;
        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (station.marker && station.marker._icon) {
            station.marker._icon.classList.add("station-marker-selectable");
          }
        }
        ui.updateSelectedStationsForLine();
      }

      /**
       * 路線設定モード中に駅がクリックされたときのハンドラ。
       * @param {string} stationId - クリックされた駅のID。
       */
      function handleStationClickForLineBuilding(stationId) {
        if (!state.lineBuildingMode) return;

        var station = getStationById(stationId);
        if (!station) return;

        var index = state.selectedStationsForLine.indexOf(stationId);
        if (index > -1) {
          removeStationFromLineBuilding(stationId);
          ui.showMessage(
            station.name + "を路線から削除しました。",
            "info",
            false,
            1500
          );
        } else {
          state.selectedStationsForLine.push(stationId);
          ui.showMessage(station.name + "を路線に追加しました。", "info", false, 1500);
          if (station.marker && station.marker._icon) {
            station.marker._icon.classList.add("selected-for-line");
          }
        }

        ui.updateSelectedStationsForLine();
        updateLineGhost();

        // 駅マーカーの番号を更新
        for (var i = 0; i < state.stations.length; i++) {
          var s = state.stations[i];
          var idx = state.selectedStationsForLine.indexOf(s.id);
          if (s.marker && s.marker.getElement()) {
            s.marker.getElement().innerHTML = idx > -1 ? idx + 1 : "";
          }
        }
      }

      /**
       * 路線設定モードから駅を削除する。
       * @param {string} stationIdToRemove - 削除する駅のID。
       */
      function removeStationFromLineBuilding(stationIdToRemove) {
        var index = state.selectedStationsForLine.indexOf(stationIdToRemove);
        if (index > -1) {
          state.selectedStationsForLine.splice(index, 1);
        }

        var station = getStationById(stationIdToRemove);
        if (station && station.marker && station.marker._icon) {
          station.marker._icon.classList.remove("selected-for-line");
          station.marker.getElement().innerHTML = ""; // 番号をクリア
        }
        ui.updateSelectedStationsForLine();
        updateLineGhost();

        // 残りの駅の番号を更新
        for (var i = 0; i < state.stations.length; i++) {
          var s = state.stations[i];
          var idx = state.selectedStationsForLine.indexOf(s.id);
          if (s.marker && s.marker.getElement()) {
            s.marker.getElement().innerHTML = idx > -1 ? idx + 1 : "";
          }
        }
      }

      /** 路線設定中の仮ポリライン（ゴースト）を更新する。 */
      function updateLineGhost() {
        if (state.currentLineGhost) {
          map.removeLayer(state.currentLineGhost);
          state.currentLineGhost = null;
        }
        if (state.selectedStationsForLine.length < 2) {
          return;
        }

        var ghostPath = [];
        var pathFound = true;
        for (var i = 0; i < state.selectedStationsForLine.length - 1; i++) {
          var startStation = getStationById(state.selectedStationsForLine[i]);
          var endStation = getStationById(state.selectedStationsForLine[i + 1]);
          if (startStation && endStation) {
            var segmentPath = findPathBetweenStations_GraphSearch(
              startStation.latlng,
              endStation.latlng
            );

            if (segmentPath) {
              if (
                ghostPath.length > 0 &&
                segmentPath.length > 0 &&
                ghostPath[ghostPath.length - 1].equals(segmentPath[0])
              ) {
                Array.prototype.push.apply(ghostPath, segmentPath.slice(1));
              } else {
                Array.prototype.push.apply(ghostPath, segmentPath);
              }
            } else {
              pathFound = false;
              ui.showMessage(
                "警告: " +
                  startStation.name +
                  " と " +
                  endStation.name +
                  " 間に接続された線路がありません。",
                "warning",
                false,
                4000
              );
              break;
            }
          }
        }

        if (pathFound && ghostPath.length >= 2) {
          state.currentLineGhost = L.polyline(
            ghostPath,
            ghostStyle("lineGhost")
          ).addTo(map);
        }
      }

      /** 路線設定を確定する。 */
      function confirmLineBuilding() {
        if (state.selectedStationsForLine.length < 2) {
          ui.showMessage("路線には2つ以上の駅が必要です。", "warning");
          return;
        }

        var totalLineDistance = 0;
        var lineSegmentsForTrainMovement = [];
        var linePathLatLngsForDisplay = [];
        var pathFoundSuccessfully = true;

        for (var i = 0; i < state.selectedStationsForLine.length - 1; i++) {
          var startStation = getStationById(state.selectedStationsForLine[i]);
          var endStation = getStationById(state.selectedStationsForLine[i + 1]);

          if (startStation && endStation) {
            var segmentPath = findPathBetweenStations_GraphSearch(
              startStation.latlng,
              endStation.latlng
            );

            if (segmentPath) {
              var distance = calculatePathDistance(segmentPath);
              totalLineDistance += distance;
              lineSegmentsForTrainMovement.push({
                startStationId: startStation.id,
                endStationId: endStation.id,
                latlngs: segmentPath,
                distance: distance,
              });
              if (linePathLatLngsForDisplay.length > 0) {
                Array.prototype.push.apply(
                  linePathLatLngsForDisplay,
                  segmentPath.slice(1)
                );
              } else {
                Array.prototype.push.apply(
                  linePathLatLngsForDisplay,
                  segmentPath
                );
              }
            } else {
              pathFoundSuccessfully = false;
              ui.showMessage(
                "エラー: " +
                  startStation.name +
                  "から" +
                  endStation.name +
                  "への経路が見つかりませんでした。路線を作成できません。",
                "error",
                false,
                5000
              );
              break;
            }
          }
        }

        if (!pathFoundSuccessfully) {
          return;
        }

        var actualLineCost =
          CONFIG.costs.line.base +
          CONFIG.costs.line.perMeter * totalLineDistance;
        if (state.assets < actualLineCost) {
          ui.showMessage("資金不足: 路線を確定できません。", "error", false, 5000);
          return;
        }

        state.assets -= actualLineCost;

        var lineId = generateUniqueId();
        var lineColor = CONFIG.lineColors[state.currentLineColorIndex];
        state.currentLineColorIndex =
          (state.currentLineColorIndex + 1) % CONFIG.lineColors.length;

        // 路線名を入力させるプロンプトを追加
        var lineName = prompt("路線の名前を入力してください:", "新路線");
        if (!lineName || lineName.trim() === "") {
          lineName = "無名路線 " + (state.lines.length + 1);
        }

        var lineLayer = L.polyline(linePathLatLngsForDisplay, {
          className: "line-color",
          color: lineColor,
          weight: 5,
          opacity: 0.8,
          id: lineId,
        }).addTo(map);

        state.lines.push({
          id: lineId,
          name: lineName, // 路線名を追加
          stationIds: [].concat(state.selectedStationsForLine),
          color: lineColor,
          layer: lineLayer,
          segments: lineSegmentsForTrainMovement,
          totalDistance: totalLineDistance,
          assignedTrainIds: [],
          totalTrainsOnLine: 0, // 新規追加: 路線上の総列車数
          totalCarsOnLine: 0, // 新規追加: 路線上の総車両数
        });

        ui.updateFinance();
        ui.showMessage(
          lineName +
            "を確定しました！ (総距離 " +
            totalLineDistance.toFixed(1) +
            "m, コスト $" +
            Math.round(actualLineCost).toLocaleString() +
            ")",
          "success",
          false,
          2000
        );
        cancelLineBuilding();
        ui.renderTrainShop();
      }

      /** 路線設定をキャンセルする。 */
      function cancelLineBuilding() {
        state.lineBuildingMode = false;
        var i;
        for (i = 0; i < state.selectedStationsForLine.length; i++) {
          var station = getStationById(state.selectedStationsForLine[i]);
          if (station && station.marker && station.marker._icon) {
            station.marker._icon.classList.remove("selected-for-line");
            station.marker.getElement().innerHTML = ""; // 番号をクリア
          }
        }
        state.selectedStationsForLine = [];
        if (state.currentLineGhost) {
          map.removeLayer(state.currentLineGhost);
          state.currentLineGhost = null;
        }
        ui.showMessage("路線設定をキャンセルしました。", "info");
        ui.setLineBuildModeActive(false);
        ui.updateSelectedStationsForLine();
        map.dragging.enable();

        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (station.marker && station.marker._icon) {
            station.marker._icon.classList.remove("station-marker-selectable");
          }
        }
      }

      // --- DEMOLITION LOGIC: 解体機能 ---
      /** 解体モードを開始する。 */
      function startDemolitionMode() {
        if (state.demolitionMode) {
          cancelDemolition();
          return;
        }
        deactivateAllModes();
        state.demolitionMode = true;
        state.selectedForDemolition = null;
        ui.showMessage(
          "解体モード: 解体したい線路や駅をクリックしてください。",
          "info",
          true
        );
        ui.setDemolitionModeActive(true);
        map.dragging.disable();
      }

      /**
       * 解体モード中にマップ上のオブジェクトがクリックされたときのハンドラ。
       * @param {string} type - 'track' または 'station'。
       * @param {string} id - オブジェクトのID。
       */
      function selectForDemolition(type, id) {
        if (!state.demolitionMode) return;

        var demolitionTargetDisplayMap = {
          track: function (id) {
            return "選択中: 線路 (ID: " + id.substring(0, 5) + "...)";
          },
          station: function (id) {
            var station = getStationById(id);
            return "選択中: 駅 (" + (station ? station.name : "不明") + ")";
          },
        };

        // ハイライト解除
        if (state.selectedForDemolition) {
          var prevType = state.selectedForDemolition.type;
          var prevId = state.selectedForDemolition.id;
          var prevObj =
            prevType === "track"
              ? getTrackById(prevId)
              : getStationById(prevId);
          if (prevObj) {
            if (prevType === "track") {
              if (prevObj.railLayer && prevObj.railLayer._path)
                prevObj.railLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (prevObj.sleeperLayer && prevObj.sleeperLayer._path)
                prevObj.sleeperLayer._path.classList.remove(
                  "selected-for-demolition"
                );
            } else if (prevType === "station") {
              if (prevObj.bodyLayer && prevObj.bodyLayer._path)
                prevObj.bodyLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (prevObj.edgeLayer && prevObj.edgeLayer._path)
                prevObj.edgeLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (prevObj.marker && prevObj.marker._icon)
                prevObj.marker._icon.classList.remove(
                  "selected-for-demolition"
                );
            }
          }
        }

        // 新しいオブジェクトを選択し、ハイライト
        state.selectedForDemolition = { type: type, id: id };
        var currentObj =
          type === "track" ? getTrackById(id) : getStationById(id);
        if (currentObj) {
          if (type === "track") {
            if (currentObj.railLayer && currentObj.railLayer._path)
              currentObj.railLayer._path.classList.add(
                "selected-for-demolition"
              );
            if (currentObj.sleeperLayer && currentObj.sleeperLayer._path)
              currentObj.sleeperLayer._path.classList.add(
                "selected-for-demolition"
              );
          } else if (type === "station") {
            if (currentObj.bodyLayer && currentObj.bodyLayer._path)
              currentObj.bodyLayer._path.classList.add(
                "selected-for-demolition"
              );
            if (currentObj.edgeLayer && currentObj.edgeLayer._path)
              currentObj.edgeLayer._path.classList.add(
                "selected-for-demolition"
              );
            if (currentObj.marker && currentObj.marker._icon)
              currentObj.marker._icon.classList.add("selected-for-demolition");
          }
          ui.selectedDemolitionTargetDisplay.textContent =
            demolitionTargetDisplayMap[type](id);
        }
        ui.confirmDemolitionButton.disabled = false;
      }

      /** 選択されたオブジェクトを解体する。 */
      function confirmDemolition() {
        if (!state.selectedForDemolition) {
          ui.showMessage("解体するオブジェクトが選択されていません。", "warning");
          return;
        }

        var type = state.selectedForDemolition.type;
        var id = state.selectedForDemolition.id;
        var i;

        if (type === "track") {
          var trackIndex = state.tracks.findIndex(function (t) {
            return t.id === id;
          });
          if (trackIndex === -1) {
            return;
          }

          var trackToDemolish = state.tracks[trackIndex];
          map.removeLayer(trackToDemolish.railLayer);
          map.removeLayer(trackToDemolish.sleeperLayer);
          state.tracks.splice(trackIndex, 1);
          ui.showMessage("線路を解体しました。", "success", false, 2000);

          // この線路を使用していた可能性のある全ての路線を再検証・削除
          var affectedLines = state.lines.filter(function (line) {
            return !line.segments.every(function (seg) {
              var start = getStationById(seg.startStationId);
              var end = getStationById(seg.endStationId);
              return (
                start &&
                end &&
                findPathBetweenStations_GraphSearch(
                  start.latlng,
                  end.latlng
                ) !== null
              );
            });
          });
          for (i = 0; i < affectedLines.length; i++) {
            removeLine(affectedLines[i].id);
          }
        } else if (type === "station") {
          var stationIndex = state.stations.findIndex(function (s) {
            return s.id === id;
          });
          if (stationIndex === -1) {
            return;
          }
          var stationToDemolish = state.stations[stationIndex];

          map.removeLayer(stationToDemolish.bodyLayer);
          map.removeLayer(stationToDemolish.edgeLayer);
          map.removeLayer(stationToDemolish.marker);
          if (stationToDemolish.marker.getTooltip()) {
            map.removeLayer(stationToDemolish.marker.getTooltip());
          } // ツールチップも削除
          state.stations.splice(stationIndex, 1);
          ui.showMessage(
            stationToDemolish.name + "を解体しました。",
            "success",
            false,
            2000
          );

          // この駅を含む路線を全て削除
          var linesToRemove = state.lines.filter(function (line) {
            return line.stationIds.includes(id);
          });
          for (i = 0; i < linesToRemove.length; i++) {
            removeLine(linesToRemove[i].id);
          }
        }

        cancelDemolition();
        ui.renderTrainShop();
      }

      /** 路線を削除するヘルパー関数 */
      function removeLine(lineId) {
        var lineIndex = state.lines.findIndex(function (l) {
          return l.id === lineId;
        });
        if (lineIndex === -1) return;

        var lineToRemove = state.lines[lineIndex];

        var i, j;
        if (lineToRemove.assignedTrainIds) {
          for (i = 0; i < lineToRemove.assignedTrainIds.length; i++) {
            var train = state.trains.find(function (t) {
              return t.id === lineToRemove.assignedTrainIds[i];
            });
            if (train) {
              train.currentLineId = null;
              // 既存の carLayers を削除する代わりに carMarkers を削除
              if (train.carMarkers) {
                for (j = 0; j < train.carMarkers.length; j++) {
                  if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                    map.removeLayer(train.carMarkers[j]);
                  }
                }
                train.carMarkers = []; // クリア
              }
              train.currentLatLng = null;
              train.isStopped = true;
              if (train.stopTimer) clearTimeout(train.stopTimer);
              train.currentPassengers = [];
            }
          }
        }

        map.removeLayer(lineToRemove.layer);
        state.lines.splice(lineIndex, 1);
        ui.showMessage(
          "路線 " + lineToRemove.name + " が削除されました。",
          "info",
          false,
          3000
        );
        ui.renderTrainShop(); // 列車ショップも更新して、割り当て解除を反映
      }

      /** 解体モードをキャンセルする。 */
      function cancelDemolition() {
        if (state.selectedForDemolition) {
          var type = state.selectedForDemolition.type;
          var id = state.selectedForDemolition.id;
          var obj = type === "track" ? getTrackById(id) : getStationById(id);
          if (obj) {
            if (type === "track") {
              if (obj.railLayer && obj.railLayer._path)
                obj.railLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (obj.sleeperLayer && obj.sleeperLayer._path)
                obj.sleeperLayer._path.classList.remove(
                  "selected-for-demolition"
                );
            } else if (type === "station") {
              if (obj.bodyLayer && obj.bodyLayer._path)
                obj.bodyLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (obj.edgeLayer && obj.edgeLayer._path)
                obj.edgeLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (obj.marker && obj.marker._icon)
                obj.marker._icon.classList.remove("selected-for-demolition");
            }
          }
        }
        state.demolitionMode = false;
        state.selectedForDemolition = null;
        ui.showMessage("解体モードをキャンセルしました。", "info");
        ui.setDemolitionModeActive(false);
        map.dragging.enable();
      }

      // --- TRAIN MOVEMENT LOGIC: 列車移動の計算と更新 ---
      /** 全列車の位置と状態を更新する。 */
      function updateTrains() {
        var deltaTime =
          (CONFIG.updateInterval / 1000) * state.gameSpeedMultiplier; // 秒単位
        var i;

        for (i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];

          if (!train.currentLineId || train.isStopped) {
            continue;
          }

          var line = getLineById(train.currentLineId);
          if (!line || !line.segments || line.segments.length === 0) {
            console.warn(
              "Train " + train.id + ": Invalid line. Stopping train."
            );
            train.currentLineId = null;
            train.isStopped = true;
            continue;
          }

          var currentSegment = line.segments[train.currentSegmentIndex];
          if (
            !currentSegment ||
            !currentSegment.latlngs ||
            currentSegment.latlngs.length < 2
          ) {
            console.warn(
              "Train " + train.id + ": Invalid segment. Stopping train."
            );
            train.currentLineId = null;
            train.isStopped = true;
            continue;
          }

          var speed_mps = (train.speed * 1000) / 3600; // km/h を m/s に変換
          var distanceMoved = speed_mps * deltaTime;
          var segmentLength = currentSegment.distance;
          if (segmentLength === 0) {
            // ゼロ除算対策
            train.progress = train.direction === 1 ? 1.0 : 0;
            handleArrival(
              train,
              line,
              train.direction === 1
                ? line.stationIds[train.currentSegmentIndex + 1]
                : line.stationIds[train.currentSegmentIndex],
              train.progress
            );
            continue;
          }

          var progressChange = distanceMoved / segmentLength;
          train.progress += train.direction * progressChange;

          // 進行方向に応じて終点・始点チェック
          if (train.direction === 1 && train.progress >= 1.0) {
            // 順方向で終点到着
            var arrivedStationId =
              line.stationIds[train.currentSegmentIndex + 1];
            handleArrival(train, line, arrivedStationId, 1.0);
          } else if (train.direction === -1 && train.progress <= 0) {
            // 逆方向で始点到着
            var arrivedStationId = line.stationIds[train.currentSegmentIndex];
            handleArrival(train, line, arrivedStationId, 0);
          } else {
            // セグメント内を移動中
            var data = getLatLngAtProgressOnPath(
              currentSegment.latlngs,
              train.progress
            );
            if (data) {
              train.currentLatLng = data.latlng;
              train.currentHeading = data.heading;
              if (train.direction === -1) {
                train.currentHeading = (train.currentHeading + 180) % 360;
              }
            }
          }
        }

        renderTrains();
      }

      /**
       * 駅到着時の処理をまとめたヘルパー関数
       */
      function handleArrival(train, line, arrivedStationId, progressAtArrival) {
        train.progress = progressAtArrival;
        var station = getStationById(arrivedStationId); // station変数名に変更

        function moveToNextSegment() {
          if (train.direction === 1) {
            // 順方向
            if (train.currentSegmentIndex >= line.segments.length - 1) {
              // 路線の終点
              train.direction = -1; // 方向転換
            } else {
              train.currentSegmentIndex++;
              train.progress = 0;
            }
          } else {
            // 逆方向
            if (train.currentSegmentIndex <= 0) {
              // 路線の始点
              train.direction = 1; // 方向転換
            } else {
              train.currentSegmentIndex--;
              train.progress = 1.0;
            }
          }
        }

        if (
          station && // station変数名に変更
          station.platformLength >= train.totalLength
        ) {
          train.isStopped = true;
          train.currentStationId = arrivedStationId;
          train.currentLatLng = station.latlng; // station変数名に変更

          // --- 乗客の降車処理 ---
          var passengersDisembarked = 0;
          var remainingPassengers = [];
          for (var i = 0; i < train.currentPassengers.length; i++) {
            var passenger = train.currentPassengers[i];
            if (passenger.destinationStationId === arrivedStationId) {
              // 変更点: 駅のrevenueMultiplierを乗算
              state.assets +=
                CONFIG.passengerRevenuePerPerson * station.revenueMultiplier; // station変数名に変更
              passengersDisembarked++;
            } else {
              remainingPassengers.push(passenger);
            }
          }
          train.currentPassengers = remainingPassengers;
          if (passengersDisembarked > 0) {
            ui.showMessage(
              passengersDisembarked +
                "人の乗客が" +
                station.name + // station変数名に変更
                "で降車し、$" +
                (
                  passengersDisembarked *
                  CONFIG.passengerRevenuePerPerson *
                  station.revenueMultiplier // station変数名に変更
                ).toLocaleString() + // ここも表示に合わせて変更
                "の収益を得ました。",
              "success",
              false,
              2000
            );
          }

          // --- 乗客の乗車処理 (最適化) ---
          var availableCapacity =
            train.maxCapacity - train.currentPassengers.length;
          var passengersBoardedCount = 0;
          var passengersToBoard = [];
          var currentLineStationIds = line.stationIds;
          var nextStationId = null;

          if (
            train.direction === 1 &&
            train.currentSegmentIndex < line.stationIds.length - 1
          ) {
            nextStationId = line.stationIds[train.currentSegmentIndex + 1];
          } else if (train.direction === -1 && train.currentSegmentIndex > 0) {
            nextStationId = line.stationIds[train.currentSegmentIndex - 1];
          }

          var tempPassengersWaiting = []; // 駅に残る乗客を一時的に保持する配列

          // 1. 次の停車駅を目的地とする乗客を優先的に乗せる
          for (var i = 0; i < station.passengersWaiting.length; i++) {
            var p = station.passengersWaiting[i];
            if (
              passengersBoardedCount < availableCapacity &&
              p.destinationStationId === nextStationId
            ) {
              passengersToBoard.push(p);
              passengersBoardedCount++;
            } else {
              tempPassengersWaiting.push(p);
            }
          }
          station.passengersWaiting = tempPassengersWaiting; // 処理済みの乗客を削除し、残りを更新

          tempPassengersWaiting = []; // リセット

          // 2. この路線の他の駅を目的地とする乗客を乗せる
          for (var i = 0; i < station.passengersWaiting.length; i++) {
            var p = station.passengersWaiting[i];
            if (
              passengersBoardedCount < availableCapacity &&
              currentLineStationIds.includes(p.destinationStationId)
            ) {
              passengersToBoard.push(p);
              passengersBoardedCount++;
            } else {
              tempPassengersWaiting.push(p);
            }
          }
          station.passengersWaiting = tempPassengersWaiting; // 処理済みの乗客を削除し、残りを更新

          tempPassengersWaiting = []; // リセット

          // 3. 最後に、その他の駅を目的地とする乗客を乗せる（この路線上ではないが、どこかの駅へ向かう乗客）
          for (var i = 0; i < station.passengersWaiting.length; i++) {
            var p = station.passengersWaiting[i];
            if (passengersBoardedCount < availableCapacity) {
              passengersToBoard.push(p);
              passengersBoardedCount++;
            } else {
              tempPassengersWaiting.push(p);
            }
          }
          station.passengersWaiting = tempPassengersWaiting; // 最終的に駅に残る乗客

          Array.prototype.push.apply(train.currentPassengers, passengersToBoard);

          if (passengersBoardedCount > 0) {
            ui.showMessage(
              passengersBoardedCount +
                "人の乗客が" +
                station.name +
                "で乗車しました。",
              "info",
              false,
              2000
            );
          }

          train.stopTimer = setTimeout(function () {
            train.isStopped = false;
            train.currentStationId = null;
            moveToNextSegment();
            ui.renderTrainShop(); // 乗客数表示を更新するため
            setStationRevenueMultiplier(station); // 駅の待機乗客数も更新されるためポップアップを更新
          }, CONFIG.trainStopDuration / state.gameSpeedMultiplier); // 倍速適用
        } else {
          if (station) {
            // station変数名に変更
            ui.showMessage(
              train.name +
                "は" +
                station.name + // station変数名に変更
                "を通過します(プラットフォーム長不足または停車しない駅)。",
              "warning",
              false,
              3000
            );
          }
          moveToNextSegment();
        }
        ui.updateFinance(); // 収益更新
      }

      // --- PASSENGER GENERATION LOGIC: 乗客生成ロジック ---

      /**
       * 各駅で定期的に乗客を生成する。
       * 生成される乗客の数は、駅の人口密度と路線の供給状況に応じて変動する。
       */
      function generatePassengersAtStations() {
        var i, j;
        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (!station.revenueMultiplier) continue;

          // 人口密度に基づく基本乗客生成量
          var baseCount = Math.floor(
            CONFIG.basePassengerGeneration * station.revenueMultiplier
          );

          // この駅を通る路線の供給状況を考慮
          var totalLineCarsAtStation = 0;
          var linesServingStation = state.lines.filter(function (line) {
            return line.stationIds.includes(station.id);
          });

          for (j = 0; j < linesServingStation.length; j++) {
            totalLineCarsAtStation += linesServingStation[j].totalCarsOnLine;
          }

          // 供給量に応じた乗客生成ボーナス/ペナルティ
          // 輸送能力が過剰になると、供給係数の増加が鈍化、あるいは頭打ちになるように調整
          var supplyFactor = 1.0;
          if (totalLineCarsAtStation > 0) {
            var optimalTotalCars =
              linesServingStation.length * CONFIG.optimalCarsPerLineSegment;
            if (optimalTotalCars === 0)
              optimalTotalCars = CONFIG.optimalCarsPerLineSegment; // 路線がない場合のゼロ除算対策

            // 対数関数で増加を鈍化させ、最大値を設定
            supplyFactor =
              1 + Math.log(1 + totalLineCarsAtStation / optimalTotalCars) * 0.8;
            supplyFactor = Math.min(supplyFactor, 2.5); // 最大2.5倍に制限
          }

          var actualCount = Math.floor(baseCount * supplyFactor);

          // 駅の最大待機乗客数を超えないように生成量を制限
          var availableSlots =
            station.maxWaitingPassengers - station.passengersWaiting.length;
          actualCount = Math.min(actualCount, availableSlots);
          actualCount = Math.max(0, actualCount); // マイナスにならないように

          for (var k = 0; k < actualCount; k++) {
            var destinationStation = null;
            var attempts = 0;
            while (
              !destinationStation &&
              attempts < CONFIG.passengerMaxDestinationAttempts
            ) {
              var randomIndex = Math.floor(Math.random() * state.stations.length);
              var potentialDestination = state.stations[randomIndex];
              if (potentialDestination.id !== station.id) {
                destinationStation = potentialDestination;
              }
              attempts++;
            }

            if (destinationStation) {
              station.passengersWaiting.push({
                id: generateUniqueId(),
                destinationStationId: destinationStation.id,
              });
            }
          }
          // 駅のポップアップを更新
          if (station.marker && station.marker.getPopup()) {
            setStationRevenueMultiplier(station); // これでポップアップも更新される
          }
        }
      }

      /**
       * ゲーム内時間を更新する。
       */
      function updateGameTime() {
        state.gameTime += CONFIG.gameTimeInterval * state.gameSpeedMultiplier * CONFIG.gameTimeScale;
        ui.updateGameTimeDisplay();
      }

      /**
       * ゲーム速度を設定し、タイマーを再設定する。
       * @param {number} multiplier - 速度倍率 (例: 1, 2, 4, 8)
       */
      function setGameSpeed(multiplier) {
        state.gameSpeedMultiplier = multiplier;

        // 既存のインターバルをクリア
        if (state.trainUpdateIntervalId) {
          clearInterval(state.trainUpdateIntervalId);
        }
        if (state.passengerGenerationIntervalId) {
          clearInterval(state.passengerGenerationIntervalId);
        }
        if (state.gameTimeIntervalId) {
          clearInterval(state.gameTimeIntervalId);
        }

        // 新しいインターバルを設定
        state.trainUpdateIntervalId = setInterval(
          updateTrains,
          CONFIG.updateInterval / state.gameSpeedMultiplier
        );
        state.passengerGenerationIntervalId = setInterval(
          generatePassengersAtStations,
          CONFIG.passengerGenerationInterval / state.gameSpeedMultiplier
        );
        state.gameTimeIntervalId = setInterval(
          updateGameTime,
          CONFIG.gameTimeInterval / state.gameSpeedMultiplier
        );

        // UIのボタンのアクティブ状態を更新
        var speedButtons = document.querySelectorAll(
          "#game-speed-control .speed-btn"
        );
        for (var i = 0; i < speedButtons.length; i++) {
          if (parseInt(speedButtons[i].dataset.speed) === multiplier) {
            speedButtons[i].classList.add("active");
          } else {
            speedButtons[i].classList.remove("active");
          }
        }
        ui.showMessage("ゲーム速度を " + multiplier + "倍に設定しました。", "info", false, 1500);
      }

      // --- RENDER TRAINS: マップ上での列車の描画とアニメーション ---
      /** 全列車の車両をマップ上に描画または更新する。 */
      function renderTrains() {
        var i, j;
        for (i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];

          if (!train.currentLineId || !train.currentLatLng) {
            // 列車が路線に割り当てられていない、または位置情報がない場合は、既存のマーカーを削除
            if (train.carMarkers) {
              for (j = 0; j < train.carMarkers.length; j++) {
                if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                  map.removeLayer(train.carMarkers[j]);
                }
              }
            }
            train.carMarkers = []; // クリア
            continue;
          }

          var line = getLineById(train.currentLineId);
          if (!line) continue;

          var carLengthMeters = CONFIG.trainCarDimensionsMeters.length;
          var currentSegment = line.segments[train.currentSegmentIndex];
          var headDistanceInSegment = currentSegment.distance * train.progress;

          // carMarkers配列のサイズ調整
          // 既存のマーカー数が車両数と異なる場合は、すべて削除して再作成
          if (!train.carMarkers || train.carMarkers.length !== train.cars) {
            if (train.carMarkers) {
              for (j = 0; j < train.carMarkers.length; j++) {
                if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                  map.removeLayer(train.carMarkers[j]);
                }
              }
            }
            // 修正箇所: train.cars が不正な値の場合に 0 にフォールバック
            train.carMarkers = new Array(train.cars || 0);
          }

          for (j = 0; j < train.cars; j++) {
            // 各車両の中心が先頭からどれだけ離れているか
            var carCenterDistance =
              headDistanceInSegment - j * carLengthMeters - carLengthMeters / 2;

            var pointData;
            // 現在のセグメント内で車両の位置を計算
            if (
              carCenterDistance >= 0 &&
              carCenterDistance <= currentSegment.distance
            ) {
              pointData = getPointAtDistance(
                currentSegment.latlngs,
                carCenterDistance
              );
            } else {
              // セグメント外の車両は、先頭車両の方向へ延長線上に配置 (簡易的な処理)
              pointData = getPointAtDistance(
                currentSegment.latlngs,
                Math.max(
                  0,
                  Math.min(currentSegment.distance, carCenterDistance)
                )
              );
            }

            if (!pointData) continue;

            var carLatLng = pointData.latlng;
            var carHeading = pointData.heading;
            if (train.direction === -1) {
              carHeading = (carHeading + 180) % 360;
            }

            var carLengthPx = metersToPixels(
              CONFIG.trainCarDimensionsMeters.length,
              carLatLng
            );
            var carWidthPx = metersToPixels(
              CONFIG.trainCarDimensionsMeters.width,
              carLatLng
            );
            var maxDim = Math.max(carLengthPx, carWidthPx) + 4; // 少し余裕を持たせる
            var iconSize = [maxDim, maxDim];
            var rotation = carHeading - 90;

            // 先頭車両に進行方向矢印を追加
            var carBodyClass = j === 0 ? "train-car-body front-car" : "train-car-body";

            if (!train.carMarkers[j]) {
              // 初回作成
              var carIcon = L.divIcon({
                className: "train-car-container",
                html:
                  '<div class="' +
                  carBodyClass +
                  '" style="background-color:' +
                  train.color +
                  '; width:' +
                  carLengthPx +
                  "px; height:" +
                  carWidthPx +
                  'px;"></div>',
                iconSize: iconSize,
                iconAnchor: [maxDim / 2, maxDim / 2],
              });
              train.carMarkers[j] = L.rotatedMarker(carLatLng, {
                icon: carIcon,
                rotation: rotation,
              }).addTo(map);
            } else {
              // 更新
              train.carMarkers[j].setLatLng(carLatLng);
              train.carMarkers[j].setRotation(rotation);

              // アイコンサイズと車両サイズを動的に更新
              var iconElement = train.carMarkers[j].getElement();
              if (iconElement) {
                var bodyElement = iconElement.querySelector(".train-car-body");
                if (bodyElement) {
                  bodyElement.style.width = carLengthPx + "px";
                  bodyElement.style.height = carWidthPx + "px";
                  bodyElement.className = carBodyClass; // クラスも更新
                }
                // L.divIconのiconSizeは直接変更できないため、新しいアイコンをセットし直す
                // ただし、これはコストが高いので、アイコンサイズが大きく変動しない場合は省略可能
                // 今回は車両サイズが動的に変わるため、正確性を優先して再設定
                train.carMarkers[j].setIcon(
                  L.divIcon({
                    className: "train-car-container",
                    html:
                      '<div class="' +
                      carBodyClass +
                      '" style="background-color:' +
                      train.color +
                      '; width:' +
                      carLengthPx +
                      "px; height:" +
                      carWidthPx +
                      'px;"></div>',
                    iconSize: iconSize,
                    iconAnchor: [maxDim / 2, maxDim / 2],
                  })
                );
              }
            }

            // 先頭車両にのみポップアップを設定/更新
            if (j === 0) {
              var popupContent =
                "<b>" +
                train.name +
                "</b><br>" +
                "路線: " +
                line.name +
                "<br>" +
                "速度: " +
                train.speed +
                "km/h<br>" +
                "乗客: " +
                train.currentPassengers.length +
                "/" +
                train.maxCapacity +
                "人";
              if (!train.carMarkers[j].getPopup()) {
                train.carMarkers[j].bindPopup(popupContent);
              } else {
                train.carMarkers[j].getPopup().setContent(popupContent);
              }
            }
          }
        }
      }

      // --- SAVE / LOAD GAME (共有機能対応のため、関数を分割・共通化) ---

      function serializeLatLng(latlng) {
        return latlng ? { lat: latlng.lat, lng: latlng.lng } : null;
      }
      function deserializeLatLng(obj) {
        return obj ? L.latLng(obj.lat, obj.lng) : null;
      }
      function serializeLatLngs(latlngs) {
        return (latlngs || []).map(serializeLatLng);
      }
      function deserializeLatLngs(arr) {
        return (arr || []).map(deserializeLatLng);
      }

      /**
       * 現在のゲーム状態から保存可能なオブジェクトを生成する。
       * Leafletレイヤーオブジェクトなどは除外し、再構築に必要なデータのみを抽出。
       * @returns {object} 保存可能なゲーム状態オブジェクト。
       */
      function getSavableState() {
        return {
          assets: state.assets,
          tracks: state.tracks.map(function (t) {
            return {
              id: t.id,
              latlngs: serializeLatLngs(t.latlngs),
              type: t.type,
            };
          }),
          stations: state.stations.map(function (s) {
            return {
              id: s.id,
              name: s.name,
              latlng: serializeLatLng(s.latlng),
              latlngs: serializeLatLngs(s.latlngs),
              platformLength: s.platformLength,
              revenueMultiplier: s.revenueMultiplier,
              passengersWaiting: s.passengersWaiting,
              maxWaitingPassengers: s.maxWaitingPassengers,
            };
          }),
          lines: state.lines.map(function (l) {
            return {
              id: l.id,
              name: l.name,
              stationIds: l.stationIds,
              color: l.color,
              totalDistance: l.totalDistance,
              assignedTrainIds: l.assignedTrainIds,
              segments: l.segments.map(function (seg) {
                return {
                  startStationId: seg.startStationId,
                  endStationId: seg.endStationId,
                  latlngs: serializeLatLngs(seg.latlngs),
                  distance: seg.distance,
                };
              }),
              totalTrainsOnLine: l.totalTrainsOnLine,
              totalCarsOnLine: l.totalCarsOnLine,
            };
          }),
          trains: state.trains.map(function (t) {
            return {
              id: t.id,
              type: t.type,
              name: t.name,
              cars: t.cars,
              cost: t.cost,
              color: t.color,
              speed: t.speed,
              totalLength: t.totalLength,
              currentStationId: t.currentStationId,
              currentLineId: t.currentLineId,
              currentSegmentIndex: t.currentSegmentIndex,
              direction: t.direction,
              progress: t.progress,
              isStopped: t.isStopped,
              currentPassengers: t.currentPassengers,
              maxCapacity: t.maxCapacity,
            };
          }),
          currentLineColorIndex: state.currentLineColorIndex,
          gameSpeedMultiplier: state.gameSpeedMultiplier,
          gameTime: state.gameTime, // ゲーム時間を保存
        };
      }

      /** マップ上の全てのLeafletレイヤーをクリアする */
      function clearMapLayers() {
        map.eachLayer(function (layer) {
          // ベースのタイルレイヤーと人口密度レイヤーは残す
          if (
            layer instanceof L.TileLayer ||
            (populationDensityLayer && layer === populationDensityLayer)
          ) {
            // Keep the base tile layer and population density layer
          } else {
            map.removeLayer(layer);
          }
        });
        // train.carMarkersも明示的にクリア
        for (var i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];
          if (train.carMarkers) {
            for (var j = 0; j < train.carMarkers.length; j++) {
              if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                map.removeLayer(train.carMarkers[j]);
              }
            }
          }
          train.carMarkers = []; // クリア
        }
      }

      // --- 暗号化/復号化のヘルパー関数 ---
      // 注意: このXOR暗号化は非常に簡易的なものであり、セキュリティレベルは高くありません。
      // 鍵がコード内にハードコードされているため、本格的なセキュリティが必要な場合は、
      // より強力な暗号化ライブラリの導入と、鍵管理の仕組みが必要です。
      var encryptionKey = "RailBuilderSecretKey2023"; // 適当な鍵

      function xorEncryptDecrypt(data, key) {
        var output = "";
        for (var i = 0; i < data.length; i++) {
          var charCode = data.charCodeAt(i) ^ key.charCodeAt(i % key.length);
          output += String.fromCharCode(charCode);
        }
        return output;
      }

      /**
       * ロードされたデータオブジェクトからゲーム状態を復元する。
       * @param {object} loadedState - ロードするゲーム状態オブジェクト。
       * @returns {boolean} ロードが成功したかどうか。
       */
      function loadGameFromObject(loadedState) {
        if (!loadedState) {
          ui.showMessage("無効なゲームデータです。", "error", false, 3000);
          return false;
        }

        clearMapLayers();

        // Reset state
        state = {
          assets: loadedState.assets,
          tracks: [],
          stations: [],
          lines: [],
          trains: [],
          planning: { type: null, points: [], ghost: null, costTooltip: null },
          lineBuildingMode: false,
          selectedStationsForLine: [],
          currentLineGhost: null,
          selectedTrainToBuyId: null,
          currentLineColorIndex: loadedState.currentLineColorIndex || 0,
          selectedTrainToAssignId: null,
          demolitionMode: false,
          selectedForDemolition: null,
          gameSpeedMultiplier: loadedState.gameSpeedMultiplier || 1,
          trainUpdateIntervalId: null,
          passengerGenerationIntervalId: null,
          gameTime: loadedState.gameTime || 0, // ゲーム時間をロード
          gameTimeIntervalId: null,
        };

        var i;

        // Rebuild tracks
        for (i = 0; i < loadedState.tracks.length; i++) {
          var tData = loadedState.tracks[i];
          var latlngs = deserializeLatLngs(tData.latlngs);

          var railLayer = L.polyline(latlngs, {
            className: "track-rail track-" + tData.type + "-rail",
            id: tData.id,
          }).addTo(map);
          var sleeperLayer = L.polyline(latlngs, {
            className: "track-sleeper track-" + tData.type + "-sleeper",
            id: tData.id,
          }).addTo(map);

          state.tracks.push({
            id: tData.id,
            latlngs: latlngs,
            railLayer: railLayer,
            sleeperLayer: sleeperLayer,
            type: tData.type,
          });

          railLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", this.options.id);
            }
          });
          sleeperLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", e.target.options.id);
            }
          });
        }

        // Rebuild stations
        for (i = 0; i < loadedState.stations.length; i++) {
          var sData = loadedState.stations[i];
          var latlng = deserializeLatLng(sData.latlng);
          var latlngs = deserializeLatLngs(sData.latlngs);

          var platformBodyLayer = L.polyline(latlngs, {
            className: "station-platform-body",
            id: sData.id,
          }).addTo(map);
          var platformEdgeLayer = L.polyline(latlngs, {
            className: "station-platform-edge",
            id: sData.id,
          }).addTo(map);

          var marker = L.marker(latlng, {
            icon: L.divIcon({
              className: "station-marker",
              iconSize: [16, 16],
              html: "",
            }),
            id: sData.id,
          }).addTo(map);
          var newStation = {
            id: sData.id,
            name: sData.name,
            latlng: latlng,
            latlngs: latlngs,
            platformLength: sData.platformLength,
            bodyLayer: platformBodyLayer,
            edgeLayer: platformEdgeLayer,
            marker: marker,
            revenueMultiplier: sData.revenueMultiplier || 1.0,
            passengersWaiting: sData.passengersWaiting || [],
            maxWaitingPassengers:
              sData.maxWaitingPassengers ||
              Math.floor(
                sData.platformLength *
                  CONFIG.maxWaitingPassengersPerMeterOfPlatform
              ),
          };
          state.stations.push(newStation);

          // 駅名ツールチップをバインド
          marker.bindTooltip(newStation.name, {
            permanent: true,
            direction: "top",
            className: "station-name-tooltip",
          });
          marker.getTooltip()._container.style.display =
            map.getZoom() >= 13 ? "block" : "none";

          marker.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var id = e.target.options.id;
            if (state.lineBuildingMode) {
              handleStationClickForLineBuilding(id);
            } else if (state.demolitionMode) {
              selectForDemolition("station", id);
            } else {
              // 修正4: 通常クリック時にポップアップを開く
              e.target.openPopup();
            }
          });
          platformBodyLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var id = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", id);
            }
          });
          platformEdgeLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var id = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", id);
            }
          });
          setStationRevenueMultiplier(newStation); // ロード時にも人口密度を適用
        }

        // Rebuild lines
        for (i = 0; i < loadedState.lines.length; i++) {
          var lData = loadedState.lines[i];
          var linePathLatLngs = [];
          if (lData.segments && lData.segments.length > 0) {
            linePathLatLngs = deserializeLatLngs(lData.segments[0].latlngs);
            for (var j = 1; j < lData.segments.length; j++) {
              var segLatLngs = deserializeLatLngs(lData.segments[j].latlngs);
              Array.prototype.push.apply(
                linePathLatLngs,
                segLatLngs.slice(1)
              );
            }
          }
          var lineLayer = L.polyline(linePathLatLngs, {
            className: "line-color",
            color: lData.color,
            weight: 5,
            opacity: 0.8,
            id: lData.id,
          }).addTo(map);
          state.lines.push({
            id: lData.id,
            name: lData.name,
            stationIds: lData.stationIds,
            color: lData.color,
            layer: lineLayer,
            totalDistance: lData.totalDistance,
            assignedTrainIds: lData.assignedTrainIds,
            segments: lData.segments.map(function (seg) {
              return {
                startStationId: seg.startStationId,
                endStationId: seg.endStationId,
                latlngs: deserializeLatLngs(seg.latlngs),
                distance: seg.distance,
              };
            }),
            totalTrainsOnLine: lData.totalTrainsOnLine || 0,
            totalCarsOnLine: lData.totalCarsOnLine || 0,
          });
        }

        // Rebuild trains
        for (i = 0; i < loadedState.trains.length; i++) {
          var trainData = loadedState.trains[i];
          var newTrain = Object.assign({}, trainData);
          newTrain.stopTimer = null;
          newTrain.carMarkers = []; // ロード時には空にして、renderTrainsで再作成させる
          newTrain.currentLatLng = null; // will be calculated on next update
          newTrain.currentHeading = 0;
          state.trains.push(newTrain);
        }

        ui.updateFinance();
        ui.updateGameTimeDisplay(); // ゲーム時間も更新
        ui.renderTrainShop();
        renderTrains();
        setGameSpeed(state.gameSpeedMultiplier); // ロード後にゲーム速度を再設定
        return true;
      }

      /** ゲームの状態をローカルストレージに保存する。 */
      function saveGame() {
        var savableState = getSavableState();
        try {
          var jsonString = JSON.stringify(savableState);
          var encrypted = xorEncryptDecrypt(jsonString, encryptionKey); // 暗号化
          var compressedAndEncrypted = LZString.compressToBase64(encrypted); // 圧縮

          localStorage.setItem("railBuilderSaveGame", compressedAndEncrypted);
          ui.showMessage("ゲームをセーブしました！ (ローカル)", "success", false, 2000);
        } catch (e) {
          console.error("ゲームのセーブに失敗しました:", e);
          ui.showMessage("ゲームのセーブに失敗しました。", "error", false, 3000);
        }
      }

      /** ローカルストレージからゲームの状態をロードする。 */
      function loadGame() {
        ui.showLoadingOverlay("ゲームデータをロード中...");
        var savedData = localStorage.getItem("railBuilderSaveGame");
        if (!savedData) {
          ui.showMessage("保存されたゲームデータがありません。", "warning", false, 3000);
          ui.hideLoadingOverlay();
          return;
        }
        try {
          var decompressed = LZString.decompressFromBase64(savedData); // 解凍
          if (!decompressed) {
            throw new Error("LZ-String decompression failed.");
          }
          var decrypted = xorEncryptDecrypt(decompressed, encryptionKey); // 復号化
          var loadedState = JSON.parse(decrypted);

          if (loadGameFromObject(loadedState)) {
            ui.showMessage("ゲームをロードしました！ (ローカル)", "success", false, 2000);
          }
        } catch (e) {
          console.error("ゲームのロードに失敗しました:", e);
          ui.showMessage(
            "ゲームのロードに失敗しました。データが破損している可能性があります。",
            "error",
            false,
            5000
          );
        } finally {
          ui.hideLoadingOverlay();
        }
      }

      /** 現在のゲーム状態をJSONテキストとしてテキストエリアに出力する。 */
      function exportSaveData() {
        try {
          var savableState = getSavableState();
          var jsonString = JSON.stringify(savableState);
          var encrypted = xorEncryptDecrypt(jsonString, encryptionKey); // 暗号化
          var compressedAndEncrypted = LZString.compressToBase64(encrypted); // 圧縮

          ui.saveDataTextarea.value = compressedAndEncrypted;
          ui.showMessage(
            "セーブデータを出力しました。テキストエリアからコピーしてください。",
            "info",
            false,
            3000
          );
        } catch (e) {
          console.error("セーブデータのエクスポートに失敗しました:", e);
          ui.showMessage("セーブデータのエクスポートに失敗しました。", "error", false, 3000);
        }
      }

      /** テキストエリアのJSONテキストからゲーム状態をインポートする。 */
      function importSaveData() {
        ui.showLoadingOverlay("セーブデータをインポート中...");
        var compressedAndEncrypted = ui.saveDataTextarea.value;
        if (!compressedAndEncrypted) {
          ui.showMessage(
            "テキストエリアにセーブデータを貼り付けてください。",
            "warning",
            false,
            3000
          );
          ui.hideLoadingOverlay();
          return;
        }
        try {
          var decompressed = LZString.decompressFromBase64(
            compressedAndEncrypted
          ); // 解凍
          if (!decompressed) {
            throw new Error("LZ-String decompression failed.");
          }
          var decrypted = xorEncryptDecrypt(decompressed, encryptionKey); // 復号化
          var loadedState = JSON.parse(decrypted);

          if (loadGameFromObject(loadedState)) {
            ui.showMessage(
              "セーブデータを入力し、ゲームをロードしました！",
              "success",
              false,
              2000
            );
            ui.saveDataTextarea.value = ""; // ロード後クリア
          }
        } catch (e) {
          console.error("セーブデータのインポートに失敗しました:", e);
          ui.showMessage(
            "無効なセーブデータです。形式を確認してください。",
            "error",
            false,
            5000
          );
        } finally {
          ui.hideLoadingOverlay();
        }
      }

      // ===================================================================
      // 人口密度TIFF関連の機能追加
      // ===================================================================

      // グローバル変数としてGeoTIFFオブジェクトとラスタデータを保持
      var populationDensityData = null; // 1次元配列で人口密度を保持
      var populationDensityGeoTransform = null; // [minX, minY, maxX, maxY]
      var populationDensityWidth = 0;
      var populationDensityHeight = 0;
      var populationDensityLayer = null; // Leafletの人口密度レイヤー

      var POPULATION_DENSITY_TIFF_PATH = "./zinkou.tif";

      // GeoTIFFを読み込み、ラスタデータをキャッシュ
      async function loadPopulationDensityTiff() {
        ui.showLoadingOverlay("人口密度データを読み込み中...");
        try {
          const tiff = await GeoTIFF.fromUrl(POPULATION_DENSITY_TIFF_PATH);
          const image = await tiff.getImage();

          let bbox = image.getBoundingBox();
          if (!Array.isArray(bbox)) {
            bbox = [bbox.left, bbox.bottom, bbox.right, bbox.top];
          }
          populationDensityGeoTransform = bbox;
          populationDensityWidth = image.getWidth();
          populationDensityHeight = image.getHeight();

          // 全ピクセルを読み込んで1次元配列に保持 (RangeError対策)
          const raster = await image.readRasters();
          populationDensityData = raster[0]; // raster[0] はすでに型付き配列

          console.log("TIFF Width:", populationDensityWidth);
          console.log("TIFF Height:", populationDensityHeight);
          console.log(
            "Raster data length:",
            populationDensityData ? populationDensityData.length : "null"
          ); // ここで長さを確認

          ui.showMessage(
            "人口密度データの読み込みが完了しました。",
            "success",
            false,
            3000
          );
          console.log(
            "Population Density TIFF loaded:",
            populationDensityGeoTransform,
            "Width:",
            populationDensityWidth,
            "Height:",
            populationDensityHeight
          );

          // 駅の収益倍率を更新
          for (let i = 0; i < state.stations.length; i++) {
            setStationRevenueMultiplier(state.stations[i]);
          }

          // 人口密度レイヤーを初期表示
          // addPopulationDensityLayer();
        } catch (error) {
          console.error("人口密度TIFFの読み込みに失敗しました:", error);
          ui.showMessage(
            "人口密度データの読み込みに失敗しました。ファイルパスを確認してください。",
            "error",
            false,
            7000
          );
        } finally {
          ui.hideLoadingOverlay();
        }
      }

      // 緯度経度 → ラスタ座標
      function latLngToPixel(latlng) {
        const [minX, minY, maxX, maxY] = populationDensityGeoTransform;
        // 経度方向の範囲が0の場合の対策
        const lngRange = maxX - minX;
        const latRange = maxY - minY;

        let x = 0;
        if (lngRange !== 0) {
          x = ((latlng.lng - minX) / lngRange) * populationDensityWidth;
        }
        let y = 0;
        if (latRange !== 0) {
          y = ((maxY - latlng.lat) / latRange) * populationDensityHeight;
        }

        return [Math.floor(x), Math.floor(y)];
      }

      // 人口密度を取得（キャッシュ配列から同期で取得）
      function getPopulationDensity(latlng) {
        if (
          !populationDensityData ||
          populationDensityWidth === 0 ||
          populationDensityHeight === 0 ||
          !populationDensityGeoTransform
        )
          return 0;

        // 緯度経度がGeoTIFFの範囲外の場合のチェック
        const [minX, minY, maxX, maxY] = populationDensityGeoTransform;
        if (
          latlng.lng < minX ||
          latlng.lng > maxX ||
          latlng.lat < minY ||
          latlng.lat > maxY
        ) {
          return 0; // 範囲外
        }

        const [x, y] = latLngToPixel(latlng);

        // 範囲チェックを強化
        if (
          x < 0 ||
          x >= populationDensityWidth ||
          y < 0 ||
          y >= populationDensityHeight
        ) {
          // console.warn("Pixel coordinates out of bounds:", x, y, "for LatLng:", latlng.lat, latlng.lng);
          return 0;
        }

        // 計算されるインデックスが配列の範囲内にあるか最終チェック
        const index = y * populationDensityWidth + x;
        if (index < 0 || index >= populationDensityData.length) {
          // console.error("Calculated index out of bounds:", index, "Array length:", populationDensityData.length, "for LatLng:", latlng.lat, latlng.lng);
          return 0;
        }

        return populationDensityData[index];
      }

      // 駅の収益倍率を設定
      function setStationRevenueMultiplier(station) {
        const density = getPopulationDensity(station.latlng);
        let multiplier = 1.0;

        if (density > 10000) multiplier = 2.5;
        else if (density > 5000) multiplier = 2.0;
        else if (density > 1000) multiplier = 1.5;
        else if (density > 500) multiplier = 1.0;
        else multiplier = 0.5;

        station.revenueMultiplier = multiplier;

        if (station.marker && station.marker.getPopup()) {
          station.marker
            .getPopup()
            .setContent(
              `<b>${station.name}</b><br>ID: ${station.id}<br>` +
                `プラットフォーム長: ${station.platformLength.toFixed(
                  1
                )}m<br>` +
                `人口密度: ${Math.round(density).toLocaleString()}人/km²<br>` +
                `収益倍率: ${station.revenueMultiplier.toFixed(2)}<br>` +
                `待機乗客: ${station.passengersWaiting.length}人<br>` +
                `最大待機乗客: ${station.maxWaitingPassengers}人`
            );
        }
      }

      // 人口密度カラー取得
      function getDensityColor(density) {
        if (density <= 0) return "rgba(0,0,0,0)";
        let r, g, b, a;
        if (density < 50) {
          const ratio = density / 50;
          r = 100 * ratio;
          g = 150 * ratio;
          b = 255;
          a = 0.1 + 0.3 * ratio;
        } else if (density < 500) {
          const ratio = (density - 50) / 450;
          r = 100 + 155 * ratio;
          g = 150 * (1 - ratio);
          b = 255 * (1 - ratio);
          a = 0.4 + 0.2 * ratio;
        } else if (density < 2000) {
          const ratio = (density - 500) / 1500;
          r = 255;
          g = Math.floor(100 * (1 - ratio)); // 修正: gを減らす
          b = Math.floor(100 * (1 - ratio)); // 修正: bを減らす
          a = 0.6 + 0.2 * ratio;
        } else {
          const ratio = Math.min(1, (density - 2000) / 8000);
          r = 255;
          g = Math.floor(100 * (1 - ratio));
          b = 100 + 155 * ratio;
          a = 0.8 + 0.1 * ratio;
        }
        return `rgba(${Math.floor(r)},${Math.floor(b)},${Math.floor(g)},${a})`; /* RGB順序を調整 */
      }

      // Leaflet人口密度レイヤー
      L.GridLayer.PopulationDensity = L.GridLayer.extend({
        options: { tileSize: 256, opacity: 0.6, samplingResolution: 24 },
        createTile: function (coords) {
          const tile = L.DomUtil.create("canvas", "leaflet-tile");
          tile.width = tile.height = this.options.tileSize;
          const ctx = tile.getContext("2d");
          if (!populationDensityData) return tile;

          const step = this.options.tileSize / this.options.samplingResolution; // より細かいグリッドで描画
          for (let x = 0; x < this.options.tileSize; x += step) {
            for (let y = 0; y < this.options.tileSize; y += step) {
              const mapPixelX = coords.x * this.options.tileSize + x;
              const mapPixelY = coords.y * this.options.tileSize + y;
              const latlng = map.unproject([mapPixelX, mapPixelY], coords.z);
              const density = getPopulationDensity(latlng);
              if (density > 0) {
                ctx.fillStyle = getDensityColor(density);
                ctx.fillRect(x, y, step, step);
              }
            }
          }
          return tile;
        },
      });

      L.gridLayer.populationDensity = function (options) {
        return new L.GridLayer.PopulationDensity(options);
      };

      function addPopulationDensityLayer() {
        if (populationDensityLayer) map.removeLayer(populationDensityLayer);
        populationDensityLayer = L.gridLayer
          .populationDensity({ opacity: 0.6 })
          .addTo(map);
        populationDensityLayer.setZIndex(1);
      }

      // ===================================================================
      // チュートリアル機能
      // ===================================================================
      var tutorialSteps = [
        {
          title: "Rail Builder Proへようこそ！",
          icon: "fas fa-train",
          text: "このゲームでは、線路や駅を建設し、列車を運行して都市を発展させます。まずは基本的な操作を学びましょう。",
        },
        {
          title: "1. 線路の建設",
          icon: "fas fa-road",
          text: "左側の「建設メニュー」から「地上線」「高架線」「トンネル」を選び、マップ上でドラッグして線路を建設します。建設コストに注意しましょう。",
        },
        {
          title: "2. 駅の建設",
          icon: "fas fa-train-station",
          text: "「建設メニュー」から「駅」を選び、マップ上でドラッグして駅のプラットフォームを建設します。駅は乗客の乗り降りや収益の拠点となります。",
        },
        {
          title: "3. 列車ショップ",
          icon: "fas fa-cart-shopping",
          text: "「列車ショップ」では、様々な種類の列車を購入できます。資金と相談して、最適な列車を選びましょう。",
        },
        {
          title: "4. 路線設定",
          icon: "fas fa-route",
          text: "「路線設定」モードで駅を順番にクリックし、路線を作成します。作成した路線に列車を割り当てることで運行が開始されます。",
        },
        {
          title: "5. 解体モード",
          icon: "fas fa-hammer",
          text: "「解体モード」では、建設済みの線路や駅を撤去できます。不要な施設を整理し、都市計画を見直しましょう。",
        },
        {
          title: "6. 資金と時間",
          icon: "fas fa-dollar-sign",
          text: "右上の「資産」と「時間」はゲームの進行状況を示します。乗客を運び、収益を上げて資産を増やしましょう。ゲーム速度も調整できます。",
        },
        {
          title: "7. 人口密度と収益",
          icon: "fas fa-users",
          text: "駅周辺の人口密度が高いほど、より多くの乗客が生成され、収益も増加します。人口密度の高い地域に駅を建設するのがおすすめです。",
        },
        {
          title: "ゲーム開始！",
          icon: "fas fa-play",
          text: "これで基本的な操作はマスターしました。さあ、あなただけの鉄道王国を築き上げましょう！",
        },
      ];
      var currentTutorialStep = 0;

      function showTutorial() {
        document.getElementById("tutorial-overlay").classList.add("show");
        showTutorialStep(0);
        // チュートリアル中はマップ操作を無効化
        map.dragging.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
        if (map.touchZoom) map.touchZoom.disable();
        if (map.zoomControl) map.zoomControl.disable();
      }

      function hideTutorial() {
        document.getElementById("tutorial-overlay").classList.remove("show");
        localStorage.setItem("hasSeenTutorial", "true");
        // チュートリアル終了後、マップ操作を有効化
        map.dragging.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
        if (map.tap) map.tap.enable();
        if (map.touchZoom) map.touchZoom.enable();
        if (map.zoomControl) map.zoomControl.enable();
      }

      function showTutorialStep(stepIndex) {
        if (stepIndex < 0 || stepIndex >= tutorialSteps.length) return;

        currentTutorialStep = stepIndex;
        var step = tutorialSteps[currentTutorialStep];

        document.getElementById("tutorial-title").textContent = step.title;
        document.getElementById("tutorial-icon").className =
          step.icon + " tutorial-icon";
        document.getElementById("tutorial-text").textContent = step.text;

        document.getElementById("tutorial-prev-btn").disabled =
          currentTutorialStep === 0;
        document.getElementById("tutorial-next-btn").textContent =
          currentTutorialStep === tutorialSteps.length - 1
            ? "完了"
            : "次へ";
        document.getElementById("tutorial-next-btn").querySelector("i").className =
          currentTutorialStep === tutorialSteps.length - 1
            ? "fas fa-check"
            : "fas fa-chevron-right";
      }

      function initTutorial() {
        document
          .getElementById("tutorial-next-btn")
          .addEventListener("click", function () {
            if (currentTutorialStep === tutorialSteps.length - 1) {
              hideTutorial();
            } else {
              showTutorialStep(currentTutorialStep + 1);
            }
          });

        document
          .getElementById("tutorial-prev-btn")
          .addEventListener("click", function () {
            showTutorialStep(currentTutorialStep - 1);
          });

        document
          .getElementById("tutorial-skip-btn")
          .addEventListener("click", hideTutorial);

        if (!localStorage.getItem("hasSeenTutorial")) {
          showTutorial();
        }
      }

      // --- INITIAL LOAD ---
      document.addEventListener("DOMContentLoaded", function () {
        loadPopulationDensityTiff().then(function () {
          setGameSpeed(1); // 初期速度は1倍
          initTutorial(); // チュートリアルを初期化
        });
      });
    </script>
  </body>
</html>