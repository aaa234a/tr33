<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Rail Builder Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
    />
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <!-- GeoTIFF.js を追加 -->
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    <!-- LZ-String を追加: セーブデータを圧縮・解凍するために使用 -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>

    <style>
      /* 基本的なスタイル */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f8f9fa; /* 全体の背景色 */
        color: #333;
        overflow: hidden; /* チュートリアル表示時にスクロールバーが出ないように */
      }
      #map {
        height: 100%;
        width: 100%;
        cursor: default;
      }
      /* 建設モード中のカーソル */
      #map.build-mode-cursor {
        cursor: crosshair;
      }

      /* カスタムスクロールバー (Webkit系ブラウザ) */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      /* トップレベルのパネル (left-panel, finance-panel) */
      .panel {
        position: absolute;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95); /* 背景を少し不透明に */
        padding: 15px; /* パディングを増やす */
        border-radius: 10px; /* 角を丸く */
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2); /* 影を強調 */
        border: 1px solid #e0e0e0; /* 軽いボーダー */
        transition: all 0.3s ease-out; /* 開閉アニメーション用 */
      }
      #left-panel {
        top: 15px;
        left: 15px;
        width: 280px; /* 幅を少し広げる */
        max-height: calc(100% - 30px); /* 画面の高さに合わせて最大高さを設定 */
        overflow-y: auto; /* 内容が多い場合にスクロール可能に */
        display: flex;
        flex-direction: column;
        gap: 15px; /* 子パネル間のスペースを増やす */
      }
      #left-panel.collapsed {
        width: 60px; /* 最小幅をボタンより大きく変更 */
        height: 60px; /* max-heightではなくheightで固定に変更 */
        overflow: hidden;
        padding: 0;
      }
      #left-panel.collapsed > *:not(.panel-toggle-btn) {
        display: none; /* 開閉ボタン以外を非表示 */
      }

      .panel-toggle-btn {
        position: absolute;
        top: 0px;
        right: 0px;
        width: 40px;
        height: 40px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 0 10px 0 10px;
        cursor: pointer;
        font-size: 1.2em;
        line-height: 40px;
        text-align: center;
        transition: background 0.2s;
        z-index: 1001; /* パネルコンテンツより手前 */
      }
      .panel-toggle-btn:hover {
        background: #0056b3;
      }
      #left-panel.collapsed .panel-toggle-btn {
        border-radius: 10px; /* 全体が丸くなるように */
        top: 10px; /* 閉じた状態でのボタンの位置調整 */
        right: 10px; /* 閉じた状態でのボタンの位置調整 */
      }

      #finance-panel {
        top: 15px;
        right: 15px;
        width: 220px; /* 幅を少し広げる */
        text-align: right; /* テキストを右寄せ */
        font-size: 1.1em;
        font-weight: bold;
        color: #007bff; /* 強調色 */
      }
      #finance-panel span {
        color: #28a745; /* 資産の色 */
      }
      #message-bar {
        position: absolute;
        bottom: 25px; /* 下からの位置を少し上げる */
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.85); /* 背景をより濃く */
        color: white;
        padding: 10px 20px; /* パディングを増やす */
        border-radius: 25px; /* 角をさらに丸く */
        font-size: 1.1em;
        opacity: 0;
        transition: opacity 0.4s ease-in-out, background-color 0.3s, color 0.3s; /* トランジションを長く */
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
      #message-bar.success {
        background-color: rgba(40, 167, 69, 0.9);
      }
      #message-bar.warning {
        background-color: rgba(255, 193, 7, 0.9);
        color: #333;
      }
      #message-bar.error {
        background-color: rgba(220, 53, 69, 0.9);
      }

      /* left-panel の子要素のパネル (build-menu, finance-panel) */
      /* これらはFlexアイテムとしてレイアウトされるため、positionはstatic */
      #left-panel > .panel {
        background: #fdfdfd; /* 子パネルの背景色 */
        padding: 15px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* 軽い影 */
        position: static; /* 絶対配置を解除 */
        width: auto; /* 幅を親に合わせる */
        margin-bottom: 0; /* gapでスペースを確保するため不要 */
        border: 1px solid #f0f0f0;
      }
      #left-panel > .panel h3 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #007bff;
        font-size: 1.2em;
        border-bottom: 2px solid #eee;
        padding-bottom: 8px;
        border-left: 5px solid #007bff; /* パネルヘッダーの強調 */
        padding-left: 10px;
      }
      #left-panel > .panel h4 {
        margin-top: 15px;
        margin-bottom: 10px;
        color: #555;
        font-size: 1em;
      }

      /* マップ上の表示物 */
      /* 線路のレール */
      .track-rail {
        color: #a0a0a0; /* レール色: やや明るいグレー */
        weight: 2;
        opacity: 0.9;
        lineCap: butt; /* 端を四角に */
        z-index: 10; /* 枕木より上 */
      }
      /* 線路の枕木 */
      .track-sleeper {
        color: #6a5c50; /* 枕木色: やや濃い茶色 */
        weight: 8; /* 枕木は太く */
        opacity: 0.9;
        dashArray: "1 10"; /* 短い線と長い間隔で枕木を表現 */
        lineCap: butt;
        z-index: 5; /* レールより下 */
      }

      /* 地上線路 */
      .track-ground-rail {
        color: #a0a0a0;
      }
      .track-ground-sleeper {
        color: #6a5c50;
      }

      /* 高架線路の見た目 */
      .track-viaduct-rail {
        color: #c0c0c0; /* 高架線は明るいグレー */
      }
      .track-viaduct-sleeper {
        color: #807060; /* 高架線の枕木は少し明るい茶色 */
      }
      /* トンネル線路の見た目 */
      .track-tunnel-rail {
        color: #606060; /* トンネル線は暗いグレー */
      }
      .track-tunnel-sleeper {
        color: #403020; /* トンネルの枕木は暗い茶色 */
      }

      /* 駅ホーム本体 */
      .station-platform-body {
        color: #b0b0b0; /* コンクリート色 */
        weight: 15; /* ホーム本体は太く */
        opacity: 0.9;
        lineCap: butt;
        z-index: 15; /* レールより上 */
      }
      /* 駅ホームの縁 */
      .station-platform-edge {
        color: #ffffff; /* 白線 */
        weight: 4; /* 細い縁 */
        opacity: 1;
        lineCap: butt;
        z-index: 20; /* ホーム本体より上 */
      }

      .station-marker {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #d9534f;
        border: 2px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        transition: transform 0.1s ease-out; /* ホバー時のアニメーション */
        display: flex; /* 中央に数字を配置 */
        justify-content: center;
        align-items: center;
        font-size: 0.8em;
        font-weight: bold;
        color: white;
      }
      .station-marker:hover {
        transform: scale(1.2); /* ホバーで少し拡大 */
      }
      .station-marker.selected-for-line {
        background: #007bff; /* 路線設定で選択された駅の色 */
        border-color: #007bff;
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.7);
      }
      /* 路線設定で選択された駅マーカーのスタイルをさらに調整（駅クリック時に適用される）*/
      .station-marker-selectable {
        cursor: pointer;
      }

      /* 駅名ツールチップ */
      .station-name-tooltip {
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 4px 8px;
        font-size: 0.9em;
        white-space: nowrap;
        pointer-events: none; /* クリックイベントを通過させる */
      }
      .station-name-tooltip::before {
        border-top-color: rgba(0, 0, 0, 0.7) !important;
      }

      /* 解体モードで選択されたオブジェクトのスタイル */
      .selected-for-demolition {
        animation: pulse 1s infinite alternate; /* 点滅アニメーション */
      }
      @keyframes pulse {
        from {
          outline: 3px solid rgba(220, 53, 69, 0.5);
          box-shadow: 0 0 10px rgba(220, 53, 69, 0.3);
        }
        to {
          outline: 3px solid rgba(220, 53, 69, 1);
          box-shadow: 0 0 15px rgba(220, 53, 69, 0.8);
        }
      }

      .station-marker.selected-for-demolition {
        background: #dc3545; /* マーカーも赤く */
        border-color: #dc3545;
      }

      .line-color {
        weight: 5;
        dasharray: "";
        opacity: 0.8;
      }

      /* ボタンのスタイル */
      button {
        margin: 4px 0; /* マージンを調整 */
        padding: 10px 15px; /* パディングを増やす */
        border-radius: 5px; /* 角を丸く */
        cursor: pointer;
        border: 1px solid #007bff; /* メインカラーのボーダー */
        background: #007bff; /* メインカラーの背景 */
        color: white; /* 文字色を白に */
        font-weight: bold;
        transition: background 0.2s, color 0.2s, border-color 0.2s,
          box-shadow 0.2s, transform 0.2s;
        width: 100%;
        box-sizing: border-box;
        box-shadow: 0 2px 4px rgba(0, 123, 255, 0.2);
        display: flex; /* アイコンとテキストを中央揃え */
        align-items: center;
        justify-content: center;
      }
      button i {
        margin-right: 8px; /* アイコンとテキストの間隔 */
      }
      button:hover {
        background: #0056b3; /* ホバーで少し暗く */
        border-color: #0056b3;
        box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
        transform: translateY(-2px); /* 浮き上がるエフェクト */
      }
      button.active {
        background: #28a745; /* アクティブなボタンは緑色に */
        border-color: #28a745;
        box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        transform: translateY(0); /* 浮き上がりをリセット */
      }
      button.active:hover {
        background: #218838;
        border-color: #218838;
      }
      button:disabled {
        background: #e9ecef;
        color: #6c757d;
        cursor: not-allowed;
        border-color: #dee2e6;
        box-shadow: none;
        transform: translateY(0);
      }
      /* 特定のボタンのスタイル調整 */
      #confirm-build,
      #confirm-line-build,
      #confirm-demolition {
        background: #ffc107; /* 確定ボタンは警告色 */
        border-color: #ffc107;
        color: #333;
      }
      #confirm-build:hover,
      #confirm-line-build:hover,
      #confirm-demolition:hover {
        background: #e0a800;
        border-color: #e0a800;
      }
      #cancel-line-build,
      #cancel-demolition {
        background: #dc3545; /* キャンセルボタンは危険色 */
        border-color: #dc3545;
      }
      #cancel-line-build:hover,
      #cancel-demolition:hover {
        background: #c82333;
      }
      #demolition-mode-btn {
        background: #6c757d; /* 解体モードは灰色 */
        border-color: #6c757d;
      }
      #demolition-mode-btn:hover {
        background: #5a6268;
        border-color: #5a6268;
      }
      #demolition-mode-btn.active {
        background: #dc3545; /* アクティブな解体モードは赤 */
        border-color: #dc3545;
      }
      #demolition-mode-btn.active:hover {
        background: #c82333;
        border-color: #c82333;
      }

      /* ゲーム速度ボタンの調整 */
      #game-speed-control button {
        width: calc(33.33% - 5px); /* 3つ並べる */
        display: inline-flex; /* flexに変更 */
        margin-right: 5px;
      }
      #game-speed-control button:nth-child(3n) {
        margin-right: 0;
      }

      hr {
        border: none;
        border-top: 1px solid #eee;
        margin: 15px 0;
      }

      /* 列車ショップ */
      #train-list,
      #bought-trains-list {
        max-height: 250px; /* 高さを調整 */
        overflow-y: auto;
        border: 1px solid #ddd; /* ボーダーを調整 */
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 10px;
        background: #fff;
      }
      .train-item {
        display: flex;
        align-items: center;
        padding: 10px;
        margin-bottom: 6px;
        border: 1px solid #eee;
        border-radius: 5px;
        cursor: pointer;
        background: #f9f9f9;
        transition: background 0.2s, border-color 0.2s, box-shadow 0.2s;
      }
      .train-item:hover {
        background: #f0f0f0;
        border-color: #ccc;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }
      .train-item.selected {
        border-color: #007bff;
        background: #e7f3ff;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
      }
      .train-item i {
        font-size: 1.5em;
        margin-right: 12px;
        color: #666;
      }
      .train-item-color-box {
        width: 24px; /* サイズを少し大きく */
        height: 24px;
        border-radius: 4px;
        margin-right: 12px;
        border: 1px solid #ccc;
        flex-shrink: 0; /* 縮まないように */
      }
      .train-item-details {
        flex-grow: 1;
      }
      .train-item-details h4 {
        margin: 0;
        font-size: 1.1em;
        color: #333;
      }
      .train-item-details p {
        margin: 0;
        font-size: 0.85em;
        color: #666;
      }

      /* 路線設定 */
      #selected-stations-list {
        max-height: 180px; /* 高さを調整 */
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 10px;
        background: #fff;
      }
      .selected-station-item {
        padding: 8px;
        margin-bottom: 5px;
        background: #f0f8ff; /* 選択された駅の背景色 */
        border: 1px solid #b0e0e6;
        border-radius: 4px;
        font-size: 0.95em;
        color: #444;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .selected-station-item span {
        font-weight: bold;
        margin-right: 8px;
        color: #007bff;
      }
      .selected-station-item button {
        width: auto;
        padding: 4px 10px;
        font-size: 0.8em;
        margin: 0;
        background: #dc3545;
        color: white;
        border: none;
        box-shadow: none;
      }
      .selected-station-item button:hover {
        background: #c82333;
      }

      /* 列車車両 */
      .train-car-container {
        /* L.divIconのルート要素。iconSizeで指定されるサイズ */
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: none; /* マップ操作の邪魔にならないように */
      }
      .train-car-body {
        /* 実際の車両の長方形 */
        border-radius: 2px;
        box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(0, 0, 0, 0.2); /* 車両の境界線 */
        position: relative;
      }
      .train-car-body.front-car::after {
        content: "";
        position: absolute;
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 12px solid white; /* 矢印の色 */
        top: -12px; /* 車両の少し上に配置 */
        left: 50%;
        transform: translateX(-50%);
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.3);
      }

      /* 建設コスト表示ツールチップ */
      .construction-cost-tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 0.9em;
        white-space: nowrap;
        pointer-events: none;
        z-index: 1000;
        transform: translate(-50%, -120%); /* マウスカーソルから少しずらす */
      }

      /* ロード中のスピナー */
      #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        color: white;
        font-size: 1.5em;
        flex-direction: column;
        gap: 20px;
        transition: opacity 0.3s ease-in-out;
      }
      .spinner {
        border: 8px solid #f3f3f3; /* Light grey */
        border-top: 8px solid #3498db; /* Blue */
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 2s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* チュートリアルモーダル */
      #tutorial-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      }
      #tutorial-overlay.show {
        opacity: 1;
        visibility: visible;
      }
      #tutorial-modal {
        background: #fff;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        max-width: 600px;
        width: 90%;
        text-align: center;
        transform: translateY(-20px);
        transition: transform 0.3s ease-in-out;
      }
      #tutorial-overlay.show #tutorial-modal {
        transform: translateY(0);
      }
      #tutorial-modal h2 {
        color: #007bff;
        font-size: 2em;
        margin-bottom: 20px;
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }
      #tutorial-modal p {
        font-size: 1.1em;
        line-height: 1.6;
        color: #555;
        margin-bottom: 20px;
      }
      .tutorial-icon {
        font-size: 3em;
        color: #007bff;
        margin-bottom: 15px;
      }
      .tutorial-navigation-buttons button {
        width: auto;
        padding: 10px 20px;
        margin: 0 10px;
        font-size: 1em;
      }
      #tutorial-skip-btn {
        background-color: #6c757d;
        border-color: #6c757d;
      }
      #tutorial-skip-btn:hover {
        background-color: #5a6268;
        border-color: #5a6268;
      }

      /* ミッションリストのスタイル */
      #mission-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 10px;
        background: #fff;
      }
      .mission-item {
        padding: 10px;
        margin-bottom: 8px;
        border: 1px solid #e0e0e0;
        border-radius: 5px;
        background: #f9f9f9;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .mission-item.completed {
        background-color: #d4edda;
        border-color: #28a745;
        color: #155724;
      }
      .mission-item.locked {
        background-color: #f8d7da;
        border-color: #dc3545;
        color: #721c24;
        opacity: 0.7;
      }
      .mission-item h4 {
        margin: 0;
        font-size: 1.1em;
        color: #007bff;
      }
      .mission-item.completed h4 {
        color: #28a745;
      }
      .mission-item.locked h4 {
        color: #dc3545;
      }
      .mission-item p {
        margin: 0;
        font-size: 0.9em;
        color: #555;
      }
      .mission-progress-bar {
        width: 100%;
        height: 8px;
        background-color: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
      }
      .mission-progress {
        height: 100%;
        background-color: #007bff;
        width: 0%;
        transition: width 0.3s ease-in-out;
      }
      .mission-item.completed .mission-progress {
        background-color: #28a745;
      }
      .mission-reward {
        font-weight: bold;
        color: #28a745;
        font-size: 0.95em;
      }

      /* モバイル対応 */
      @media (max-width: 768px) {
        /* ブレークポイントを調整 */
        #left-panel {
          width: calc(100% - 30px); /* 左右15pxマージン */
          left: 15px;
          right: 15px;
          top: 15px;
          max-height: calc(70% - 30px); /* 画面の70%に制限 */
          flex-direction: column;
        }
        #finance-panel {
          width: calc(100% - 30px);
          right: 15px;
          top: auto; /* 上からの位置指定を解除 */
          bottom: 15px; /* 下に配置 */
          text-align: center; /* 中央寄せ */
          padding: 10px;
          font-size: 1em;
        }
        #message-bar {
          bottom: 10px; /* さらに下げる */
          font-size: 0.9em;
          padding: 8px 15px;
        }
        .panel {
          padding: 10px;
        }
        #left-panel > .panel {
          padding: 10px;
        }
        button {
          padding: 8px 12px;
          font-size: 0.9em;
        }
        select {
          padding: 8px;
          font-size: 0.9em;
        }
        .train-item {
          padding: 8px;
        }
        .train-item-details h4 {
          font-size: 1em;
        }
        .train-item-details p {
          font-size: 0.8em;
        }
        .selected-station-item {
          padding: 6px;
          font-size: 0.85em;
        }
        .selected-station-item button {
          padding: 3px 8px;
          font-size: 0.75em;
        }
        #game-speed-control button {
          width: calc(33.33% - 4px);
          margin-right: 4px;
        }
        #tutorial-modal {
          padding: 20px;
        }
        #tutorial-modal h2 {
          font-size: 1.5em;
        }
        #tutorial-modal p {
          font-size: 1em;
        }
        .tutorial-navigation-buttons button {
          padding: 8px 15px;
          margin: 0 5px;
          font-size: 0.9em;
        }
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div id="left-panel" class="panel">
      <button id="toggle-left-panel" class="panel-toggle-btn">
        <i class="fas fa-chevron-left"></i>
      </button>

      <div id="build-menu" class="panel">
        <h3>建設メニュー</h3>
        <button id="build-ground">
          <i class="fas fa-road"></i> 地上線 ($<span id="cost-ground"></span>/m)
        </button>
        <button id="build-viaduct">
          <i class="fas fa-bridge"></i> 高架線 ($<span id="cost-viaduct"></span
          >/m)
        </button>
        <button id="build-tunnel">
          <i class="fas fa-tunnel"></i> トンネル ($<span id="cost-tunnel"></span
          >/m)
        </button>
        <!-- 駅のコスト表示を基本料金と1mあたりの料金に変更 -->
        <button id="build-station">
          <i class="fas fa-train-station"></i> 駅 (基本 $250,000 + $5,000/m)
        </button>
        <hr />
        <button id="confirm-build" disabled>建設確定</button>
      </div>

      <div id="train-shop" class="panel">
        <h3>列車ショップ</h3>
        <h4>購入可能な列車</h4>
        <div id="train-list">
          <!-- 列車アイテムがここに追加される -->
        </div>
        <button id="buy-train-btn" disabled>
          <i class="fas fa-cart-shopping"></i> 選択した列車を購入
        </button>
        <hr />
        <h4>購入済み列車</h4>
        <div id="bought-trains-list">
          <!-- 購入済み列車アイテムがここに追加される -->
        </div>
        <select
          id="line-select-for-assignment"
          style="
            width: 100%;
            margin-top: 5px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
          "
        ></select>
        <button id="assign-train-to-line-btn" disabled>
          <i class="fas fa-share-nodes"></i> 選択した列車を路線に割り当てる
        </button>
      </div>

      <div id="line-builder" class="panel">
        <h3>路線設定</h3>
        <button id="start-line-build">
          <i class="fas fa-route"></i> 路線設定開始
        </button>
        <div id="selected-stations-list">
          <!-- 選択された駅がここに追加される -->
        </div>
        <!-- 路線確定ボタンのコスト表示を基本料金と1mあたりの料金に変更 -->
        <button id="confirm-line-build" disabled>
          <i class="fas fa-check"></i> 路線確定 (基本 $50,000 + $2,500/m)
        </button>
        <button id="cancel-line-build">
          <i class="fas fa-xmark"></i> キャンセル
        </button>
      </div>

      <!-- 解体メニューを追加 -->
      <div id="demolition-menu" class="panel">
        <h3>解体メニュー</h3>
        <button id="demolition-mode-btn">
          <i class="fas fa-hammer"></i> 解体モード
        </button>
        <div
          id="demolition-info"
          style="margin-top: 10px; font-size: 0.9em; color: #555"
        >
          <p>マップ上の線路や駅をクリックして選択してください。</p>
          <p id="selected-demolition-target"></p>
        </div>
        <button id="confirm-demolition" disabled>
          <i class="fas fa-trash-can"></i> 解体確定
        </button>
        <button id="cancel-demolition">
          <i class="fas fa-ban"></i> 解体キャンセル
        </button>
      </div>

      <!-- 新規追加: ミッションパネル -->
      <div id="missions-panel" class="panel">
        <h3>ミッション</h3>
        <div id="mission-list">
          <!-- ミッションアイテムがここに追加される -->
          <p style="text-align: center; color: #999; font-size: 0.9em">
            ミッションはありません
          </p>
        </div>
      </div>

      <!-- 新規追加: 人口密度表示ボタン -->
      <div id="map-overlays" class="panel">
        <h3>マップ表示</h3>
        <button id="toggle-population-density-layer-btn">
          <i class="fas fa-layer-group"></i> 人口密度表示
        </button>
      </div>

      <!-- セーブ/ロードメニューを追加 -->
      <div id="save-load-menu" class="panel">
        <h3>セーブ/ロード</h3>
        <button id="save-game-btn">
          <i class="fas fa-save"></i> ゲームをセーブ (ローカル)
        </button>
        <button id="load-game-btn">
          <i class="fas fa-folder-open"></i> ゲームをロード (ローカル)
        </button>
        <hr />
        <button id="export-save-btn">
          <i class="fas fa-file-export"></i> セーブデータを出力
        </button>
        <textarea
          id="save-data-textarea"
          rows="5"
          placeholder="セーブデータJSONをここに入力/表示"
        ></textarea>
        <button id="import-save-btn">
          <i class="fas fa-file-import"></i> セーブデータを入力
        </button>
      </div>

      <!-- ゲーム速度コントロールを追加 -->
      <div id="game-speed-control" class="panel">
        <h3>ゲーム速度</h3>
        <button data-speed="1" class="speed-btn active">1x</button>
        <button data-speed="2" class="speed-btn">2x</button>
        <button data-speed="4" class="speed-btn">4x</button>
        <button data-speed="8" class="speed-btn">8x</button>
        <button data-speed="16" class="speed-btn">16x</button>
        <button data-speed="32" class="speed-btn">32x</button>
      </div>
    </div>

    <div id="finance-panel" class="panel">
      <p>資産: <span id="assets-display">$0</span></p>
      <p>時間: <span id="game-time-display">0日 00:00</span></p>
      <p>維持費: <span id="maintenance-cost-display">$0/日</span></p>
    </div>

    <div id="message-bar"></div>

    <!-- ロード中のスピナーオーバーレイ -->
    <div id="loading-overlay" style="display: none">
      <div class="spinner"></div>
      <p id="loading-message">データを読み込み中...</p>
    </div>

    <!-- チュートリアルモーダル -->
    <div id="tutorial-overlay">
      <div id="tutorial-modal">
        <h2 id="tutorial-title"></h2>
        <i id="tutorial-icon" class="tutorial-icon"></i>
        <p id="tutorial-text"></p>
        <div class="tutorial-navigation-buttons">
          <button id="tutorial-prev-btn" disabled>
            <i class="fas fa-chevron-left"></i> 前へ
          </button>
          <button id="tutorial-next-btn">
            <i class="fas fa-chevron-right"></i> 次へ
          </button>
          <button id="tutorial-skip-btn">
            <i class="fas fa-forward"></i> スキップ
          </button>
        </div>
      </div>
    </div>

    <script>
      // ===================================================================
      // ES5互換性対応: ポリフィル相当の定義 (変更なし)
      // ===================================================================

      if (!Array.prototype.find) {
        Array.prototype.find = function (predicate) {
          var list = Object(this);
          var length = list.length >>> 0;
          if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
          }
          for (var i = 0; i < length; i++) {
            var value = list[i];
            if (predicate.call(arguments, value, i, list)) {
              return value;
            }
          }
          return undefined;
        };
      }
      if (!Array.prototype.includes) {
        Array.prototype.includes = function (searchElement /*, fromIndex */) {
          var O = Object(this);
          var len = O.length >>> 0;
          if (len === 0) {
            return false;
          }
          var n =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : 0;
          var k;
          if (n >= 0) {
            k = n;
          } else {
            k = len - Math.abs(n);
          }
          while (k < len) {
            var element = O[k];
            if (
              element === searchElement ||
              (element !== element && searchElement !== searchElement)
            ) {
              return true;
            }
            k++;
          }
          return false;
        };
      }
      if (!Array.prototype.findIndex) {
        Array.prototype.findIndex = function (predicate) {
          var list = Object(this);
          var length = list.length >>> 0;
          if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
          }
          for (var i = 0; i < length; i++) {
            var value = list[i];
            if (predicate.call(arguments, value, i, list)) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!L.Polyline.prototype.getLatLngs) {
        // For older Leaflet versions if needed
        L.Polyline.prototype.getLatLngs = function () {
          return this._latlngs;
        };
      }
      if (!L.Polyline.prototype.setLatLngs) {
        // For older Leaflet versions if needed
        L.Polyline.prototype.setLatLngs = function (latlngs) {
          this._latlngs = this._convertLatLngs(latlngs);
          return this.redraw();
        };
      }
      if (!("equals" in L.LatLng.prototype)) {
        L.LatLng.prototype.equals = function (otherLatLng, margin) {
          if (!otherLatLng) {
            return false;
          }
          otherLatLng = L.latLng(otherLatLng);
          var margin = Math.max(
            Math.abs(this.lat - otherLatLng.lat),
            Math.abs(this.lng - otherLatLng.lng)
          );
          return margin <= (margin === undefined ? 1.0e-9 : margin);
        };
      }

      // ===================================================================
      // Custom RotatedMarker: 列車車両の回転を可能にするLeafletマーカー
      // ===================================================================
      L.RotatedMarker = L.Marker.extend({
        options: {
          rotation: 0,
        },

        onAdd: function (map) {
          L.Marker.prototype.onAdd.call(this, map);
          this.updateRotation();
        },

        updateRotation: function () {
          if (this._icon) {
            this._icon.style[L.DomUtil.TRANSFORM + "Origin"] = "center center";
            var currentTransform = this._icon.style[L.DomUtil.TRANSFORM];
            var newTransform =
              currentTransform.replace(/rotate\([^)]*\)/g, "").trim() +
              " rotate(" +
              this.options.rotation +
              "deg)";
            this._icon.style[L.DomUtil.TRANSFORM] = newTransform;
          }
        },

        setRotation: function (rotation) {
          this.options.rotation = rotation;
          this.updateRotation();
          return this;
        },

        _setPos: function (pos) {
          L.Marker.prototype._setPos.call(this, pos);
          this.updateRotation();
        },
      });

      L.rotatedMarker = function (latlng, options) {
        return new L.RotatedMarker(latlng, options);
      };

      // ===================================================================
      // CONFIG: ゲームの設定値 (const -> var)
      // ===================================================================
      var CONFIG = {
        initialAssets: 50000000, // 初期資産を増額
        costs: {
          // 各種建設コストを増額
          ground: { perMeter: 50 }, // 1mあたり50ドル
          viaduct: { perMeter: 150 }, // 1mあたり150ドル
          tunnel: { perMeter: 300 }, // 1mあたり300ドル
          station: {
            // 駅のコストは基本料金とプラットフォーム長に応じた費用
            base: 250000, // 基本料金を増額
            perMeter: 5000, // 1メートルあたりの費用を増額
          },
          line: {
            // 路線のコストは基本料金と総距離に応じた費用
            base: 50000, // 基本料金を増額
            perMeter: 2500, // 1メートルあたりの費用を増額
          },
        },
        maintenanceCosts: {
          // 新規追加: 維持費
          perTrackMeterPerDay: 5, // 線路1mあたり1日5ドル
          perStationPerDay: 5000, // 駅1つあたり1日5000ドル
          perTrainPerDay: 25000, // 列車1編成あたり1日25000ドル
        },
        passengerCapacityPerCar: 50, // 1車両あたりの乗客容量
        basePassengerGeneration: 1000, // ★修正1: 駅で生成される乗客の基本量を15から1000に増やしました
        passengerRevenuePerPerson: 100, // 1人あたりの乗客収益（降車時）
        passengerGenerationInterval: 100, // 乗客を生成する間隔 (ms)
        passengerMaxDestinationAttempts: 5, // 乗客の目的地を決定する際の試行回数
        maxWaitingPassengersPerMeterOfPlatform: 2, // プラットフォーム1mあたりの最大待機乗客数
        optimalCarsPerLineSegment: 5, // ★修正3: 1路線セグメントあたりの最適な車両数を10から5に減らしました

        // 列車種類を実在のものに修正
        trains: [
          {
            id: "e233",
            name: "E233系通勤電車",
            cars: 10,
            cost: 1000000,
            color: "#007bff",
            defaultSpeed: 100,
          },
          {
            id: "e259",
            name: "E259系成田エクスプレス",
            cars: 6,
            cost: 1500000,
            color: "#d9534f",
            defaultSpeed: 130,
          },
          {
            id: "n700s",
            name: "N700S系新幹線",
            cars: 16,
            cost: 5000000,
            color: "#5cb85c",
            defaultSpeed: 285,
          },
          {
            id: "485",
            name: "485系特急電車",
            cars: 8,
            cost: 2000000,
            color: "#f0ad4e",
            defaultSpeed: 120,
          },
          {
            id: "kiha40",
            name: "キハ40系気動車",
            cars: 4,
            cost: 800000,
            color: "#6f42c1",
            defaultSpeed: 95,
          },
          {
            id: "e6",
            name: "E6系スーパーこまち",
            cars: 7,
            cost: 3000000,
            color: "#d63384",
            defaultSpeed: 320,
          },
          {
            id: "h5",
            name: "H5系北海道新幹線",
            cars: 10,
            cost: 4000000,
            color: "#20c997",
            defaultSpeed: 260,
          },
          {
            id: "shinkansen-e7",
            name: "E7系北陸新幹線",
            cars: 12,
            cost: 4500000,
            color: "#6610f2",
            defaultSpeed: 275,
          },
          {
            id: "shinkansen-e3",
            name: "E3系つばさ",
            cars: 7,
            cost: 2800000,
            color: "#fd7e14",
            defaultSpeed: 275,
          },
          {
            id: "sunrise",
            name: "寝台特急サンライズ瀬戸・出雲",
            cars: 14,
            cost: 3500000,
            color: "#20c997",
            defaultSpeed: 110,
          },
          {
            id: "torokko",
            name: "嵯峨野トロッコ列車",
            cars: 5,
            cost: 1200000,
            color: "#ffc107",
            defaultSpeed: 50,
          },
          {
            id: "local",
            name: "地方普通列車",
            cars: 3,
            cost: 500000,
            color: "#6c757d",
            defaultSpeed: 80,
          },
        ],

        trainCarDimensionsMeters: {
          // 車両のサイズ (メートル)
          length: 20, // 車両の進行方向の長さ
          width: 3, // 車両の幅
        },
        lineColors: [
          "#FF0000",
          "#0000FF",
          "#00FF00",
          "#FFFF00",
          "#00FFFF",
          "#FF00FF",
          "#FF8C00",
          "#8A2BE2",
        ], // 路線に割り当てる色
        trainStopDuration: 5000, // 駅での停車時間 (ms) - 乗降時間を考慮して延長
        updateInterval: 50, // 列車の位置更新間隔 (ms)
        snapThresholdPixels: 15, // スナップ判定のピクセル距離
        snapThresholdMeters: 20, // 線路接続判定のメートル距離
        gameTimeInterval: 1000, // ゲーム内時間更新間隔 (ms)
        gameTimeScale: 60, // リアル1秒がゲーム内60秒に相当
        splineSegmentsPerTrackSegment: 10, // Catmull-Rom補間でのセグメントあたりの中間点数

        // 新規追加: ミッション定義 (50個に拡張)
        missions: [
          {
            id: "first_track",
            title: "最初の線路",
            description: "合計1000mの線路を建設する。",
            type: "build_track_length",
            target: 1000,
            reward: 1000000,
            unlockedBy: null,
          },
          {
            id: "first_station",
            title: "最初の駅",
            description: "駅を1つ建設する。",
            type: "build_station_count",
            target: 1,
            reward: 500000,
            unlockedBy: "first_track",
          },
          {
            id: "first_line",
            title: "最初の路線",
            description: "路線を1つ設定する。",
            type: "build_line_count",
            target: 1,
            reward: 750000,
            unlockedBy: "first_station",
          },
          {
            id: "first_train",
            title: "最初の列車",
            description: "列車を1編成購入する。",
            type: "buy_train_count",
            target: 1,
            reward: 1200000,
            unlockedBy: "first_line",
          },
          {
            id: "transport_100_passengers",
            title: "乗客輸送の開始",
            description: "合計100人の乗客を輸送する。",
            type: "transport_passengers",
            target: 100,
            reward: 1500000,
            unlockedBy: "first_train",
          },
          {
            id: "expand_network_1",
            title: "ネットワーク拡張",
            description: "合計5000mの線路を建設する。",
            type: "build_track_length",
            target: 5000,
            reward: 2000000,
            unlockedBy: "transport_100_passengers",
          },
          {
            id: "establish_3_stations",
            title: "拠点拡大",
            description: "駅を合計3つ建設する。",
            type: "build_station_count",
            target: 3,
            reward: 1000000,
            unlockedBy: "expand_network_1",
          },
          {
            id: "reach_10m_assets",
            title: "資産1000万ドル",
            description: "総資産を10,000,000ドルにする。",
            type: "reach_assets",
            target: 10000000,
            reward: 3000000,
            unlockedBy: "establish_3_stations",
          },
          {
            id: "transport_10000_passengers",
            title: "輸送量増加",
            description: "合計10000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 10000,
            reward: 2500000,
            unlockedBy: "reach_10m_assets",
          },
          {
            id: "expand_network_2",
            title: "大規模ネットワーク",
            description: "合計10000mの線路を建設する。",
            type: "build_track_length",
            target: 10000,
            reward: 3500000,
            unlockedBy: "transport_10000_passengers",
          },
          {
            id: "establish_5_stations",
            title: "主要都市接続",
            description: "駅を合計5つ建設する。",
            type: "build_station_count",
            target: 5,
            reward: 2000000,
            unlockedBy: "expand_network_2",
          },
          {
            id: "reach_25m_assets",
            title: "資産2500万ドル",
            description: "総資産を25,000,000ドルにする。",
            type: "reach_assets",
            target: 25000000,
            reward: 5000000,
            unlockedBy: "establish_5_stations",
          },
          // ここから追加ミッション (計50個)
          {
            id: "build_3_trains",
            title: "車両拡充",
            description: "列車を合計3編成購入する。",
            type: "buy_train_count",
            target: 3,
            reward: 2500000,
            unlockedBy: "reach_25m_assets",
          },
          {
            id: "transport_100k_passengers",
            title: "輸送力強化",
            description: "合計100000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 100000,
            reward: 3500000,
            unlockedBy: "build_3_trains",
          },
          {
            id: "expand_network_3",
            title: "広域ネットワーク",
            description: "合計25,000mの線路を建設する。",
            type: "build_track_length",
            target: 25000,
            reward: 6000000,
            unlockedBy: "transport_100k_passengers",
          },
          {
            id: "establish_10_stations",
            title: "拠点網の拡大",
            description: "駅を合計10個建設する。",
            type: "build_station_count",
            target: 10,
            reward: 4000000,
            unlockedBy: "expand_network_3",
          },
          {
            id: "build_5_lines",
            title: "路線網の整備",
            description: "路線を合計5つ設定する。",
            type: "build_line_count",
            target: 5,
            reward: 4500000,
            unlockedBy: "establish_10_stations",
          },
          {
            id: "reach_50m_assets",
            title: "資産5000万ドル",
            description: "総資産を50,000,000ドルにする。",
            type: "reach_assets",
            target: 50000000,
            reward: 8000000,
            unlockedBy: "build_5_lines",
          },
          {
            id: "transport_250k_passengers",
            title: "中規模輸送",
            description: "合計250000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 250000,
            reward: 5000000,
            unlockedBy: "reach_50m_assets",
          },
          {
            id: "build_5_trains",
            title: "増備計画",
            description: "列車を合計5編成購入する。",
            type: "buy_train_count",
            target: 5,
            reward: 4000000,
            unlockedBy: "transport_250k_passengers",
          },
          {
            id: "expand_network_4",
            title: "都市間接続",
            description: "合計50,000mの線路を建設する。",
            type: "build_track_length",
            target: 50000,
            reward: 10000000,
            unlockedBy: "build_5_trains",
          },
          {
            id: "establish_15_stations",
            title: "主要駅の確立",
            description: "駅を合計15個建設する。",
            type: "build_station_count",
            target: 15,
            reward: 6000000,
            unlockedBy: "expand_network_4",
          },
          {
            id: "build_10_lines",
            title: "幹線網の構築",
            description: "路線を合計10個設定する。",
            type: "build_line_count",
            target: 10,
            reward: 7000000,
            unlockedBy: "establish_15_stations",
          },
          {
            id: "reach_100m_assets",
            title: "資産1億ドル",
            description: "総資産を100,000,000ドルにする。",
            type: "reach_assets",
            target: 100000000,
            reward: 15000000,
            unlockedBy: "build_10_lines",
          },
          {
            id: "transport_500k_passengers",
            title: "大規模輸送",
            description: "合計500000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 500000,
            reward: 8000000,
            unlockedBy: "reach_100m_assets",
          },
          {
            id: "build_10_trains",
            title: "車両の多様化",
            description: "列車を合計10編成購入する。",
            type: "buy_train_count",
            target: 10,
            reward: 7000000,
            unlockedBy: "transport_500k_passengers",
          },
          {
            id: "expand_network_5",
            title: "地域ネットワーク",
            description: "合計75,000mの線路を建設する。",
            type: "build_track_length",
            target: 75000,
            reward: 12000000,
            unlockedBy: "build_10_trains",
          },
          {
            id: "establish_20_stations",
            title: "主要ターミナル",
            description: "駅を合計20個建設する。",
            type: "build_station_count",
            target: 20,
            reward: 8000000,
            unlockedBy: "expand_network_5",
          },
          {
            id: "build_15_lines",
            title: "広域路線網",
            description: "路線を合計15個設定する。",
            type: "build_line_count",
            target: 15,
            reward: 9000000,
            unlockedBy: "establish_20_stations",
          },
          {
            id: "reach_250m_assets",
            title: "資産2億5000万ドル",
            description: "総資産を250,000,000ドルにする。",
            type: "reach_assets",
            target: 250000000,
            reward: 25000000,
            unlockedBy: "build_15_lines",
          },
          {
            id: "transport_1m_passengers",
            title: "都市圏輸送",
            description: "合計1000000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 1000000,
            reward: 12000000,
            unlockedBy: "reach_250m_assets",
          },
          {
            id: "build_15_trains",
            title: "車両基地の拡充",
            description: "列車を合計15編成購入する。",
            type: "buy_train_count",
            target: 15,
            reward: 10000000,
            unlockedBy: "transport_1m_passengers",
          },
          {
            id: "expand_network_6",
            title: "全国ネットワーク",
            description: "合計100,000mの線路を建設する。",
            type: "build_track_length",
            target: 100000,
            reward: 15000000,
            unlockedBy: "build_15_trains",
          },
          {
            id: "establish_25_stations",
            title: "広域拠点",
            description: "駅を合計25個建設する。",
            type: "build_station_count",
            target: 25,
            reward: 10000000,
            unlockedBy: "expand_network_6",
          },
          {
            id: "build_20_lines",
            title: "主要幹線網",
            description: "路線を合計20個設定する。",
            type: "build_line_count",
            target: 20,
            reward: 12000000,
            unlockedBy: "establish_25_stations",
          },
          {
            id: "reach_500m_assets",
            title: "資産5億ドル",
            description: "総資産を500,000,000ドルにする。",
            type: "reach_assets",
            target: 500000000,
            reward: 40000000,
            unlockedBy: "build_20_lines",
          },
          {
            id: "transport_2_5m_passengers",
            title: "大量輸送時代",
            description: "合計2500000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 25000,
            reward: 18000000,
            unlockedBy: "reach_500m_assets",
          },
          {
            id: "build_20_trains",
            title: "車両の充実",
            description: "列車を合計20編成購入する。",
            type: "buy_train_count",
            target: 20,
            reward: 15000000,
            unlockedBy: "transport_2_5m_passengers",
          },
          {
            id: "expand_network_7",
            title: "超広域ネットワーク",
            description: "合計150,000mの線路を建設する。",
            type: "build_track_length",
            target: 150000,
            reward: 20000000,
            unlockedBy: "build_20_trains",
          },
          {
            id: "establish_30_stations",
            title: "主要都市圏",
            description: "駅を合計30個建設する。",
            type: "build_station_count",
            target: 30,
            reward: 12000000,
            unlockedBy: "expand_network_7",
          },
          {
            id: "build_25_lines",
            title: "鉄道網の完成",
            description: "路線を合計25個設定する。",
            type: "build_line_count",
            target: 25,
            reward: 15000000,
            unlockedBy: "establish_30_stations",
          },
          {
            id: "reach_1b_assets",
            title: "資産10億ドル",
            description: "総資産を1,000,000,000ドルにする。",
            type: "reach_assets",
            target: 1000000000,
            reward: 75000000,
            unlockedBy: "build_25_lines",
          },
          {
            id: "transport_5m_passengers",
            title: "国民の足",
            description: "合計5000000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 50000,
            reward: 25000000,
            unlockedBy: "reach_1b_assets",
          },
          {
            id: "build_25_trains",
            title: "車両大隊",
            description: "列車を合計25編成購入する。",
            type: "buy_train_count",
            target: 25,
            reward: 20000000,
            unlockedBy: "transport_5m_passengers",
          },
          {
            id: "expand_network_8",
            title: "大陸横断鉄道",
            description: "合計200,000mの線路を建設する。",
            type: "build_track_length",
            target: 200000,
            reward: 25000000,
            unlockedBy: "build_25_trains",
          },
          {
            id: "establish_35_stations",
            title: "主要交通拠点",
            description: "駅を合計35個建設する。",
            type: "build_station_count",
            target: 35,
            reward: 15000000,
            unlockedBy: "expand_network_8",
          },
          {
            id: "build_30_lines",
            title: "国家鉄道網",
            description: "路線を合計30個設定する。",
            type: "build_line_count",
            target: 30,
            reward: 18000000,
            unlockedBy: "establish_35_stations",
          },
          {
            id: "reach_2_5b_assets",
            title: "資産25億ドル",
            description: "総資産を2,500,000,000ドルにする。",
            type: "reach_assets",
            target: 2500000000,
            reward: 150000000,
            unlockedBy: "build_30_lines",
          },
          {
            id: "transport_10m_passengers",
            title: "世界一の輸送量",
            description: "合計10000000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 100000,
            reward: 40000000,
            unlockedBy: "reach_2_5b_assets",
          },
          {
            id: "expand_network_9",
            title: "世界鉄道網",
            description: "合計250,000mの線路を建設する。",
            type: "build_track_length",
            target: 250000,
            reward: 30000000,
            unlockedBy: "transport_10m_passengers",
          },
          {
            id: "establish_40_stations",
            title: "グローバルハブ",
            description: "駅を合計40個建設する。",
            type: "build_station_count",
            target: 40,
            reward: 18000000,
            unlockedBy: "expand_network_9",
          },
          {
            id: "build_35_lines",
            title: "国際路線網",
            description: "路線を合計35個設定する。",
            type: "build_line_count",
            target: 35,
            reward: 20000000,
            unlockedBy: "establish_40_stations",
          },
          {
            id: "reach_5b_assets",
            title: "資産50億ドル",
            description: "総資産を5,000,000,000ドルにする。",
            type: "reach_assets",
            target: 5000000000,
            reward: 250000000,
            unlockedBy: "build_35_lines",
          },
          {
            id: "transport_25m_passengers",
            title: "輸送の神",
            description: "合計25000000人の乗客を輸送する。",
            type: "transport_passengers",
            target: 25000000,
            reward: 75000000,
            unlockedBy: "reach_5b_assets",
          },
          {
            id: "build_30_trains",
            title: "鉄道王",
            description: "列車を合計30編成購入する。",
            type: "buy_train_count",
            target: 30,
            reward: 25000000,
            unlockedBy: "transport_25m_passengers",
          },
          {
            id: "expand_network_10",
            title: "究極の鉄道網",
            description: "合計500,000mの線路を建設する。",
            type: "build_track_length",
            target: 500000,
            reward: 50000000,
            unlockedBy: "build_30_trains",
          },
          {
            id: "establish_50_stations",
            title: "鉄道帝国",
            description: "駅を合計50個建設する。",
            type: "build_station_count",
            target: 50,
            reward: 25000000,
            unlockedBy: "expand_network_10",
          },
          {
            id: "reach_10b_assets",
            title: "資産100億ドル",
            description: "総資産を10,000,000,000ドルにする。",
            type: "reach_assets",
            target: 10000000000,
            reward: 500000000,
            unlockedBy: "establish_50_stations",
          },
        ],
      };

      // --- GAME STATE: ゲームの現在の状態を保持するオブジェクト (let -> var) ---
      var state = {
        assets: CONFIG.initialAssets, // 現在の資産
        tracks: [], // 建設済みの線路オブジェクトの配列
        stations: [], // 建設済みの駅オブジェクトの配列
        lines: [], // 確定した路線オブジェクトの配列
        trains: [], // 購入済み列車オブジェクトの配列
        planning: {
          // 線路・駅建設モードの状態
          type: null, // 'ground', 'viaduct', 'tunnel'
          points: [], // 建設中の点の配列 (LatLng)
          ghost: null, // 建設中の仮ポリライン/マーカー (Leaflet Layer)
          costTooltip: null, // 建設コスト表示ツールチップ
        },
        lineBuildingMode: false, // 路線設定モードかどうか
        selectedStationsForLine: [], // 路線設定中に選択された駅のIDリスト
        currentLineGhost: null, // 路線設定中の仮ポリライン (Leaflet Layer)
        selectedTrainToBuyId: null, // ショップで選択中の列車ID
        currentLineColorIndex: 0, // 次の路線に割り当てる色のインデックス
        selectedTrainToAssignId: null, // 路線に割り当てるために選択中の列車ID
        demolitionMode: false, // 解体モードかどうか
        selectedForDemolition: null, // 解体モードで選択されたオブジェクト { type: 'track'|'station', id: string }
        gameSpeedMultiplier: 1, // 新規追加: ゲーム速度倍率
        passengerGenerationIntervalId: null, // 新規追加: 乗客生成setInterval ID
        gameTime: 0, // 新規追加: ゲーム内時間 (ミリ秒)
        gameTimeIntervalId: null,

        // 新規追加: ミッション関連の追跡変数
        missions: [], // アクティブなミッションのインスタンス
        totalTrackLengthBuilt: 0,
        totalStationsBuilt: 0,
        totalLinesBuilt: 0,
        totalTrainsBought: 0,
        totalPassengersTransported: 0,
        lastMaintenanceDay: 0, // 新規追加: 維持費徴収の最終日
      };

      // --- MAP: Leafletマップの初期化 ---
      var map = L.map("map", { preferCanvas: true }).setView(
        [36.2048, 138.2529],
        7
      ); // 日本の中心付近を初期表示、ズームレベル7
      L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r.png}",
        {
          attribution: "&copy; CARTO",
          maxZoom: 19,
        }
      ).addTo(map);

      // --- UI ELEMENTS: UI要素への参照とUI操作関数 ---
      var ui = {
        assetsDisplay: document.getElementById("assets-display"),
        gameTimeDisplay: document.getElementById("game-time-display"), // 新規追加
        maintenanceCostDisplay: document.getElementById(
          "maintenance-cost-display"
        ), // 新規追加
        messageBar: document.getElementById("message-bar"),
        buildButtons: document.querySelectorAll(
          "#build-menu button:not(#confirm-build)"
        ),
        confirmBuildButton: document.getElementById("confirm-build"),
        trainListDiv: document.getElementById("train-list"),
        buyTrainButton: document.getElementById("buy-train-btn"),
        startLineBuildButton: document.getElementById("start-line-build"),
        selectedStationsListDiv: document.getElementById(
          "selected-stations-list"
        ),
        confirmLineBuildButton: document.getElementById("confirm-line-build"),
        cancelLineBuildButton: document.getElementById("cancel-line-build"),
        boughtTrainsListDiv: document.getElementById("bought-trains-list"),
        assignTrainToLineButton: document.getElementById(
          "assign-train-to-line-btn"
        ),
        lineSelectForAssignment: document.getElementById(
          "line-select-for-assignment"
        ),
        demolitionModeButton: document.getElementById("demolition-mode-btn"),
        selectedDemolitionTargetDisplay: document.getElementById(
          "selected-demolition-target"
        ),
        confirmDemolitionButton: document.getElementById("confirm-demolition"),
        cancelDemolitionButton: document.getElementById("cancel-demolition"),
        saveGameButton: document.getElementById("save-game-btn"),
        loadGameButton: document.getElementById("load-game-btn"),
        costGround: document.getElementById("cost-ground"),
        costViaduct: document.getElementById("cost-viaduct"),
        costTunnel: document.getElementById("cost-tunnel"),
        // 新しいUI要素への参照
        exportSaveButton: document.getElementById("export-save-btn"),
        importSaveButton: document.getElementById("import-save-btn"),
        saveDataTextarea: document.getElementById("save-data-textarea"),
        loadingOverlay: document.getElementById("loading-overlay"), // 新規追加
        loadingMessage: document.getElementById("loading-message"), // 新規追加
        toggleLeftPanelButton: document.getElementById("toggle-left-panel"), // 新規追加
        missionListDiv: document.getElementById("mission-list"), // 新規追加
        togglePopulationDensityLayerBtn: document.getElementById(
          "toggle-population-density-layer-btn"
        ), // 新規追加

        /**
         * ユーザーにメッセージを表示する。
         * @param {string} msg - 表示するメッセージ。
         * @param {string} [type='info'] - メッセージのタイプ ('info', 'success', 'warning', 'error')。
         * @param {boolean} [persistent=false] - メッセージを永続的に表示するかどうか。
         * @param {number} [duration=3000] - メッセージを表示する時間 (ミリ秒)。
         */
        showMessage: function (msg, type, persistent, duration) {
          if (type === undefined) type = "info";
          if (persistent === undefined) persistent = false;
          if (duration === undefined) duration = 3000;

          this.messageBar.textContent = msg;
          this.messageBar.className = "message-bar " + type; // クラスを更新
          this.messageBar.style.opacity = 1;
          if (!persistent) {
            clearTimeout(this.messageBar.hideTimeout); // 既存のタイマーをクリア
            this.messageBar.hideTimeout = setTimeout(function () {
              ui.messageBar.style.opacity = 0;
            }, duration);
          }
        },

        /** 資産表示を更新する。 */
        updateFinance: function () {
          this.assetsDisplay.textContent =
            "$" + Math.floor(state.assets).toLocaleString();
          // ミッションの進行状況をチェック
          checkMissionProgress("reach_assets");
        },

        /** ゲーム時間表示を更新する。 */
        updateGameTimeDisplay: function () {
          var totalMinutes = Math.floor(state.gameTime / 60000); // ミリ秒から分へ
          var days = Math.floor(totalMinutes / (24 * 60));
          var hours = Math.floor((totalMinutes % (24 * 60)) / 60);
          var minutes = totalMinutes % 60;
          this.gameTimeDisplay.textContent =
            days +
            "日 " +
            String(hours).padStart(2, "0") +
            ":" +
            String(minutes).padStart(2, "0");
          this.maintenanceCostDisplay.textContent =
            "$" + Math.round(calculateDailyMaintenanceCost()).toLocaleString() + "/日";
        },

        /** 列車ショップのUIを更新する。 */
        renderTrainShop: function () {
          var self = this;

          // 購入可能な列車リストの更新
          this.trainListDiv.innerHTML = "";
          var i, trainConfig;
          for (i = 0; i < CONFIG.trains.length; i++) {
            trainConfig = CONFIG.trains[i];
            var trainItem = document.createElement("div");
            trainItem.className = self.trainItemClass(trainConfig.id, "buy");
            trainItem.dataset.trainId = trainConfig.id;
            trainItem.innerHTML =
              '<i class="fas fa-train"></i>' + // 列車アイコンを追加
              '<div class="train-item-details">' +
              "<h4>" +
              trainConfig.name +
              "</h4>" +
              "<p>" +
              trainConfig.cars +
              "両 - $" +
              trainConfig.cost.toLocaleString() +
              "</p>" +
              "</div>";

            trainItem.onclick = function () {
              selectTrainToBuy(this.dataset.trainId);
            };
            this.trainListDiv.appendChild(trainItem);
          }

          var selectedTrainCost = state.selectedTrainToBuyId
            ? CONFIG.trains.find(function (t) {
                return t.id === state.selectedTrainToBuyId;
              }).cost
            : null;

          this.buyTrainButton.disabled =
            !state.selectedTrainToBuyId || state.assets < selectedTrainCost;
          this.buyTrainButton.textContent = state.selectedTrainToBuyId
            ? "選択した列車を購入 ($" +
              (selectedTrainCost ? selectedTrainCost.toLocaleString() : "0") +
              ")"
            : "選択した列車を購入";

          // 購入済み列車リストの更新
          this.boughtTrainsListDiv.innerHTML = "";
          if (state.trains.length === 0) {
            this.boughtTrainsListDiv.innerHTML =
              '<p style="text-align:center; color:#999; font-size:0.9em;">購入済みの列車はありません。</p>';
          }

          for (i = 0; i < state.trains.length; i++) {
            var train = state.trains[i];
            var trainItem = document.createElement("div");
            trainItem.className = self.trainItemClass(train.id, "assign");
            trainItem.dataset.trainId = train.id;
            var assignedLine = train.currentLineId
              ? getLineById(train.currentLineId)
              : null;
            trainItem.innerHTML =
              '<i class="fas fa-train"></i>' + // 列車アイコンを追加
              '<div class="train-item-details">' +
              "<h4>" +
              train.name +
              "</h4>" +
              "<p>" +
              (assignedLine ? "路線: " + assignedLine.name : "未割り当て") +
              "</p>" +
              // 乗客数と最大容量を追加
              "<p>乗客: " +
              train.currentPassengers.length +
              "/" +
              train.maxCapacity +
              "人</p>" +
              "</div>";

            trainItem.onclick = function () {
              selectTrainToAssign(this.dataset.trainId);
            };
            this.boughtTrainsListDiv.appendChild(trainItem);
          }

          // 割り当て用路線選択ドロップダウンの更新
          this.lineSelectForAssignment.innerHTML =
            '<option value="">路線を選択...</option>';
          var line;
          for (i = 0; i < state.lines.length; i++) {
            line = state.lines[i];
            var option = document.createElement("option");
            option.value = line.id;
            option.textContent = line.name;
            this.lineSelectForAssignment.appendChild(option);
          }

          // 現在選択されている路線があればそれを選択状態にする
          if (state.selectedTrainToAssignId) {
            var selectedTrain = state.trains.find(function (t) {
              return t.id === state.selectedTrainToAssignId;
            });
            if (selectedTrain && selectedTrain.currentLineId) {
              this.lineSelectForAssignment.value = selectedTrain.currentLineId;
            } else {
              this.lineSelectForAssignment.value = "";
            }
          } else {
            this.lineSelectForAssignment.value = "";
          }

          this.assignTrainToLineButton.disabled =
            !state.selectedTrainToAssignId ||
            !this.lineSelectForAssignment.value;
        },

        trainItemClass: function (id, type) {
          var baseClass = "train-item";
          if (type === "buy" && state.selectedTrainToBuyId === id)
            baseClass += " selected";
          if (type === "assign" && state.selectedTrainToAssignId === id)
            baseClass += " selected";
          return baseClass;
        },

        /** 路線設定モードで選択された駅リストを更新する。 */
        updateSelectedStationsForLine: function () {
          var self = this;
          this.selectedStationsListDiv.innerHTML = "";
          if (state.selectedStationsForLine.length === 0) {
            this.selectedStationsListDiv.innerHTML =
              '<p style="text-align:center; color:#999; font-size:0.9em;">駅を選択してください</p>';
          }

          for (var i = 0; i < state.selectedStationsForLine.length; i++) {
            var stationId = state.selectedStationsForLine[i];
            var station = getStationById(stationId);
            if (station) {
              var item = document.createElement("div");
              item.className = "selected-station-item";
              item.innerHTML =
                "<span>" +
                (i + 1) +
                ".</span> " +
                station.name +
                ' <button data-station-id="' +
                stationId +
                '"><i class="fas fa-xmark"></i> 削除</button>';

              item.querySelector("button").onclick = function (e) {
                e.stopPropagation(); // 親要素のクリックイベントが発火しないように
                removeStationFromLineBuilding(this.dataset.stationId);
              };
              this.selectedStationsListDiv.appendChild(item);
            }
          }

          // 路線確定ボタンのテキストと有効/無効状態を動的に更新
          var potentialLineLength = 0;
          var pathFound = true;
          if (state.selectedStationsForLine.length >= 2) {
            for (var j = 0; j < state.selectedStationsForLine.length - 1; j++) {
              var startStation = getStationById(
                state.selectedStationsForLine[j]
              );
              var endStation = getStationById(
                state.selectedStationsForLine[j + 1]
              );
              if (startStation && endStation) {
                var segmentPath = findPathBetweenStations_GraphSearch(
                  startStation.latlng,
                  endStation.latlng
                );
                if (segmentPath) {
                  potentialLineLength += calculatePathDistance(segmentPath);
                } else {
                  pathFound = false;
                  break;
                }
              }
            }
          }
          var potentialLineCost =
            CONFIG.costs.line.base +
            CONFIG.costs.line.perMeter * potentialLineLength;

          this.confirmLineBuildButton.disabled =
            state.selectedStationsForLine.length < 2 ||
            state.assets < potentialLineCost ||
            !pathFound;
          this.confirmLineBuildButton.textContent =
            "路線確定 ($" + Math.round(potentialLineCost).toLocaleString() + ")";
        },

        /** 建設メニューのボタンのアクティブ状態を設定する。 */
        setBuildModeActive: function (type) {
          var i, btn;
          for (i = 0; i < this.buildButtons.length; i++) {
            btn = this.buildButtons[i];
            if (btn.id === "build-" + type) {
              btn.classList.add("active");
            } else {
              btn.classList.remove("active");
            }
          }
          // 建設確定ボタンは、点を配置するまで無効
          this.confirmBuildButton.disabled = true;
          this.confirmBuildButton.textContent = "建設確定";
        },

        /** 建設メニューのボタンのアクティブ状態をリセットする。 */
        resetBuildModeActive: function () {
          var i, btn;
          for (i = 0; i < this.buildButtons.length; i++) {
            btn = this.buildButtons[i];
            btn.classList.remove("active");
          }
          this.confirmBuildButton.disabled = true;
          this.confirmBuildButton.textContent = "建設確定";
        },

        /** 路線設定関連UIの表示/非表示を切り替える。 */
        setLineBuildModeActive: function (active) {
          if (active) {
            this.startLineBuildButton.classList.add("active");
            this.confirmLineBuildButton.style.display = "flex"; // flexに変更
            this.cancelLineBuildButton.style.display = "flex"; // flexに変更
            this.selectedStationsListDiv.style.display = "block";
          } else {
            this.startLineBuildButton.classList.remove("active");
            this.confirmLineBuildButton.style.display = "none";
            this.cancelLineBuildButton.style.display = "none";
            this.selectedStationsListDiv.style.display = "none";
          }
        },

        /** 解体モード関連UIの表示/非表示を切り替える。 */
        setDemolitionModeActive: function (active) {
          if (active) {
            this.demolitionModeButton.classList.add("active");
            this.confirmDemolitionButton.style.display = "flex"; // flexに変更
            this.cancelDemolitionButton.style.display = "flex"; // flexに変更
            this.selectedDemolitionTargetDisplay.style.display = "block";
          } else {
            this.demolitionModeButton.classList.remove("active");
            this.confirmDemolitionButton.style.display = "none";
            this.cancelDemolitionButton.style.display = "none";
            this.selectedDemolitionTargetDisplay.style.display = "none";
            this.selectedDemolitionTargetDisplay.textContent = ""; // 表示をクリア
          }
          this.confirmDemolitionButton.disabled = !state.selectedForDemolition;
        },

        /** ロードオーバーレイの表示/非表示 */
        showLoadingOverlay: function (message) {
          this.loadingMessage.textContent = message || "データを読み込み中...";
          this.loadingOverlay.style.display = "flex";
          // opacityをtransitionさせるために少し遅延させる
          setTimeout(function () {
            ui.loadingOverlay.style.opacity = 1;
          }, 10);
        },

        hideLoadingOverlay: function () {
          this.loadingOverlay.style.opacity = 0;
          setTimeout(function () {
            ui.loadingOverlay.style.display = "none";
          }, 300); // transitionの時間と合わせる
        },

        // 新規追加: ミッションリストのレンダリング
        renderMissions: function () {
          this.missionListDiv.innerHTML = "";
          if (state.missions.length === 0) {
            this.missionListDiv.innerHTML =
              '<p style="text-align: center; color: #999; font-size: 0.9em">ミッションはありません</p>';
            return;
          }

          // 未完了のミッションを優先的に表示
          var sortedMissions = [].concat(state.missions).sort(function (a, b) {
            if (a.isCompleted && !b.isCompleted) return 1;
            if (!a.isCompleted && b.isCompleted) return -1;
            return 0;
          });

          for (var i = 0; i < sortedMissions.length; i++) {
            var mission = sortedMissions[i];
            var missionItem = document.createElement("div");
            missionItem.className = "mission-item";
            if (mission.isCompleted) {
              missionItem.classList.add("completed");
            } else if (!mission.isActive) {
              missionItem.classList.add("locked");
            }

            var progress = Math.min(
              100,
              (mission.currentProgress / mission.target) * 100
            );
            if (isNaN(progress)) progress = 0; // targetが0の場合のNaN対策

            missionItem.innerHTML =
              "<h4>" +
              mission.title +
              "</h4>" +
              "<p>" +
              mission.description +
              "</p>" +
              (mission.isCompleted
                ? '<p class="mission-reward">完了！ 報酬: $' +
                  mission.reward.toLocaleString() +
                  "</p>"
                : mission.isActive
                ? '<p>進行状況: ' +
                  Math.round(mission.currentProgress).toLocaleString() +
                  " / " +
                  mission.target.toLocaleString() +
                  "</p>" +
                  '<div class="mission-progress-bar"><div class="mission-progress" style="width:' +
                  progress +
                  '%"></div></div>' +
                  '<p class="mission-reward">報酬: $' +
                  mission.reward.toLocaleString() +
                  "</p>"
                : '<p>ロックされています (前提ミッションを完了してください)</p>');

            this.missionListDiv.appendChild(missionItem);
          }
        },
      };

      // --- INITIAL LOAD ---
      ui.updateFinance();
      ui.updateGameTimeDisplay();
      ui.renderTrainShop();
      ui.setLineBuildModeActive(false); // 初期は非表示
      ui.setDemolitionModeActive(false); // 初期は非表示
      ui.costGround.textContent = CONFIG.costs.ground.perMeter;
      ui.costViaduct.textContent = CONFIG.costs.viaduct.perMeter;
      ui.costTunnel.textContent = CONFIG.costs.tunnel.perMeter;
      ui.renderMissions(); // 新規追加: ミッションリストの初期レンダリング

      // --- HELPER FUNCTIONS: 汎用ユーティリティ関数 ---

      /** ユニークなIDを生成する。 */
      function generateUniqueId() {
        return "_" + Math.random().toString(36).substr(2, 9);
      }

      /** IDに基づいて駅オブジェクトを検索する。 */
      function getStationById(id) {
        var i;
        for (i = 0; i < state.stations.length; i++) {
          if (state.stations[i].id === id) {
            return state.stations[i];
          }
        }
        return undefined;
      }

      /** IDに基づいて路線オブジェクトを検索する。 */
      function getLineById(id) {
        var i;
        for (i = 0; i < state.lines.length; i++) {
          if (state.lines[i].id === id) {
            return state.lines[i];
          }
        }
        return undefined;
      }

      /** IDに基づいて線路オブジェクトを検索する。 */
      function getTrackById(id) {
        var i;
        for (i = 0; i < state.tracks.length; i++) {
          if (state.tracks[i].id === id) {
            return state.tracks[i];
          }
        }
        return undefined;
      }

      /**
       * パス(LatLng配列)上の始点からの指定された距離にある点と、その点での進行方向を計算する。
       * @param {L.LatLng[]} latlngs - パスを構成するLatLngの配列。
       * @param {number} distance - パスの始点からの距離(メートル)。
       * @returns {{latlng: L.LatLng, heading: number}|null} - 緯度経度と進行方向(度)。パスの範囲外の場合はnull。
       */
      function getPointAtDistance(latlngs, distance) {
        if (!latlngs || latlngs.length < 2) {
          return null;
        }
        var currentDist = 0;
        for (var i = 0; i < latlngs.length - 1; i++) {
          var p1 = latlngs[i];
          var p2 = latlngs[i + 1];
          var segmentDist = p1.distanceTo(p2);
          if (currentDist + segmentDist >= distance) {
            var distIntoSegment = distance - currentDist;
            var ratio = segmentDist === 0 ? 0 : distIntoSegment / segmentDist;
            var lat = p1.lat + (p2.lat - p1.lat) * ratio;
            var lng = p1.lng + (p2.lng - p1.lng) * ratio;
            return {
              latlng: L.latLng(lat, lng),
              heading: getHeading(p1, p2),
            };
          }
          currentDist += segmentDist;
        }
        // 距離がパスの全長を超える場合は、最後の点を返す
        var lastP1 = latlngs[latlngs.length - 2];
        var lastP2 = latlngs[latlngs.length - 1];
        return {
          latlng: lastP2,
          heading: getHeading(lastP1, lastP2),
        };
      }

      /**
       * LatLngの配列で構成されるパス上の指定された進行度におけるLatLngと進行方向を計算する。
       * @param {L.LatLng[]} latlngs - パスを構成するLatLngの配列。
       * @param {number} progress - 0.0から1.0までの進行度。
       * @returns {{latlng: L.LatLng, heading: number}} - 緯度経度と進行方向（度）。
       */
      function getLatLngAtProgressOnPath(latlngs, progress) {
        if (!latlngs || latlngs.length < 2) {
          return { latlng: latlngs ? latlngs[0] : L.latLng(0, 0), heading: 0 };
        }

        var totalLength = 0;
        var segmentLengths = [];
        var i;
        for (i = 0; i < latlngs.length - 1; i++) {
          var segmentLength = latlngs[i].distanceTo(latlngs[i + 1]);
          segmentLengths.push(segmentLength);
          totalLength += segmentLength;
        }

        if (totalLength === 0) {
          return { latlng: latlngs[0], heading: 0 };
        }

        var targetDistance = totalLength * progress;

        // getPointAtDistance を再利用
        return getPointAtDistance(latlngs, targetDistance);
      }

      /**
       * 2点間の進行方向（角度）を計算する。
       * @param {L.LatLng} p1 - 始点。
       * @param {L.LatLng} p2 - 終点。
       * @returns {number} - 進行方向（度、北を0度として時計回り）。
       */
      function getHeading(p1, p2) {
        var toRad = Math.PI / 180;
        var toDeg = 180 / Math.PI;

        var lat1 = p1.lat * toRad;
        var lon1 = p1.lng * toRad;
        var lat2 = p2.lat * toRad;
        var lon2 = p2.lng * toRad;

        var dLon = lon2 - lon1;

        var y = Math.sin(dLon) * Math.cos(lat2);
        var x =
          Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

        var bearing = Math.atan2(y, x) * toDeg;
        bearing = (bearing + 360) % 360; // 0-360度の範囲に変換
        return bearing;
      }

      /**
       * メートル単位の長さを現在の地図のズームレベルと緯度に基づいてピクセルに変換する。
       * @param {number} meters - メートル単位の長さ。
       * @param {L.LatLng} latlng - 変換を行う緯度経度。
       * @returns {number} - ピクセル単位の長さ。
       */
      function metersToPixels(meters, latlng) {
        var point1 = map.latLngToLayerPoint(latlng);
        var metersPerDegreeLng =
          111320 * Math.cos((latlng.lat * Math.PI) / 180);
        var latlng2 = L.latLng(
          latlng.lat,
          latlng.lng + meters / metersPerDegreeLng
        );
        var point2 = map.latLngToLayerPoint(latlng2);
        return point1.distanceTo(point2);
      }

      /**
       * パス (LatLngの配列) の総距離をメートルで計算する。
       * @param {L.LatLng[]} pathLatLngs - パスを構成するLatLngの配列。
       * @returns {number} - パスの総距離 (メートル)。
       */
      function calculatePathDistance(pathLatLngs) {
        var distance = 0;
        var i;
        for (i = 0; i < pathLatLngs.length - 1; i++) {
          distance += pathLatLngs[i].distanceTo(pathLatLngs[i + 1]);
        }
        return distance;
      }
      /**
       * 緯度経度に基づいて駅オブジェクトを検索する（中心座標で比較）。
       * @param {L.LatLng} latlng - 検索する緯度経度。
       * @returns {object|null} - 見つかった駅オブジェクト、またはnull。
       */
      function findStationByLatLng(latlng) {
        for (var i = 0; i < state.stations.length; i++) {
          // L.LatLng.equals() を使って座標を比較
          if (state.stations[i].latlng.equals(latlng)) {
            return state.stations[i];
          }
        }
        return null;
      }

      /**
       * Catmull-Romスプライン補間を使用して、与えられた点列を滑らかにする。
       * @param {L.LatLng[]} points - 補間する点の配列。
       * @param {number} numSegments - 各セグメント間に生成する中間点の数。
       * @returns {L.LatLng[]} - 補間された点の配列。
       */
      function getCatmullRomSpline(points, numSegments) {
        if (points.length < 2) {
          return points;
        }
        if (points.length === 2) {
          // 2点の場合は直線
          return points;
        }

        numSegments = numSegments || CONFIG.splineSegmentsPerTrackSegment;

        var interpolatedPoints = [];
        var i;

        // 仮想の始点と終点を追加して、曲線が端点を通るようにする
        var p0, p1, p2, p3;

        // 最初のセグメント (p0 = p1)
        p0 = points[0];
        p1 = points[0];
        p2 = points[1];
        p3 = points.length > 2 ? points[2] : points[1]; // 3点未満の場合の対応
        for (i = 0; i <= numSegments; i++) {
          var t = i / numSegments;
          interpolatedPoints.push(interpolateCatmullRom(p0, p1, p2, p3, t));
        }

        // 中間のセグメント
        for (var j = 1; j < points.length - 2; j++) {
          p0 = points[j - 1];
          p1 = points[j];
          p2 = points[j + 1];
          p3 = points[j + 2];
          for (i = 1; i <= numSegments; i++) {
            // 最初の点は重複するので1から
            var t = i / numSegments;
            interpolatedPoints.push(interpolateCatmullRom(p0, p1, p2, p3, t));
          }
        }

        // 最後のセグメント (p3 = p2)
        p0 = points[points.length - 3];
        p1 = points[points.length - 2];
        p2 = points[points.length - 1];
        p3 = points[points.length - 1];
        for (i = 1; i <= numSegments; i++) {
          // 最初の点は重複するので1から
          var t = i / numSegments;
          interpolatedPoints.push(interpolateCatmullRom(p0, p1, p2, p3, t));
        }

        return interpolatedPoints;
      }

      /**
       * Catmull-Romスプライン補間の計算ヘルパー。
       * @param {L.LatLng} p0 - 制御点0
       * @param {L.LatLng} p1 - 制御点1 (開始点)
       * @param {L.LatLng} p2 - 制御点2 (終了点)
       * @param {L.LatLng} p3 - 制御点3
       * @param {number} t - 0から1までの補間パラメータ
       * @returns {L.LatLng} - 補間された点
       */
      function interpolateCatmullRom(p0, p1, p2, p3, t) {
        var t2 = t * t;
        var t3 = t2 * t;

        var c0 = 0.5 * (-t3 + 2 * t2 - t);
        var c1 = 0.5 * (2 * t3 - 3 * t2 + 1);
        var c2 = 0.5 * (-2 * t3 + 3 * t2 + t);
        var c3 = 0.5 * (t3 - t2);

        var lat = p0.lat * c0 + p1.lat * c1 + p2.lat * c2 + p3.lat * c3;
        var lng = p0.lng * c0 + p1.lng * c1 + p2.lng * c2 + p3.lng * c3;

        return L.latLng(lat, lng);
      }

      /**
       * 2つの駅間を接続する既存の線路パスを探索し、そのパスを構成するLatLngsを返す。
       * グラフ探索（BFS）により、連続した線路・駅プラットフォームを繋ぐ。
       * @param {L.LatLng} startStationLatLng - 始点駅の中心緯度経度。
       * @param {L.LatLng} endStationLatLng - 終点駅の中心緯度経度。
       * @returns {L.LatLng[]|null} - 見つかった線路パスのLatLng配列。見つからない場合はnullを返す。
       */
      function findPathBetweenStations_GraphSearch(
        startStationLatLng,
        endStationLatLng
      ) {
        var thresholdMeters = CONFIG.snapThresholdMeters;

        var startStationObj = findStationByLatLng(startStationLatLng);
        var endStationObj = findStationByLatLng(endStationLatLng);

        // 駅が見つからない、または同じ駅同士の探索は無効
        if (
          !startStationObj ||
          !endStationObj ||
          startStationObj.id === endStationObj.id
        ) {
          return null;
        }

        // 1. 探索のためのグラフ構造（隣接リスト）を作成
        var adj = {};
        var nodes = {};

        function addNode(id, latlng) {
          if (!adj[id]) {
            adj[id] = [];
            nodes[id] = { latlng: latlng };
          }
        }
        function addEdge(u, v, path) {
          adj[u].push({ to: v, path: path });
          adj[v].push({ to: u, path: [].concat(path).reverse() }); // 逆方向も追加
        }

        var i;
        // 線路をグラフに追加
        for (i = 0; i < state.tracks.length; i++) {
          var track = state.tracks[i];
          if (!track.latlngs || track.latlngs.length < 2) continue;
          var trackStartId = "track_" + track.id + "_start";
          var trackEndId = "track_" + track.id + "_end";
          addNode(trackStartId, track.latlngs[0]);
          addNode(trackEndId, track.latlngs[track.latlngs.length - 1]);
          addEdge(trackStartId, trackEndId, track.latlngs);
        }

        // 駅のプラットフォームをグラフに追加
        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (!station.latlngs || station.latlngs.length < 2) continue;
          var stationStartId = "station_" + station.id + "_start";
          var stationEndId = "station_" + station.id + "_end";
          addNode(stationStartId, station.latlngs[0]);
          addNode(stationEndId, station.latlngs[station.latlngs.length - 1]);
          addEdge(stationStartId, stationEndId, station.latlngs);
        }

        // ノード間の接続（線路同士、駅と線路など）をエッジとして追加
        var nodeIds = Object.keys(nodes);
        for (i = 0; i < nodeIds.length; i++) {
          for (var j = i + 1; j < nodeIds.length; j++) {
            var id1 = nodeIds[i];
            var id2 = nodeIds[j];
            var parts1 = id1.split("_");
            var parts2 = id2.split("_");

            // 同じオブジェクト（線路 or 駅）の端点同士は接続しない
            // IDは'type__randomid_endpoint'の形式なので、ID部分は2番目以降
            if (
              parts1[0] === parts2[0] &&
              parts1.length > 2 &&
              parts2.length > 2 &&
              parts1[2] === parts2[2]
            ) {
              continue;
            }

            if (
              nodes[id1].latlng.distanceTo(nodes[id2].latlng) < thresholdMeters
            ) {
              // 接続パスは2点間の直線
              addEdge(id1, id2, [nodes[id1].latlng, nodes[id2].latlng]);
            }
          }
        }

        // 2. BFSで始点駅の端から終点駅の端への経路を探索
        var startNodeIds = [
          "station_" + startStationObj.id + "_start",
          "station_" + startStationObj.id + "_end",
        ];
        var endNodeIds = [
          "station_" + endStationObj.id + "_start",
          "station_" + endStationObj.id + "_end",
        ];

        var queue = [];
        var visited = {}; // 訪問済みノードのIDを保持
        var pathMap = {}; // ノードIDからそこに至るまでのパスを保持

        // 始点駅の両端をキューの初期値として追加
        for (i = 0; i < startNodeIds.length; i++) {
          var startId = startNodeIds[i];
          if (nodes[startId]) {
            queue.push(startId);
            visited[startId] = true;
            pathMap[startId] = [nodes[startId].latlng];
          }
        }

        while (queue.length > 0) {
          var currentId = queue.shift();
          var currentPath = pathMap[currentId];

          // 終点駅のどちらかの端に到達したら成功
          if (endNodeIds.includes(currentId)) {
            return currentPath;
          }

          var neighbors = adj[currentId] || [];
          for (i = 0; i < neighbors.length; i++) {
            var neighbor = neighbors[i];
            if (!visited[neighbor.to]) {
              visited[neighbor.to] = true;

              var newPath = [].concat(currentPath);
              var segmentPath = neighbor.path;

              // 接続点で座標が重複しないようにパスを結合
              if (
                newPath.length > 0 &&
                segmentPath.length > 0 &&
                newPath[newPath.length - 1].equals(segmentPath[0])
              ) {
                Array.prototype.push.apply(newPath, segmentPath.slice(1));
              } else {
                Array.prototype.push.apply(newPath, segmentPath);
              }
              pathMap[neighbor.to] = newPath;
              queue.push(neighbor.to);
            }
          }
        }

        return null; // パスが見つからなかった場合
      }

      /**
       * 全てのモードを非アクティブにするヘルパー関数
       */
      function deactivateAllModes() {
        if (state.planning.type) {
          if (state.planning.ghost) {
            map.removeLayer(state.planning.ghost);
            state.planning.ghost = null;
          }
          if (state.planning.costTooltip) {
            map.removeLayer(state.planning.costTooltip);
            state.planning.costTooltip = null;
          }
          state.planning.points = [];
          state.planning.type = null;
          ui.resetBuildModeActive();
        }
        if (state.lineBuildingMode) {
          cancelLineBuilding();
        }
        if (state.demolitionMode) {
          cancelDemolition();
        }
        map.dragging.enable(); // マップドラッグを有効化
        map.getContainer().classList.remove("build-mode-cursor"); // カーソルを元に戻す
      }

      // --- MAP EVENTS FOR CONSTRUCTION ---
      var dragging = false; // マップドラッグ中かどうかのフラグ

      /**
       * 建設モードを開始または終了する。
       * @param {string} type - 建設タイプ ('ground', 'viaduct', 'tunnel', 'station').
       */
      function startPlanning(type) {
        if (state.planning.type === type) {
          // 同じボタンを再度押したら解除
          deactivateAllModes(); // 全モードを解除
          ui.showMessage("建設モードを解除しました。", "info");
          return;
        }

        // 新しい建設モードを開始
        deactivateAllModes();
        state.planning.type = type;
        state.planning.points = [];
        if (state.planning.ghost) {
          map.removeLayer(state.planning.ghost);
        } // 既存のゴーストをクリア
        state.planning.ghost = null;
        map.dragging.disable(); // 建設中はマップドラッグを無効化
        map.getContainer().classList.add("build-mode-cursor"); // カーソルを変更
        ui.showMessage(
          (type === "station" ? "駅" : "線路") +
            "建設モード: マップをドラッグして建設します。",
          "info",
          true
        );
        ui.setBuildModeActive(type);
      }

      // --- MAP EVENTS FOR CONSTRUCTION ---
      map.on("mousedown", function (e) {
        if (!state.planning.type) return; // 建設モードでない場合は何もしない

        dragging = true;
        var snappedPoint = snapPoint(e.latlng);
        state.planning.points = [snappedPoint]; // 最初の点を設定

        // ゴースト表示を更新
        if (state.planning.ghost) {
          map.removeLayer(state.planning.ghost);
        }
        if (state.planning.type === "station") {
          state.planning.ghost = L.polyline(
            [snappedPoint, snappedPoint],
            ghostStyle("station")
          ).addTo(map);
        } else {
          state.planning.ghost = L.polyline(
            [snappedPoint, snappedPoint],
            ghostStyle(state.planning.type)
          ).addTo(map);
        }

        // コストツールチップの作成
        if (!state.planning.costTooltip) {
          state.planning.costTooltip = L.divIcon({
            className: "construction-cost-tooltip",
            html: "ドラッグして長さを決定",
            iconAnchor: [0, 0], // 後で位置を調整
          });
          state.planning.costTooltip = L.marker(e.latlng, {
            icon: state.planning.costTooltip,
          }).addTo(map);
        }
      });

      map.on("mousemove", function (e) {
        if (
          dragging &&
          state.planning.type &&
          state.planning.points.length > 0
        ) {
          var snappedPoint = snapPoint(e.latlng);
          state.planning.ghost.setLatLngs([
            state.planning.points[0],
            snappedPoint,
          ]);

          // コストツールチップの更新
          if (state.planning.costTooltip) {
            var len = state.planning.points[0].distanceTo(snappedPoint);
            var cost = 0;
            if (state.planning.type === "station") {
              cost =
                CONFIG.costs.station.base + CONFIG.costs.station.perMeter * len;
            } else {
              cost = CONFIG.costs[state.planning.type].perMeter * len;
            }
            state.planning.costTooltip.setLatLng(e.latlng);
            state.planning.costTooltip
              .getIcon()
              .options.html =
              "長さ: " +
              len.toFixed(1) +
              "m<br>コスト: $" +
              Math.round(cost).toLocaleString();
            state.planning.costTooltip.redraw(); // アイコンのHTML変更を反映
          }
        }
      });

      map.on("mouseup", function (e) {
        if (
          dragging &&
          state.planning.type &&
          state.planning.points.length > 0
        ) {
          dragging = false;
          var snappedPoint = snapPoint(e.latlng);

          if (!state.planning.points[0].equals(snappedPoint)) {
            state.planning.points.push(snappedPoint);
          } else {
            if (state.planning.type === "station") {
              // 1点しかクリックされなかった場合、デフォルトのプラットフォーム長を生成
              var defaultLength = 20; // メートル
              var angle = 45; // 北東
              var latOffset = defaultLength / 111111;
              var lngOffset =
                defaultLength /
                (111111 * Math.cos((snappedPoint.lat * Math.PI) / 180));
              state.planning.points.push(
                L.latLng(
                  snappedPoint.lat +
                    latOffset * Math.cos((angle * Math.PI) / 180),
                  snappedPoint.lng +
                    lngOffset * Math.sin((angle * Math.PI) / 180)
                )
              );
            } else {
              ui.showMessage(
                "線路は2つの異なる点で構成する必要があります。",
                "warning",
                false,
                3000
              );
              if (state.planning.ghost) {
                map.removeLayer(state.planning.ghost);
                state.planning.ghost = null;
              }
              state.planning.points = [];
              ui.confirmBuildButton.disabled = true;
              ui.confirmBuildButton.textContent = "建設確定";
              // コストツールチップを削除
              if (state.planning.costTooltip) {
                map.removeLayer(state.planning.costTooltip);
                state.planning.costTooltip = null;
              }
              return;
            }
          }

          var cost = 0;
          var len = state.planning.points[0].distanceTo(
            state.planning.points[1]
          );
          if (state.planning.type === "station") {
            cost =
              CONFIG.costs.station.base + CONFIG.costs.station.perMeter * len;
          } else {
            cost = CONFIG.costs[state.planning.type].perMeter * len;
          }
          ui.confirmBuildButton.textContent =
            "建設確定 ($" + Math.round(cost).toLocaleString() + ")";
          ui.confirmBuildButton.disabled = state.assets < cost;

          // コストツールチップを削除
          if (state.planning.costTooltip) {
            map.removeLayer(state.planning.costTooltip);
            state.planning.costTooltip = null;
          }
        }
      });

      // --- SNAP TO NEARBY TRACK/STATION ---
      /**
       * 最も近い既存の線路の端点や駅に緯度経度をスナップさせる。
       * @param {L.LatLng} latlng - スナップ対象の緯度経度。
       * @returns {L.LatLng} - スナップされた緯度経度、または元の緯度経度。
       */
      function snapPoint(latlng) {
        var closest = { point: latlng, dist: Infinity };
        var currentPointPx = map.latLngToLayerPoint(latlng);
        var i;
        var snapCandidates = [];

        // 既存の線路の端点
        for (i = 0; i < state.tracks.length; i++) {
          snapCandidates.push(state.tracks[i].latlngs[0]);
          snapCandidates.push(
            state.tracks[i].latlngs[state.tracks[i].latlngs.length - 1]
          );
        }

        // 既存の駅のプラットフォームの端点をスナップ候補に追加
        for (i = 0; i < state.stations.length; i++) {
          if (
            state.stations[i].latlngs &&
            state.stations[i].latlngs.length >= 2
          ) {
            snapCandidates.push(state.stations[i].latlngs[0]);
            snapCandidates.push(
              state.stations[i].latlngs[state.stations[i].latlngs.length - 1]
            );
          }
        }

        for (i = 0; i < snapCandidates.length; i++) {
          var p = snapCandidates[i];
          var d = currentPointPx.distanceTo(map.latLngToLayerPoint(p));
          if (d < closest.dist && d < CONFIG.snapThresholdPixels) {
            closest = { point: p, dist: d };
          }
        }

        return closest.point;
      }
      // --- GHOST STYLE ---
      /**
       * 建設モードの仮表示（ゴースト）のスタイルを返す。
       * @param {string} type - 建設タイプ。
       * @returns {object} - Leafletのポリラインスタイルオブジェクト。
       */
      function ghostStyle(type) {
        var styles = {
          ground: { color: "#007bff", weight: 4, dashArray: "10,10" },
          viaduct: { color: "#0a0", weight: 4, dashArray: "5,5" },
          tunnel: { color: "#a0a", weight: 4, dashArray: "2,8" },
          station: {
            color: "#d9534f",
            weight: 6,
            opacity: 0.7,
            dashArray: "5, 10",
          },
          lineGhost: { color: "#888", weight: 5, dashArray: "5,10" }, // 路線設定中の仮線
        };
        return styles[type] || { color: "#000", weight: 4 };
      }

      // --- CONFIRM BUILD (TRACK/STATION): 建設の確定ロジック ---
      function confirmBuild() {
        if (!state.planning.type) {
          ui.showMessage("建設モードが選択されていません。", "warning");
          return;
        }
        if (state.planning.points.length < 2) {
          ui.showMessage("建設点が不足しています。", "warning", false, 3000);
          return;
        }

        var type = state.planning.type;
        var actualCost;
        var buildMessage;
        var points = state.planning.points;
        var len = points[0].distanceTo(points[1]);

        if (type === "station") {
          actualCost =
            CONFIG.costs.station.base + CONFIG.costs.station.perMeter * len;
          buildMessage = "プラットフォーム長 " + len.toFixed(1) + "m の駅";
        } else {
          actualCost = CONFIG.costs[type].perMeter * len;
          buildMessage =
            (type === "ground"
              ? "地上線"
              : type === "viaduct"
              ? "高架線"
              : "トンネル") +
            " (" +
            len.toFixed(1) +
            "m)";
        }

        if (state.assets < actualCost) {
          ui.showMessage("資金不足: 建設できません。", "error", false, 5000);
          return;
        }

        state.assets -= actualCost;

        if (type === "station") {
          var stationId = generateUniqueId();
          var stationName = "無名駅" + (state.stations.length + 1);
          var stationCenter = points[0];

          // 駅ホーム本体レイヤー
          var platformBodyLayer = L.polyline(points, {
            className: "station-platform-body",
            id: stationId,
          }).addTo(map);
          // 駅ホーム縁レイヤー
          var platformEdgeLayer = L.polyline(points, {
            className: "station-platform-edge",
            id: stationId,
          }).addTo(map);

          var marker = L.marker(stationCenter, {
            icon: L.divIcon({
              className: "station-marker",
              iconSize: [16, 16],
              html: "", // 路線設定モードで数字が入る
            }),
            id: stationId,
          }).addTo(map);

          var newStation = {
            id: stationId,
            name: stationName,
            latlng: stationCenter,
            latlngs: points,
            platformLength: len,
            bodyLayer: platformBodyLayer, // レイヤーを分割
            edgeLayer: platformEdgeLayer, // レイヤーを分割
            marker: marker,
            revenueMultiplier: 1.0, // 初期値は1.0、後で人口密度で更新
            passengersWaiting: [], // 新規追加: 駅で待機中の乗客リスト
            maxWaitingPassengers: Math.floor(
              len * CONFIG.maxWaitingPassengersPerMeterOfPlatform
            ), // 新規追加
          };
          state.stations.push(newStation);
          state.totalStationsBuilt++; // 新規追加: ミッション進行状況更新

          // 駅名ツールチップをバインド
          marker.bindTooltip(newStation.name, {
            permanent: true,
            direction: "top",
            className: "station-name-tooltip",
          });
          marker.getTooltip()._container.style.display =
            map.getZoom() >= 13 ? "block" : "none"; // ズームレベルに応じて表示/非表示

          marker.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var currentId = e.target.options.id;
            if (state.lineBuildingMode) {
              handleStationClickForLineBuilding(currentId);
            } else if (state.demolitionMode) {
              selectForDemolition("station", currentId);
            } else {
              // 修正2: 通常クリック時にポップアップを開く
              e.target.openPopup();
            }
          });
          platformBodyLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var currentId = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", currentId);
            }
          });
          platformEdgeLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var currentId = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", currentId);
            }
          });

          fetch(
            "https://nominatim.openstreetmap.org/reverse?format=json&lat=" +
              stationCenter.lat +
              "&lon=" +
              stationCenter.lng +
              "&zoom=18&addressdetails=1"
          )
            .then(function (response) {
              return response.json();
            })
            .then(function (data) {
              var resolvedName =
                "無名駅" + (stationCenter.lat.toFixed(4) + ")");
              // var revenueMultiplier = 1.0; // 既存の地名APIからの収益倍率ロジックは削除

              if (data && data.address) {
                var addr = data.address;
                // 地名APIからの収益倍率設定ロジックは削除
                var nameCandidate =
                  addr.station ||
                  addr.railway ||
                  addr.town ||
                  addr.village ||
                  addr.suburb ||
                  addr.neighbourhood ||
                  addr.city;
                if (nameCandidate) {
                  resolvedName = nameCandidate.match(/(区|市|町|村|郡)$/)
                    ? nameCandidate
                    : nameCandidate + "駅";
                }
              }

              newStation.name = resolvedName;
              // newStation.revenueMultiplier = revenueMultiplier; // 既存の地名APIからの収益倍率設定ロジックは削除

              // 人口密度に基づいて収益倍率を設定
              setStationRevenueMultiplier(newStation);
              newStation.marker.getTooltip().setContent(newStation.name); // ツールチップも更新

              ui.showMessage(
                resolvedName +
                  "を建設しました！ (" +
                  buildMessage +
                  ", $" +
                  Math.round(actualCost).toLocaleString() +
                  ")",
                "success",
                false,
                2500
              );
              ui.renderTrainShop();
              checkMissionProgress("build_station_count"); // 新規追加: ミッション進行状況更新
            })
            .catch(function (error) {
              console.error("地名APIの取得に失敗しました:", error);
              // 地名APIが失敗しても人口密度は設定する
              newStation.name = "無名駅 (" + stationCenter.lat.toFixed(4) + ")";
              setStationRevenueMultiplier(newStation);
              newStation.marker.getTooltip().setContent(newStation.name); // ツールチップも更新
              ui.showMessage(
                "地名取得失敗: " +
                  newStation.name +
                  "を建設しました。 (" +
                  buildMessage +
                  ", $" +
                  Math.round(actualCost).toLocaleString() +
                  ")",
                "warning",
                false,
                2500
              );
              checkMissionProgress("build_station_count"); // 新規追加: ミッション進行状況更新
            });
        } else {
          // 線路建設
          var smoothedLatLngs = getCatmullRomSpline(
            points,
            CONFIG.splineSegmentsPerTrackSegment
          );

          var trackId = generateUniqueId();
          var railLayer = L.polyline(smoothedLatLngs, {
            className: "track-rail track-" + type + "-rail",
            id: trackId,
          }).addTo(map);
          var sleeperLayer = L.polyline(smoothedLatLngs, {
            className: "track-sleeper track-" + type + "-sleeper",
            id: trackId,
          }).addTo(map);

          state.tracks.push({
            id: trackId,
            latlngs: smoothedLatLngs, // スプライン補間された点列を保存
            railLayer: railLayer, // レイヤーを分割
            sleeperLayer: sleeperLayer, // レイヤーを分割
            type: type,
          });
          state.totalTrackLengthBuilt += len; // 新規追加: ミッション進行状況更新

          railLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", this.options.id);
            }
          });
          sleeperLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", e.target.options.id);
            }
          });

          ui.showMessage(
            buildMessage +
              "を建設しました！ ($" +
              Math.round(actualCost).toLocaleString() +
              ")",
            "success",
            false,
            2000
          );
          checkMissionProgress("build_track_length"); // 新規追加: ミッション進行状況更新
        }

        if (state.planning.ghost) {
          map.removeLayer(state.planning.ghost);
          state.planning.ghost = null;
        }
        state.planning.points = [];
        state.planning.type = null;
        map.dragging.enable();
        map.getContainer().classList.remove("build-mode-cursor"); // カーソルを元に戻す
        ui.resetBuildModeActive();
        ui.updateFinance();
      }

      // ズームレベルに応じて駅名ツールチップの表示/非表示を切り替える
      map.on("zoomend", function () {
        var currentZoom = map.getZoom();
        for (var i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (station.marker && station.marker.getTooltip()) {
            station.marker.getTooltip()._container.style.display =
              currentZoom >= 13 ? "block" : "none";
          }
        }
      });

      // --- TRAIN SHOP LOGIC: 列車ショップの機能 ---

      /** 購入する列車を選択する。 */
      function selectTrainToBuy(trainId) {
        state.selectedTrainToBuyId = trainId;
        ui.renderTrainShop();
      }

      /** 選択された列車を購入する。 */
      function buySelectedTrain() {
        var trainToBuyConfig = CONFIG.trains.find(function (t) {
          return t.id === state.selectedTrainToBuyId;
        });
        if (!trainToBuyConfig) {
          ui.showMessage("列車が選択されていません。", "warning");
          return;
        }
        if (state.assets < trainToBuyConfig.cost) {
          ui.showMessage("資金不足: 列車を購入できません。", "error", false, 5000);
          return;
        }

        state.assets -= trainToBuyConfig.cost;
        var newTrain = {
          id: generateUniqueId(),
          type: trainToBuyConfig.id,
          name: trainToBuyConfig.name,
          cars: trainToBuyConfig.cars,
          cost: trainToBuyConfig.cost,
          color: trainToBuyConfig.color,
          speed: trainToBuyConfig.defaultSpeed,
          totalLength:
            trainToBuyConfig.cars * CONFIG.trainCarDimensionsMeters.length,
          currentStationId: null,
          currentLineId: null,
          currentSegmentIndex: 0,
          direction: 1,
          progress: 0,
          isStopped: false,
          stopTimer: null,
          carMarkers: [], // 変更: carLayersからcarMarkersへ
          currentLatLng: null,
          currentHeading: 0,
          currentPassengers: [], // 変更: 乗客オブジェクトの配列
          maxCapacity: trainToBuyConfig.cars * CONFIG.passengerCapacityPerCar, // 新規追加: 最大乗客容量
        };
        state.trains.push(newTrain);
        state.totalTrainsBought++; // 新規追加: ミッション進行状況更新

        ui.updateFinance();
        ui.showMessage(trainToBuyConfig.name + "を購入しました！", "success", false, 2000);
        state.selectedTrainToBuyId = null;
        ui.renderTrainShop();
        checkMissionProgress("buy_train_count"); // 新規追加: ミッション進行状況更新
        // renderTrains(); // 列車が割り当てられたらレンダリングを更新 (gameLoopで自動的に行われる)
      }

      /** 路線に割り当てる列車を選択する。 */
      function selectTrainToAssign(trainId) {
        state.selectedTrainToAssignId = trainId;
        ui.renderTrainShop();
      }

      /**
       * 指定された路線の総車両数と総列車数を更新する。
       * 列車が路線に割り当てられたり、割り当てが解除されたりするたびに呼び出す。
       * @param {string} lineId - 路線のID。
       */
      function updateLineTrainCounts(lineId) {
        var line = getLineById(lineId);
        if (!line) return;

        line.totalTrainsOnLine = 0;
        line.totalCarsOnLine = 0;

        for (var i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];
          if (train.currentLineId === lineId) {
            line.totalTrainsOnLine++;
            line.totalCarsOnLine += train.cars;
          }
        }
      }

      /** 選択された列車を路線に割り当てる。 */
      function assignSelectedTrainToLine() {
        var trainId = state.selectedTrainToAssignId;
        var lineId = ui.lineSelectForAssignment.value;

        if (!trainId || !lineId) {
          ui.showMessage("列車と路線を選択してください。", "warning");
          return;
        }

        var train = state.trains.find(function (t) {
          return t.id === trainId;
        });
        var line = getLineById(lineId);

        if (!train || !line) {
          ui.showMessage("無効な列車または路線です。", "error");
          return;
        }
        if (line.segments.length === 0) {
          ui.showMessage("選択された路線には有効なセグメントがありません。", "warning");
          return;
        }

        // 以前の路線から列車を外す
        if (train.currentLineId) {
          var oldLine = getLineById(train.currentLineId);
          if (oldLine && oldLine.assignedTrainIds) {
            oldLine.assignedTrainIds = oldLine.assignedTrainIds.filter(
              function (id) {
                return id !== train.id;
              }
            );
            updateLineTrainCounts(oldLine.id); // 以前の路線の列車数を更新
          }
          // 列車が路線から外れる際に、マップ上のマーカーを削除
          if (train.carMarkers) {
            for (var k = 0; k < train.carMarkers.length; k++) {
              if (train.carMarkers[k] && map.hasLayer(train.carMarkers[k])) {
                map.removeLayer(train.carMarkers[k]);
              }
            }
          }
          train.carMarkers = []; // マーカー配列をクリア
        }

        train.currentLineId = line.id;
        train.currentSegmentIndex = 0;
        train.direction = 1;
        train.progress = 0;
        train.isStopped = false;
        train.stopTimer = null;
        train.currentStationId = null;
        train.currentPassengers = []; // 路線割り当て時に乗客をリセット

        var firstSegment = line.segments[0];
        if (firstSegment && firstSegment.latlngs.length > 0) {
          train.currentLatLng = firstSegment.latlngs[0];
          train.currentHeading = getHeading(
            firstSegment.latlngs[0],
            firstSegment.latlngs[1] || firstSegment.latlngs[0]
          );
        } else {
          console.warn("路線の最初のセグメントが見つかりません。");
          train.currentLineId = null;
          return;
        }

        if (!line.assignedTrainIds) {
          line.assignedTrainIds = [];
        }
        line.assignedTrainIds.push(train.id);

        updateLineTrainCounts(line.id); // 新しい路線の列車数を更新

        ui.showMessage(
          train.name + "を路線 " + line.name + "に割り当てました。",
          "success",
          false,
          2000
        );
        state.selectedTrainToAssignId = null;
        ui.renderTrainShop();
        renderTrains(); // 列車が割り当てられたらレンダリングを更新
      }

      // --- LINE BUILDING LOGIC: 路線設定の機能 ---

      /** 路線設定モードを開始する。 */
      function startLineBuilding() {
        if (state.lineBuildingMode) {
          cancelLineBuilding();
          return;
        }

        deactivateAllModes();
        state.lineBuildingMode = true;
        state.selectedStationsForLine = [];
        if (state.currentLineGhost) {
          map.removeLayer(state.currentLineGhost);
          state.currentLineGhost = null;
        }
        ui.showMessage(
          "路線設定モードを開始しました。駅をクリックして路線に追加してください。",
          "info",
          true
        );
        ui.setLineBuildModeActive(true);
        map.dragging.disable();

        var i;
        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (station.marker && station.marker._icon) {
            station.marker._icon.classList.add("station-marker-selectable");
          }
        }
        ui.updateSelectedStationsForLine();
      }

      /**
       * 路線設定モード中に駅がクリックされたときのハンドラ。
       * @param {string} stationId - クリックされた駅のID。
       */
      function handleStationClickForLineBuilding(stationId) {
        if (!state.lineBuildingMode) return;

        var station = getStationById(stationId);
        if (!station) return;

        var index = state.selectedStationsForLine.indexOf(stationId);
        if (index > -1) {
          removeStationFromLineBuilding(stationId);
          ui.showMessage(
            station.name + "を路線から削除しました。",
            "info",
            false,
            1500
          );
        } else {
          state.selectedStationsForLine.push(stationId);
          ui.showMessage(station.name + "を路線に追加しました。", "info", false, 1500);
          if (station.marker && station.marker._icon) {
            station.marker._icon.classList.add("selected-for-line");
          }
        }

        ui.updateSelectedStationsForLine();
        updateLineGhost();

        // 駅マーカーの番号を更新
        for (var i = 0; i < state.stations.length; i++) {
          var s = state.stations[i];
          var idx = state.selectedStationsForLine.indexOf(s.id);
          if (s.marker && s.marker.getElement()) {
            s.marker.getElement().innerHTML = idx > -1 ? idx + 1 : "";
          }
        }
      }

      /**
       * 路線設定モードから駅を削除する。
       * @param {string} stationIdToRemove - 削除する駅のID。
       */
      function removeStationFromLineBuilding(stationIdToRemove) {
        var index = state.selectedStationsForLine.indexOf(stationIdToRemove);
        if (index > -1) {
          state.selectedStationsForLine.splice(index, 1);
        }

        var station = getStationById(stationIdToRemove);
        if (station && station.marker && station.marker._icon) {
          station.marker._icon.classList.remove("selected-for-line");
          station.marker.getElement().innerHTML = ""; // 番号をクリア
        }
        ui.updateSelectedStationsForLine();
        updateLineGhost();

        // 残りの駅の番号を更新
        for (var i = 0; i < state.stations.length; i++) {
          var s = state.stations[i];
          var idx = state.selectedStationsForLine.indexOf(s.id);
          if (s.marker && s.marker.getElement()) {
            s.marker.getElement().innerHTML = idx > -1 ? idx + 1 : "";
          }
        }
      }

      /** 路線設定中の仮ポリライン（ゴースト）を更新する。 */
      function updateLineGhost() {
        if (state.currentLineGhost) {
          map.removeLayer(state.currentLineGhost);
          state.currentLineGhost = null;
        }
        if (state.selectedStationsForLine.length < 2) {
          return;
        }

        var ghostPath = [];
        var pathFound = true;
        for (var i = 0; i < state.selectedStationsForLine.length - 1; i++) {
          var startStation = getStationById(state.selectedStationsForLine[i]);
          var endStation = getStationById(state.selectedStationsForLine[i + 1]);
          if (startStation && endStation) {
            var segmentPath = findPathBetweenStations_GraphSearch(
              startStation.latlng,
              endStation.latlng
            );

            if (segmentPath) {
              if (
                ghostPath.length > 0 &&
                segmentPath.length > 0 &&
                ghostPath[ghostPath.length - 1].equals(segmentPath[0])
              ) {
                Array.prototype.push.apply(ghostPath, segmentPath.slice(1));
              } else {
                Array.prototype.push.apply(ghostPath, segmentPath);
              }
            } else {
              pathFound = false;
              ui.showMessage(
                "警告: " +
                  startStation.name +
                  " と " +
                  endStation.name +
                  " 間に接続された線路がありません。",
                "warning",
                false,
                4000
              );
              break;
            }
          }
        }

        if (pathFound && ghostPath.length >= 2) {
          state.currentLineGhost = L.polyline(
            ghostPath,
            ghostStyle("lineGhost")
          ).addTo(map);
        }
      }

      /** 路線設定を確定する。 */
      function confirmLineBuilding() {
        if (state.selectedStationsForLine.length < 2) {
          ui.showMessage("路線には2つ以上の駅が必要です。", "warning");
          return;
        }

        var totalLineDistance = 0;
        var lineSegmentsForTrainMovement = [];
        var linePathLatLngsForDisplay = [];
        var pathFoundSuccessfully = true;

        for (var i = 0; i < state.selectedStationsForLine.length - 1; i++) {
          var startStation = getStationById(state.selectedStationsForLine[i]);
          var endStation = getStationById(state.selectedStationsForLine[i + 1]);

          if (startStation && endStation) {
            var segmentPath = findPathBetweenStations_GraphSearch(
              startStation.latlng,
              endStation.latlng
            );

            if (segmentPath) {
              var distance = calculatePathDistance(segmentPath);
              totalLineDistance += distance;
              lineSegmentsForTrainMovement.push({
                startStationId: startStation.id,
                endStationId: endStation.id,
                latlngs: segmentPath,
                distance: distance,
              });
              if (linePathLatLngsForDisplay.length > 0) {
                Array.prototype.push.apply(
                  linePathLatLngsForDisplay,
                  segmentPath.slice(1)
                );
              } else {
                Array.prototype.push.apply(
                  linePathLatLngsForDisplay,
                  segmentPath
                );
              }
            } else {
              pathFoundSuccessfully = false;
              ui.showMessage(
                "エラー: " +
                  startStation.name +
                  "から" +
                  endStation.name +
                  "への経路が見つかりませんでした。路線を作成できません。",
                "error",
                false,
                5000
              );
              break;
            }
          }
        }

        if (!pathFoundSuccessfully) {
          return;
        }

        var actualLineCost =
          CONFIG.costs.line.base +
          CONFIG.costs.line.perMeter * totalLineDistance;
        if (state.assets < actualLineCost) {
          ui.showMessage("資金不足: 路線を確定できません。", "error", false, 5000);
          return;
        }

        state.assets -= actualLineCost;

        var lineId = generateUniqueId();
        var lineColor = CONFIG.lineColors[state.currentLineColorIndex];
        state.currentLineColorIndex =
          (state.currentLineColorIndex + 1) % CONFIG.lineColors.length;

        // 路線名を入力させるプロンプトを追加
        var lineName = prompt("路線の名前を入力してください:", "新路線");
        if (!lineName || lineName.trim() === "") {
          lineName = "無名路線 " + (state.lines.length + 1);
        }

        var lineLayer = L.polyline(linePathLatLngsForDisplay, {
          className: "line-color",
          color: lineColor,
          weight: 5,
          opacity: 0.8,
          id: lineId,
        }).addTo(map);

        state.lines.push({
          id: lineId,
          name: lineName, // 路線名を追加
          stationIds: [].concat(state.selectedStationsForLine),
          color: lineColor,
          layer: lineLayer,
          segments: lineSegmentsForTrainMovement,
          totalDistance: totalLineDistance,
          assignedTrainIds: [],
          totalTrainsOnLine: 0, // 新規追加: 路線上の総列車数
          totalCarsOnLine: 0, // 新規追加: 路線上の総車両数
        });
        state.totalLinesBuilt++; // 新規追加: ミッション進行状況更新

        ui.updateFinance();
        ui.showMessage(
          lineName +
            "を確定しました！ (総距離 " +
            totalLineDistance.toFixed(1) +
            "m, コスト $" +
            Math.round(actualLineCost).toLocaleString() +
            ")",
          "success",
          false,
          2000
        );
        cancelLineBuilding();
        ui.renderTrainShop();
        checkMissionProgress("build_line_count"); // 新規追加: ミッション進行状況更新
      }

      /** 路線設定をキャンセルする。 */
      function cancelLineBuilding() {
        state.lineBuildingMode = false;
        var i;
        for (i = 0; i < state.selectedStationsForLine.length; i++) {
          var station = getStationById(state.selectedStationsForLine[i]);
          if (station && station.marker && station.marker._icon) {
            station.marker._icon.classList.remove("selected-for-line");
            station.marker.getElement().innerHTML = ""; // 番号をクリア
          }
        }
        state.selectedStationsForLine = [];
        if (state.currentLineGhost) {
          map.removeLayer(state.currentLineGhost);
          state.currentLineGhost = null;
        }
        ui.showMessage("路線設定をキャンセルしました。", "info");
        ui.setLineBuildModeActive(false);
        ui.updateSelectedStationsForLine();
        map.dragging.enable();

        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (station.marker && station.marker._icon) {
            station.marker._icon.classList.remove("station-marker-selectable");
          }
        }
      }

      // --- DEMOLITION LOGIC: 解体機能 ---
      /** 解体モードを開始する。 */
      function startDemolitionMode() {
        if (state.demolitionMode) {
          cancelDemolition();
          return;
        }
        deactivateAllModes();
        state.demolitionMode = true;
        state.selectedForDemolition = null;
        ui.showMessage(
          "解体モード: 解体したい線路や駅をクリックしてください。",
          "info",
          true
        );
        ui.setDemolitionModeActive(true);
        map.dragging.disable();
      }

      /**
       * 解体モード中にマップ上のオブジェクトがクリックされたときのハンドラ。
       * @param {string} type - 'track' または 'station'。
       * @param {string} id - オブジェクトのID。
       */
      function selectForDemolition(type, id) {
        if (!state.demolitionMode) return;

        var demolitionTargetDisplayMap = {
          track: function (id) {
            return "選択中: 線路 (ID: " + id.substring(0, 5) + "...)";
          },
          station: function (id) {
            var station = getStationById(id);
            return "選択中: 駅 (" + (station ? station.name : "不明") + ")";
          },
        };

        // ハイライト解除
        if (state.selectedForDemolition) {
          var prevType = state.selectedForDemolition.type;
          var prevId = state.selectedForDemolition.id;
          var prevObj =
            prevType === "track"
              ? getTrackById(prevId)
              : getStationById(prevId);
          if (prevObj) {
            if (prevType === "track") {
              if (prevObj.railLayer && prevObj.railLayer._path)
                prevObj.railLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (prevObj.sleeperLayer && prevObj.sleeperLayer._path)
                prevObj.sleeperLayer._path.classList.remove(
                  "selected-for-demolition"
                );
            } else if (prevType === "station") {
              if (prevObj.bodyLayer && prevObj.bodyLayer._path)
                prevObj.bodyLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (prevObj.edgeLayer && prevObj.edgeLayer._path)
                prevObj.edgeLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (prevObj.marker && prevObj.marker._icon)
                prevObj.marker._icon.classList.remove(
                  "selected-for-demolition"
                );
            }
          }
        }

        // 新しいオブジェクトを選択し、ハイライト
        state.selectedForDemolition = { type: type, id: id };
        var currentObj =
          type === "track" ? getTrackById(id) : getStationById(id);
        if (currentObj) {
          if (type === "track") {
            if (currentObj.railLayer && currentObj.railLayer._path)
              currentObj.railLayer._path.classList.add(
                "selected-for-demolition"
              );
            if (currentObj.sleeperLayer && currentObj.sleeperLayer._path)
              currentObj.sleeperLayer._path.classList.add(
                "selected-for-demolition"
              );
          } else if (type === "station") {
            if (currentObj.bodyLayer && currentObj.bodyLayer._path)
              currentObj.bodyLayer._path.classList.add(
                "selected-for-demolition"
              );
            if (currentObj.edgeLayer && currentObj.edgeLayer._path)
              currentObj.edgeLayer._path.classList.add(
                "selected-for-demolition"
              );
            if (currentObj.marker && currentObj.marker._icon)
              currentObj.marker._icon.classList.add("selected-for-demolition");
          }
          ui.selectedDemolitionTargetDisplay.textContent =
            demolitionTargetDisplayMap[type](id);
        }
        ui.confirmDemolitionButton.disabled = false;
      }

      /** 選択されたオブジェクトを解体する。 */
      function confirmDemolition() {
        if (!state.selectedForDemolition) {
          ui.showMessage("解体するオブジェクトが選択されていません。", "warning");
          return;
        }

        var type = state.selectedForDemolition.type;
        var id = state.selectedForDemolition.id;
        var i;

        if (type === "track") {
          var trackIndex = state.tracks.findIndex(function (t) {
            return t.id === id;
          });
          if (trackIndex === -1) {
            return;
          }

          var trackToDemolish = state.tracks[trackIndex];
          map.removeLayer(trackToDemolish.railLayer);
          map.removeLayer(trackToDemolish.sleeperLayer);
          state.tracks.splice(trackIndex, 1);
          state.totalTrackLengthBuilt -= calculatePathDistance(
            trackToDemolish.latlngs
          ); // ミッション進行状況更新
          ui.showMessage("線路を解体しました。", "success", false, 2000);

          // この線路を使用していた可能性のある全ての路線を再検証・削除
          var affectedLines = state.lines.filter(function (line) {
            return !line.segments.every(function (seg) {
              var start = getStationById(seg.startStationId);
              var end = getStationById(seg.endStationId);
              return (
                start &&
                end &&
                findPathBetweenStations_GraphSearch(
                  start.latlng,
                  end.latlng
                ) !== null
              );
            });
          });
          for (i = 0; i < affectedLines.length; i++) {
            removeLine(affectedLines[i].id);
          }
        } else if (type === "station") {
          var stationIndex = state.stations.findIndex(function (s) {
            return s.id === id;
          });
          if (stationIndex === -1) {
            return;
          }
          var stationToDemolish = state.stations[stationIndex];

          map.removeLayer(stationToDemolish.bodyLayer);
          map.removeLayer(stationToDemolish.edgeLayer);
          map.removeLayer(stationToDemolish.marker);
          if (stationToDemolish.marker.getTooltip()) {
            map.removeLayer(stationToDemolish.marker.getTooltip());
          } // ツールチップも削除
          state.stations.splice(stationIndex, 1);
          state.totalStationsBuilt--; // ミッション進行状況更新
          ui.showMessage(
            stationToDemolish.name + "を解体しました。",
            "success",
            false,
            2000
          );

          // この駅を含む路線を全て削除
          var linesToRemove = state.lines.filter(function (line) {
            return line.stationIds.includes(id);
          });
          for (i = 0; i < linesToRemove.length; i++) {
            removeLine(linesToRemove[i].id);
          }
        }

        cancelDemolition();
        ui.renderTrainShop();
        ui.updateFinance(); // 資産表示更新
        ui.updateGameTimeDisplay(); // 維持費表示更新
        checkMissionProgress("build_track_length"); // ミッション進行状況更新
        checkMissionProgress("build_station_count"); // ミッション進行状況更新
      }

      /** 路線を削除するヘルパー関数 */
      function removeLine(lineId) {
        var lineIndex = state.lines.findIndex(function (l) {
          return l.id === lineId;
        });
        if (lineIndex === -1) return;

        var lineToRemove = state.lines[lineIndex];

        var i, j;
        if (lineToRemove.assignedTrainIds) {
          for (i = 0; i < lineToRemove.assignedTrainIds.length; i++) {
            var train = state.trains.find(function (t) {
              return t.id === lineToRemove.assignedTrainIds[i];
            });
            if (train) {
              train.currentLineId = null;
              // 既存の carLayers を削除する代わりに carMarkers を削除
              if (train.carMarkers) {
                for (j = 0; j < train.carMarkers.length; j++) {
                  if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                    map.removeLayer(train.carMarkers[j]);
                  }
                }
                train.carMarkers = []; // クリア
              }
              train.currentLatLng = null;
              train.isStopped = true;
              if (train.stopTimer) clearTimeout(train.stopTimer);
              train.currentPassengers = [];
            }
          }
        }

        map.removeLayer(lineToRemove.layer);
        state.lines.splice(lineIndex, 1);
        state.totalLinesBuilt--; // ミッション進行状況更新
        ui.showMessage(
          "路線 " + lineToRemove.name + " が削除されました。",
          "info",
          false,
          3000
        );
        ui.renderTrainShop(); // 列車ショップも更新して、割り当て解除を反映
        checkMissionProgress("build_line_count"); // ミッション進行状況更新
      }

      /** 解体モードをキャンセルする。 */
      function cancelDemolition() {
        if (state.selectedForDemolition) {
          var type = state.selectedForDemolition.type;
          var id = state.selectedForDemolition.id;
          var obj = type === "track" ? getTrackById(id) : getStationById(id);
          if (obj) {
            if (type === "track") {
              if (obj.railLayer && obj.railLayer._path)
                obj.railLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (obj.sleeperLayer && obj.sleeperLayer._path)
                obj.sleeperLayer._path.classList.remove(
                  "selected-for-demolition"
                );
            } else if (type === "station") {
              if (obj.bodyLayer && obj.bodyLayer._path)
                obj.bodyLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (obj.edgeLayer && obj.edgeLayer._path)
                obj.edgeLayer._path.classList.remove(
                  "selected-for-demolition"
                );
              if (obj.marker && obj.marker._icon)
                obj.marker._icon.classList.remove("selected-for-demolition");
            }
          }
        }
        state.demolitionMode = false;
        state.selectedForDemolition = null;
        ui.showMessage("解体モードをキャンセルしました。", "info");
        ui.setDemolitionModeActive(false);
        map.dragging.enable();
      }

      // --- TRAIN MOVEMENT LOGIC: 列車移動の計算と更新 ---
      /** 全列車の位置と状態を更新する。 */
      function updateTrains(deltaTime) {
        // var deltaTime = (CONFIG.updateInterval / 1000) * state.gameSpeedMultiplier; // 秒単位 // 削除
        var i;

        for (i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];

          if (!train.currentLineId || train.isStopped) {
            continue;
          }

          var line = getLineById(train.currentLineId);
          if (!line || !line.segments || line.segments.length === 0) {
            console.warn(
              "Train " + train.id + ": Invalid line. Stopping train."
            );
            train.currentLineId = null;
            train.isStopped = true;
            continue;
          }

          var currentSegment = line.segments[train.currentSegmentIndex];
          if (
            !currentSegment ||
            !currentSegment.latlngs ||
            currentSegment.latlngs.length < 2
          ) {
            console.warn(
              "Train " + train.id + ": Invalid segment. Stopping train."
            );
            train.currentLineId = null;
            train.isStopped = true;
            continue;
          }

          var speed_mps = (train.speed * 1000) / 3600; // km/h を m/s に変換
          var distanceMoved = speed_mps * deltaTime;
          var segmentLength = currentSegment.distance;
          if (segmentLength === 0) {
            // ゼロ除算対策
            train.progress = train.direction === 1 ? 1.0 : 0;
            handleArrival(
              train,
              line,
              train.direction === 1
                ? line.stationIds[train.currentSegmentIndex + 1]
                : line.stationIds[train.currentSegmentIndex],
              train.progress
            );
            continue;
          }

          var progressChange = distanceMoved / segmentLength;
          train.progress += train.direction * progressChange;

          // 進行方向に応じて終点・始点チェック
          if (train.direction === 1 && train.progress >= 1.0) {
            // 順方向で終点到着
            var arrivedStationId =
              line.stationIds[train.currentSegmentIndex + 1];
            handleArrival(train, line, arrivedStationId, 1.0);
          } else if (train.direction === -1 && train.progress <= 0) {
            // 逆方向で始点到着
            var arrivedStationId = line.stationIds[train.currentSegmentIndex];
            handleArrival(train, line, arrivedStationId, 0);
          } else {
            // セグメント内を移動中
            var data = getLatLngAtProgressOnPath(
              currentSegment.latlngs,
              train.progress
            );
            if (data) {
              train.currentLatLng = data.latlng;
              train.currentHeading = data.heading;
              if (train.direction === -1) {
                train.currentHeading = (train.currentHeading + 180) % 360;
              }
            }
          }
        }
      }

      /**
       * 駅到着時の処理をまとめたヘルパー関数
       */
      function handleArrival(train, line, arrivedStationId, progressAtArrival) {
        train.progress = progressAtArrival;
        var station = getStationById(arrivedStationId); // station変数名に変更

        function moveToNextSegment() {
          if (train.direction === 1) {
            // 順方向
            if (train.currentSegmentIndex >= line.segments.length - 1) {
              // 路線の終点
              train.direction = -1; // 方向転換
            } else {
              train.currentSegmentIndex++;
              train.progress = 0;
            }
          } else {
            // 逆方向
            if (train.currentSegmentIndex <= 0) {
              // 路線の始点
              train.direction = 1; // 方向転換
            } else {
              train.currentSegmentIndex--;
              train.progress = 1.0;
            }
          }
        }

        if (
          station && // station変数名に変更
          station.platformLength >= train.totalLength
        ) {
          train.isStopped = true;
          train.currentStationId = arrivedStationId;
          train.currentLatLng = station.latlng; // station変数名に変更

          // --- 乗客の降車処理 ---
          var passengersDisembarked = 0;
          var remainingPassengers = [];
          for (var i = 0; i < train.currentPassengers.length; i++) {
            var passenger = train.currentPassengers[i];
            if (passenger.destinationStationId === arrivedStationId) {
              // 変更点: 駅のrevenueMultiplierを乗算
              state.assets +=
                CONFIG.passengerRevenuePerPerson * station.revenueMultiplier; // station変数名に変更
              passengersDisembarked++;
            } else {
              remainingPassengers.push(passenger);
            }
          }
          train.currentPassengers = remainingPassengers;
          if (passengersDisembarked > 0) {
            ui.showMessage(
              passengersDisembarked +
                "人の乗客が" +
                station.name + // station変数名に変更
                "で降車し、$" +
                (
                  passengersDisembarked *
                  CONFIG.passengerRevenuePerPerson *
                  station.revenueMultiplier // station変数名に変更
                ).toLocaleString() + // ここも表示に合わせて変更
                "の収益を得ました。",
              "success",
              false,
              2000
            );
            state.totalPassengersTransported += passengersDisembarked; // 新規追加: ミッション進行状況更新
            checkMissionProgress("transport_passengers"); // 新規追加: ミッション進行状況更新
          }

          // --- 乗客の乗車処理 (最適化) ---
          var availableCapacity =
            train.maxCapacity - train.currentPassengers.length;
          var passengersBoardedCount = 0;
          var passengersToBoard = [];
          var currentLineStationIds = line.stationIds;
          var nextStationId = null; // 列車が次に向かう駅のID

          // 現在停車している駅の路線のインデックスを取得
          var arrivedStationIndexInLine = currentLineStationIds.indexOf(
            arrivedStationId
          );

          if (arrivedStationIndexInLine !== -1) {
            if (train.direction === 1) {
              // 順方向で到着した場合、次に向かう駅は路線の次の駅
              if (arrivedStationIndexInLine + 1 < currentLineStationIds.length) {
                nextStationId =
                  currentLineStationIds[arrivedStationIndexInLine + 1];
              }
            } else {
              // train.direction === -1 (逆方向)
              // 逆方向で到着した場合、次に向かう駅は路線の前の駅
              if (arrivedStationIndexInLine - 1 >= 0) {
                nextStationId =
                  currentLineStationIds[arrivedStationIndexInLine - 1];
              }
            }
          }

          var tempPassengersWaiting = []; // 駅に残る乗客を一時的に保持する配列

          // 1. 次の停車駅を目的地とする乗客を優先的に乗せる
          for (var i = 0; i < station.passengersWaiting.length; i++) {
            var p = station.passengersWaiting[i];
            if (
              passengersBoardedCount < availableCapacity &&
              p.destinationStationId === nextStationId
            ) {
              passengersToBoard.push(p);
              passengersBoardedCount++;
            } else {
              tempPassengersWaiting.push(p);
            }
          }
          station.passengersWaiting = tempPassengersWaiting; // 処理済みの乗客を削除し、残りを更新

          tempPassengersWaiting = []; // リセット

          // 2. この路線の他の駅を目的地とする乗客を乗せる
          for (var i = 0; i < station.passengersWaiting.length; i++) {
            var p = station.passengersWaiting[i];
            if (
              passengersBoardedCount < availableCapacity &&
              currentLineStationIds.includes(p.destinationStationId)
            ) {
              passengersToBoard.push(p);
              passengersBoardedCount++;
            } else {
              tempPassengersWaiting.push(p);
            }
          }
          station.passengersWaiting = tempPassengersWaiting; // 処理済みの乗客を削除し、残りを更新

          // 3. 以前の「その他の駅を目的地とする乗客」を乗せるロジックを削除しました。
          //    これにより、列車は運行している路線上の駅を目的地とする乗客のみを乗せるようになります。

          Array.prototype.push.apply(train.currentPassengers, passengersToBoard);

          if (passengersBoardedCount > 0) {
            ui.showMessage(
              passengersBoardedCount +
                "人の乗客が" +
                station.name +
                "で乗車しました。",
              "info",
              false,
              2000
            );
          }

          train.stopTimer = setTimeout(function () {
            train.isStopped = false;
            train.currentStationId = null;
            moveToNextSegment();
            ui.renderTrainShop(); // 乗客数表示を更新するため
            setStationRevenueMultiplier(station); // 駅の待機乗客数も更新されるためポップアップを更新
          }, CONFIG.trainStopDuration / state.gameSpeedMultiplier); // 倍速適用
        } else {
          if (station) {
            // station変数名に変更
            ui.showMessage(
              train.name +
                "は" +
                station.name + // station変数名に変更
                "を通過します(プラットフォーム長不足または停車しない駅)。",
              "warning",
              false,
              3000
            );
          }
          moveToNextSegment();
        }
        ui.updateFinance(); // 収益更新
      }

      // --- PASSENGER GENERATION LOGIC: 乗客生成ロジック ---

      /**
       * 各駅で定期的に乗客を生成する。
       * 生成される乗客の数は、駅の人口密度と路線の供給状況に応じて変動する。
       */
      function generatePassengersAtStations() {
        var i, j;
        for (i = 0; i < state.stations.length; i++) {
          var station = state.stations[i];
          if (!station.revenueMultiplier) continue;

          // 人口密度に基づく基本乗客生成量
          var baseCount = Math.floor(
            CONFIG.basePassengerGeneration * station.revenueMultiplier
          );

          // この駅を通る路線の供給状況を考慮
          var totalLineCarsAtStation = 0;
          var linesServingStation = state.lines.filter(function (line) {
            return line.stationIds.includes(station.id);
          });

          for (j = 0; j < linesServingStation.length; j++) {
            totalLineCarsAtStation += linesServingStation[j].totalCarsOnLine;
          }

          // 供給量に応じた乗客生成ボーナス/ペナルティ
          // 輸送能力が過剰になると、供給係数の増加が鈍化、あるいは頭打ちになるように調整
          var supplyFactor = 1.0;
          if (totalLineCarsAtStation > 0) {
            var optimalTotalCars =
              linesServingStation.length * CONFIG.optimalCarsPerLineSegment;
            if (optimalTotalCars === 0)
              optimalTotalCars = CONFIG.optimalCarsPerLineSegment; // 路線がない場合のゼロ除算対策

            // ★修正4: supplyFactorの計算式を調整し、最大倍率を2.5から3.0に引き上げました
            supplyFactor =
              1 + Math.log(1 + totalLineCarsAtStation / optimalTotalCars) * 1.0; // 0.8を1.0に変更
            supplyFactor = Math.min(supplyFactor, 3.0); // 最大3.0倍に制限
          }

          var actualCount = Math.floor(baseCount * supplyFactor);

          // 駅の最大待機乗客数を超えないように生成量を制限
          var availableSlots =
            station.maxWaitingPassengers - station.passengersWaiting.length;
          actualCount = Math.min(actualCount, availableSlots);
          actualCount = Math.max(0, actualCount); // マイナスにならないように

          for (var k = 0; k < actualCount; k++) {
            var destinationStation = null;
            var possibleDestinationStations = [];

            // 修正箇所: 現在の駅が属する路線の中からランダムに1つ選び、その路線上の他の駅を目的地とする
            if (linesServingStation.length > 0) {
              var selectedLine =
                linesServingStation[
                  Math.floor(Math.random() * linesServingStation.length)
                ];
              for (var m = 0; m < selectedLine.stationIds.length; m++) {
                var destId = selectedLine.stationIds[m];
                if (destId !== station.id) {
                  // 自分自身は目的地にしない
                  possibleDestinationStations.push(destId);
                }
              }
            }

            if (possibleDestinationStations.length > 0) {
              // 接続可能な駅の中からランダムに選択
              var randomIndex = Math.floor(
                Math.random() * possibleDestinationStations.length
              );
              destinationStation = getStationById(
                possibleDestinationStations[randomIndex]
              );
            }
            // else: この駅がどの路線にも属していない、または単独の駅である場合、乗客は生成されない。
            // これにより、無駄な乗客が減り、降車率が上がる。

            if (destinationStation) {
              // destinationStation が null でない場合のみ乗客を追加
              station.passengersWaiting.push({
                id: generateUniqueId(),
                destinationStationId: destinationStation.id,
              });
            }
          }
          // 駅のポップアップを更新
          if (station.marker && station.marker.getPopup()) {
            setStationRevenueMultiplier(station); // これでポップアップも更新される
          }
        }
      }

      /**
       * 1日あたりの維持費を計算する。
       * @returns {number} 1日あたりの維持費。
       */
      function calculateDailyMaintenanceCost() {
        var cost = 0;
        cost +=
          state.totalTrackLengthBuilt * CONFIG.maintenanceCosts.perTrackMeterPerDay;
        cost += state.stations.length * CONFIG.maintenanceCosts.perStationPerDay;
        cost += state.trains.length * CONFIG.maintenanceCosts.perTrainPerDay;
        return cost;
      }

      /**
       * ゲーム内時間を更新する。
       */
      function updateGameTime() {
        var prevDay = Math.floor(state.gameTime / (24 * 60 * 60000)); // 1日=24時間=1440分=86400秒=86400000ミリ秒
        state.gameTime +=
          CONFIG.gameTimeInterval * state.gameSpeedMultiplier * CONFIG.gameTimeScale;
        var currentDay = Math.floor(state.gameTime / (24 * 60 * 60000));

        if (currentDay > prevDay && currentDay > state.lastMaintenanceDay) {
          // 日が変わり、かつ前回の徴収日より進んでいれば維持費を徴収
          var dailyCost = calculateDailyMaintenanceCost();
          state.assets -= dailyCost;
          state.lastMaintenanceDay = currentDay;
          ui.showMessage(
            "今日の維持費: $" + dailyCost.toLocaleString(),
            "warning",
            false,
            3000
          );
          ui.updateFinance(); // 資産表示を更新
        }

        ui.updateGameTimeDisplay();
      }

      // --- GAME LOOP ---
      var lastFrameTime = 0;
      var gameLoopAccumulator = 0; // 経過時間蓄積用
      var FIXED_UPDATE_INTERVAL_MS = CONFIG.updateInterval; // 固定の更新間隔 (ms)

      function gameLoop(currentTime) {
        if (!lastFrameTime) {
          lastFrameTime = currentTime;
        }
        var elapsed = currentTime - lastFrameTime; // 前のフレームからの経過時間
        lastFrameTime = currentTime;

        // 経過時間を蓄積し、固定更新間隔ごとにupdateTrainsを呼び出す
        // state.gameSpeedMultiplier は deltaTime の計算に影響を与える
        gameLoopAccumulator += elapsed * state.gameSpeedMultiplier;

        while (gameLoopAccumulator >= FIXED_UPDATE_INTERVAL_MS) {
          updateTrains(FIXED_UPDATE_INTERVAL_MS / 1000); // 秒単位に変換して渡す
          gameLoopAccumulator -= FIXED_UPDATE_INTERVAL_MS;
        }

        renderTrains(); // 毎フレーム描画

        requestAnimationFrame(gameLoop);
      }

      /**
       * ゲーム速度を設定し、タイマーを再設定する。
       * @param {number} multiplier - 速度倍率 (例: 1, 2, 4, 8)
       */
      function setGameSpeed(multiplier) {
        state.gameSpeedMultiplier = multiplier;

        // 既存のインターバルをクリア (trainUpdateIntervalIdはrequestAnimationFrameになるので削除)
        if (state.passengerGenerationIntervalId) {
          clearInterval(state.passengerGenerationIntervalId);
        }
        if (state.gameTimeIntervalId) {
          clearInterval(state.gameTimeIntervalId);
        }

        // 新しいインターバルを設定
        state.passengerGenerationIntervalId = setInterval(
          generatePassengersAtStations,
          CONFIG.passengerGenerationInterval / state.gameSpeedMultiplier
        );
        state.gameTimeIntervalId = setInterval(
          updateGameTime,
          CONFIG.gameTimeInterval / state.gameSpeedMultiplier
        );

        // UIのボタンのアクティブ状態を更新
        var speedButtons = document.querySelectorAll(
          "#game-speed-control .speed-btn"
        );
        for (var i = 0; i < speedButtons.length; i++) {
          if (parseInt(speedButtons[i].dataset.speed) === multiplier) {
            speedButtons[i].classList.add("active");
          } else {
            speedButtons[i].classList.remove("active");
          }
        }
        ui.showMessage("ゲーム速度を " + multiplier + "倍に設定しました。", "info", false, 1500);
      }

      // --- RENDER TRAINS: マップ上での列車の描画とアニメーション ---
      /** 全列車の位置と状態を更新する。 */
      function renderTrains() {
        var i, j;
        for (i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];

          if (!train.currentLineId || !train.currentLatLng) {
            // 列車が路線に割り当てられていない、または位置情報がない場合は、既存のマーカーを削除
            if (train.carMarkers) {
              for (j = 0; j < train.carMarkers.length; j++) {
                if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                  map.removeLayer(train.carMarkers[j]);
                }
              }
            }
            train.carMarkers = []; // クリア
            continue;
          }

          var line = getLineById(train.currentLineId);
          if (!line) continue;

          var carLengthMeters = CONFIG.trainCarDimensionsMeters.length;
          var currentSegment = line.segments[train.currentSegmentIndex];
          var headDistanceInSegment = currentSegment.distance * train.progress;

          // carMarkers配列のサイズ調整
          // 既存のマーカー数が車両数と異なる場合は、すべて削除して再作成
          if (!train.carMarkers || train.carMarkers.length !== train.cars) {
            if (train.carMarkers) {
              for (j = 0; j < train.carMarkers.length; j++) {
                if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                  map.removeLayer(train.carMarkers[j]);
                }
              }
            }
            train.carMarkers = []; // クリア
            // 新しいマーカー配列を初期化
            for (j = 0; j < train.cars; j++) {
              // 仮のLatlngで初期化
              train.carMarkers.push(
                L.rotatedMarker(train.currentLatLng || L.latLng(0, 0), {
                  icon: L.divIcon({
                    className: "train-car-container",
                    html: '<div class="train-car-body" style="background-color:' + train.color + ';"></div>',
                    iconSize: [1, 1], // 初期サイズは小さく
                    iconAnchor: [0, 0],
                  }),
                  rotation: 0,
                }).addTo(map)
              );
            }
          }

          for (j = 0; j < train.cars; j++) {
            // 各車両の中心が先頭からどれだけ離れているか
            var carCenterDistance =
              headDistanceInSegment - j * carLengthMeters - carLengthMeters / 2;

            var pointData;
            // 現在のセグメント内で車両の位置を計算
            if (
              carCenterDistance >= 0 &&
              carCenterDistance <= currentSegment.distance
            ) {
              pointData = getPointAtDistance(
                currentSegment.latlngs,
                carCenterDistance
              );
            } else {
              // セグメント外の車両は、先頭車両の方向へ延長線上に配置 (簡易的な処理)
              // ここで getPointAtDistance が null を返す可能性があるのでチェック
              pointData = getPointAtDistance(
                currentSegment.latlngs,
                Math.max(
                  0,
                  Math.min(currentSegment.distance, carCenterDistance)
                )
              );
            }

            if (!pointData) {
              // pointDataが取得できない場合は、その車両をマップから削除
              if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                  map.removeLayer(train.carMarkers[j]);
              }
              continue;
            }

            var carLatLng = pointData.latlng;
            var carHeading = pointData.heading;
            if (train.direction === -1) {
              carHeading = (carHeading + 180) % 360;
            }

            var carLengthPx = metersToPixels(
              CONFIG.trainCarDimensionsMeters.length,
              carLatLng
            );
            var carWidthPx = metersToPixels(
              CONFIG.trainCarDimensionsMeters.width,
              carLatLng
            );
            // LeafletのiconSizeは、アイコン全体のサイズであり、車両のボディサイズではない。
            // iconAnchorを中央にするため、maxDimを計算して設定。
            var maxDim = Math.max(carLengthPx, carWidthPx);
            var iconSize = [maxDim, maxDim]; // アイコン全体のサイズ

            var rotation = carHeading - 90;

            var carMarker = train.carMarkers[j];
            if (carMarker) {
              carMarker.setLatLng(carLatLng);
              carMarker.setRotation(rotation);

              var iconElement = carMarker.getElement();
              if (iconElement) {
                var bodyElement = iconElement.querySelector(".train-car-body");
                if (bodyElement) {
                  bodyElement.style.width = carLengthPx + "px";
                  bodyElement.style.height = carWidthPx + "px";
                  // 先頭車両のクラスを更新
                  if (j === 0) {
                      bodyElement.classList.add("front-car");
                  } else {
                      bodyElement.classList.remove("front-car");
                  }
                }
                // L.divIconのiconSizeは直接変更できないため、新しいアイコンをセットし直す
                // ただし、これはコストが高い。今回はmaxDimが変動するため、iconSizeの更新は必要。
                // iconAnchorも再計算して設定
                carMarker.setIcon(
                  L.divIcon({
                    className: "train-car-container",
                    html:
                      '<div class="train-car-body ' + (j === 0 ? 'front-car' : '') + '" style="background-color:' +
                      train.color +
                      '; width:' +
                      carLengthPx +
                      "px; height:" +
                      carWidthPx +
                      'px;"></div>',
                    iconSize: iconSize,
                    iconAnchor: [maxDim / 2, maxDim / 2],
                  })
                );
              }

              // 先頭車両にのみポップアップを設定/更新
              if (j === 0) {
                var popupContent =
                  "<b>" +
                  train.name +
                  "</b><br>" +
                  "路線: " +
                  line.name +
                  "<br>" +
                  "速度: " +
                  train.speed +
                  "km/h<br>" +
                  "乗客: " +
                  train.currentPassengers.length +
                  "/" +
                  train.maxCapacity +
                  "人" +
                  (train.isStopped ? "<br><b>停車中</b>" : ""); // 新規追加: 停車中表示
                if (!carMarker.getPopup()) {
                  carMarker.bindPopup(popupContent);
                } else {
                  carMarker.getPopup().setContent(popupContent);
                }
              }
            }
          }
        }
      }

      // --- SAVE / LOAD GAME (共有機能対応のため、関数を分割・共通化) ---

      function serializeLatLng(latlng) {
        return latlng ? { lat: latlng.lat, lng: latlng.lng } : null;
      }
      function deserializeLatLng(obj) {
        return obj ? L.latLng(obj.lat, obj.lng) : null;
      }
      function serializeLatLngs(arr) {
        return (arr || []).map(serializeLatLng);
      }
      function deserializeLatLngs(arr) {
        return (arr || []).map(deserializeLatLng);
      }

      /**
       * 現在のゲーム状態から保存可能なオブジェクトを生成する。
       * Leafletレイヤーオブジェクトなどは除外し、再構築に必要なデータのみを抽出。
       * @returns {object} 保存可能なゲーム状態オブジェクト。
       */
      function getSavableState() {
        return {
          assets: state.assets,
          tracks: state.tracks.map(function (t) {
            return {
              id: t.id,
              latlngs: serializeLatLngs(t.latlngs),
              type: t.type,
            };
          }),
          stations: state.stations.map(function (s) {
            return {
              id: s.id,
              name: s.name,
              latlng: serializeLatLng(s.latlng),
              latlngs: serializeLatLngs(s.latlngs),
              platformLength: s.platformLength,
              revenueMultiplier: s.revenueMultiplier,
              passengersWaiting: s.passengersWaiting,
              maxWaitingPassengers: s.maxWaitingPassengers,
            };
          }),
          lines: state.lines.map(function (l) {
            return {
              id: l.id,
              name: l.name,
              stationIds: l.stationIds,
              color: l.color,
              totalDistance: l.totalDistance,
              assignedTrainIds: l.assignedTrainIds,
              segments: l.segments.map(function (seg) {
                return {
                  startStationId: seg.startStationId,
                  endStationId: seg.endStationId,
                  latlngs: serializeLatLngs(seg.latlngs),
                  distance: seg.distance,
                };
              }),
              totalTrainsOnLine: l.totalTrainsOnLine,
              totalCarsOnLine: l.totalCarsOnLine,
            };
          }),
          trains: state.trains.map(function (t) {
            return {
              id: t.id,
              type: t.type,
              name: t.name,
              cars: t.cars,
              cost: t.cost,
              color: t.color,
              speed: t.speed,
              totalLength: t.totalLength,
              currentStationId: t.currentStationId,
              currentLineId: t.currentLineId,
              currentSegmentIndex: t.currentSegmentIndex,
              direction: t.direction,
              progress: t.progress,
              isStopped: t.isStopped,
              currentPassengers: t.currentPassengers,
              maxCapacity: t.maxCapacity,
            };
          }),
          currentLineColorIndex: state.currentLineColorIndex,
          gameSpeedMultiplier: state.gameSpeedMultiplier,
          gameTime: state.gameTime, // ゲーム時間を保存

          // 新規追加: ミッション関連の保存
          missions: state.missions,
          totalTrackLengthBuilt: state.totalTrackLengthBuilt,
          totalStationsBuilt: state.totalStationsBuilt,
          totalLinesBuilt: state.totalLinesBuilt,
          totalTrainsBought: state.totalTrainsBought,
          totalPassengersTransported: state.totalPassengersTransported,
          lastMaintenanceDay: state.lastMaintenanceDay,
        };
      }

      /** マップ上の全てのLeafletレイヤーをクリアする */
      function clearMapLayers() {
        map.eachLayer(function (layer) {
          // ベースのタイルレイヤーと人口密度レイヤーは残す
          if (
            layer instanceof L.TileLayer ||
            (populationDensityLayer && layer === populationDensityLayer)
          ) {
            // Keep the base tile layer and population density layer
          } else {
            map.removeLayer(layer);
          }
        });
        // train.carMarkersも明示的にクリア
        for (var i = 0; i < state.trains.length; i++) {
          var train = state.trains[i];
          if (train.carMarkers) {
            for (var j = 0; j < train.carMarkers.length; j++) {
              if (train.carMarkers[j] && map.hasLayer(train.carMarkers[j])) {
                map.removeLayer(train.carMarkers[j]);
              }
            }
          }
          train.carMarkers = []; // クリア
        }
      }

      // --- 暗号化/復号化のヘルパー関数 ---
      // 注意: このXOR暗号化は非常に簡易的なものであり、セキュリティレベルは高くありません。
      // 鍵がコード内にハードコードされているため、本格的なセキュリティが必要な場合は、
      // より強力な暗号化ライブラリの導入と、鍵管理の仕組みが必要です。
      var encryptionKey = "RailBuilderSecretKey2023"; // 適当な鍵

      function xorEncryptDecrypt(data, key) {
        var output = "";
        for (var i = 0; i < data.length; i++) {
          var charCode = data.charCodeAt(i) ^ key.charCodeAt(i % key.length);
          output += String.fromCharCode(charCode);
        }
        return output;
      }

      /**
       * ロードされたデータオブジェクトからゲーム状態を復元する。
       * @param {object} loadedState - ロードするゲーム状態オブジェクト。
       * @returns {boolean} ロードが成功したかどうか。
       */
      function loadGameFromObject(loadedState) {
        if (!loadedState) {
          ui.showMessage("無効なゲームデータです。", "error", false, 3000);
          return false;
        }

        clearMapLayers();

        // Reset state
        state = {
          assets: loadedState.assets,
          tracks: [],
          stations: [],
          lines: [],
          trains: [],
          planning: { type: null, points: [], ghost: null, costTooltip: null },
          lineBuildingMode: false,
          selectedStationsForLine: [],
          currentLineGhost: null,
          selectedTrainToBuyId: null,
          currentLineColorIndex: loadedState.currentLineColorIndex || 0,
          selectedTrainToAssignId: null,
          demolitionMode: false,
          selectedForDemolition: null,
          gameSpeedMultiplier: loadedState.gameSpeedMultiplier || 1,
          passengerGenerationIntervalId: null,
          gameTime: loadedState.gameTime || 0, // ゲーム時間をロード
          gameTimeIntervalId: null,

          // 新規追加: ミッション関連のロード
          missions: loadedState.missions || [],
          totalTrackLengthBuilt: loadedState.totalTrackLengthBuilt || 0,
          totalStationsBuilt: loadedState.totalStationsBuilt || 0,
          totalLinesBuilt: loadedState.totalLinesBuilt || 0,
          totalTrainsBought: loadedState.totalTrainsBought || 0,
          totalPassengersTransported: loadedState.totalPassengersTransported || 0,
          lastMaintenanceDay: loadedState.lastMaintenanceDay || 0,
        };

        var i;

        // Rebuild tracks
        for (i = 0; i < loadedState.tracks.length; i++) {
          var tData = loadedState.tracks[i];
          var latlngs = deserializeLatLngs(tData.latlngs);

          var railLayer = L.polyline(latlngs, {
            className: "track-rail track-" + tData.type + "-rail",
            id: tData.id,
          }).addTo(map);
          var sleeperLayer = L.polyline(latlngs, {
            className: "track-sleeper track-" + tData.type + "-sleeper",
            id: tData.id,
          }).addTo(map);

          state.tracks.push({
            id: tData.id,
            latlngs: latlngs,
            railLayer: railLayer,
            sleeperLayer: sleeperLayer,
            type: tData.type,
          });

          railLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", this.options.id);
            }
          });
          sleeperLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            if (state.demolitionMode) {
              selectForDemolition("track", e.target.options.id);
            }
          });
        }

        // Rebuild stations
        for (i = 0; i < loadedState.stations.length; i++) {
          var sData = loadedState.stations[i];
          var latlng = deserializeLatLng(sData.latlng);
          var latlngs = deserializeLatLngs(sData.latlngs);

          var platformBodyLayer = L.polyline(latlngs, {
            className: "station-platform-body",
            id: sData.id,
          }).addTo(map);
          var platformEdgeLayer = L.polyline(latlngs, {
            className: "station-platform-edge",
            id: sData.id,
          }).addTo(map);

          var marker = L.marker(latlng, {
            icon: L.divIcon({
              className: "station-marker",
              iconSize: [16, 16],
              html: "",
            }),
            id: sData.id,
          }).addTo(map);
          var newStation = {
            id: sData.id,
            name: sData.name,
            latlng: latlng,
            latlngs: latlngs,
            platformLength: sData.platformLength,
            bodyLayer: platformBodyLayer,
            edgeLayer: platformEdgeLayer,
            marker: marker,
            revenueMultiplier: sData.revenueMultiplier || 1.0,
            passengersWaiting: sData.passengersWaiting || [],
            maxWaitingPassengers:
              sData.maxWaitingPassengers ||
              Math.floor(
                sData.platformLength *
                  CONFIG.maxWaitingPassengersPerMeterOfPlatform
              ),
          };
          state.stations.push(newStation);

          // 駅名ツールチップをバインド
          marker.bindTooltip(newStation.name, {
            permanent: true,
            direction: "top",
            className: "station-name-tooltip",
          });
          marker.getTooltip()._container.style.display =
            map.getZoom() >= 13 ? "block" : "none";

          marker.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var id = e.target.options.id;
            if (state.lineBuildingMode) {
              handleStationClickForLineBuilding(id);
            } else if (state.demolitionMode) {
              selectForDemolition("station", id);
            } else {
              // 修正4: 通常クリック時にポップアップを開く
              e.target.openPopup();
            }
          });
          platformBodyLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var id = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", id);
            }
          });
          platformEdgeLayer.on("click", function (e) {
            e.originalEvent.stopPropagation();
            var id = e.target.options.id;
            if (state.demolitionMode) {
              selectForDemolition("station", id);
            }
          });
          setStationRevenueMultiplier(newStation); // ロード時にも人口密度を適用
        }

        // Rebuild lines
        for (i = 0; i < loadedState.lines.length; i++) {
          var lData = loadedState.lines[i];
          var linePathLatLngs = [];
          if (lData.segments && lData.segments.length > 0) {
            linePathLatLngs = deserializeLatLngs(lData.segments[0].latlngs);
            for (var j = 1; j < lData.segments.length; j++) {
              var segLatLngs = deserializeLatLngs(lData.segments[j].latlngs);
              Array.prototype.push.apply(
                linePathLatLngs,
                segLatLngs.slice(1)
              );
            }
          }
          var lineLayer = L.polyline(linePathLatLngs, {
            className: "line-color",
            color: lData.color,
            weight: 5,
            opacity: 0.8,
            id: lData.id,
          }).addTo(map);
          state.lines.push({
            id: lData.id,
            name: lData.name,
            stationIds: lData.stationIds,
            color: lData.color,
            layer: lineLayer,
            totalDistance: lData.totalDistance,
            assignedTrainIds: lData.assignedTrainIds,
            segments: lData.segments.map(function (seg) {
              return {
                startStationId: seg.startStationId,
                endStationId: seg.endStationId,
                latlngs: deserializeLatLngs(seg.latlngs),
                distance: seg.distance,
              };
            }),
            totalTrainsOnLine: lData.totalTrainsOnLine || 0,
            totalCarsOnLine: lData.totalCarsOnLine || 0,
          });
        }

        // Rebuild trains
        for (i = 0; i < loadedState.trains.length; i++) {
          var trainData = loadedState.trains[i];
          var newTrain = Object.assign({}, trainData);
          newTrain.stopTimer = null;
          newTrain.carMarkers = []; // ロード時には空にして、renderTrainsで再作成させる
          newTrain.currentLatLng = null; // will be calculated on next update
          newTrain.currentHeading = 0;
          state.trains.push(newTrain);
        }

        ui.updateFinance();
        ui.updateGameTimeDisplay(); // ゲーム時間も更新
        ui.renderTrainShop();
        ui.renderMissions(); // 新規追加: ミッションリストも更新
        renderTrains(); // ロード直後に列車を描画
        setGameSpeed(state.gameSpeedMultiplier); // ロード後にゲーム速度を再設定
        return true;
      }

      /** ゲームの状態をローカルストレージに保存する。 */
      function saveGame() {
        var savableState = getSavableState();
        try {
          var jsonString = JSON.stringify(savableState);
          var encrypted = xorEncryptDecrypt(jsonString, encryptionKey); // 暗号化
          var compressedAndEncrypted = LZString.compressToBase64(encrypted); // 圧縮

          localStorage.setItem("railBuilderSaveGame", compressedAndEncrypted);
          ui.showMessage("ゲームをセーブしました！ (ローカル)", "success", false, 2000);
        } catch (e) {
          console.error("ゲームのセーブに失敗しました:", e);
          ui.showMessage("ゲームのセーブに失敗しました。", "error", false, 3000);
        }
      }

      /** ローカルストレージからゲームの状態をロードする。 */
      function loadGame() {
        ui.showLoadingOverlay("ゲームデータをロード中...");
        var savedData = localStorage.getItem("railBuilderSaveGame");
        if (!savedData) {
          ui.showMessage("保存されたゲームデータがありません。", "warning", false, 3000);
          ui.hideLoadingOverlay();
          return;
        }
        try {
          var decompressed = LZString.decompressFromBase64(savedData); // 解凍
          if (!decompressed) {
            throw new Error("LZ-String decompression failed.");
          }
          var decrypted = xorEncryptDecrypt(decompressed, encryptionKey); // 復号化
          var loadedState = JSON.parse(decrypted);

          if (loadGameFromObject(loadedState)) {
            ui.showMessage(
              "セーブデータを入力し、ゲームをロードしました！",
              "success",
              false,
              2000
            );
            ui.saveDataTextarea.value = ""; // ロード後クリア
          }
        } catch (e) {
          console.error("ゲームのロードに失敗しました:", e);
          ui.showMessage(
            "ゲームのロードに失敗しました。データが破損している可能性があります。",
            "error",
            false,
            5000
          );
        } finally {
          ui.hideLoadingOverlay();
        }
      }

      /** 現在のゲーム状態をJSONテキストとしてテキストエリアに出力する。 */
      function exportSaveData() {
        try {
          var savableState = getSavableState();
          var jsonString = JSON.stringify(savableState);
          var encrypted = xorEncryptDecrypt(jsonString, encryptionKey); // 暗号化
          var compressedAndEncrypted = LZString.compressToBase64(encrypted); // 圧縮

          ui.saveDataTextarea.value = compressedAndEncrypted;
          ui.showMessage(
            "セーブデータを出力しました。テキストエリアからコピーしてください。",
            "info",
            false,
            3000
          );
        } catch (e) {
          console.error("セーブデータのエクスポートに失敗しました:", e);
          ui.showMessage("セーブデータのエクスポートに失敗しました。", "error", false, 3000);
        }
      }

      /** テキストエリアのJSONテキストからゲーム状態をインポートする。 */
      function importSaveData() {
        ui.showLoadingOverlay("セーブデータをインポート中...");
        var compressedAndEncrypted = ui.saveDataTextarea.value;
        if (!compressedAndEncrypted) {
          ui.showMessage(
            "テキストエリアにセーブデータを貼り付けてください。",
            "warning",
            false,
            3000
          );
          ui.hideLoadingOverlay();
          return;
        }
        try {
          var decompressed = LZString.decompressFromBase64(
            compressedAndEncrypted
          ); // 解凍
          if (!decompressed) {
            throw new Error("LZ-String decompression failed.");
          }
          var decrypted = xorEncryptDecrypt(decompressed, encryptionKey); // 復号化
          var loadedState = JSON.parse(decrypted);

          if (loadGameFromObject(loadedState)) {
            ui.showMessage(
              "セーブデータを入力し、ゲームをロードしました！",
              "success",
              false,
              2000
            );
            ui.saveDataTextarea.value = ""; // ロード後クリア
          }
        } catch (e) {
          console.error("セーブデータのインポートに失敗しました:", e);
          ui.showMessage(
            "無効なセーブデータです。形式を確認してください。",
            "error",
            false,
            5000
          );
        } finally {
          ui.hideLoadingOverlay();
        }
      }

      // ===================================================================
      // 人口密度TIFF関連の機能追加
      // ===================================================================

      // グローバル変数としてGeoTIFFオブジェクトとラスタデータを保持
      var populationDensityData = null; // 1次元配列で人口密度を保持
      var populationDensityGeoTransform = null; // [minX, minY, maxX, maxY]
      var populationDensityWidth = 0;
      var populationDensityHeight = 0;
      var populationDensityLayer = null; // Leafletの人口密度レイヤー

      var POPULATION_DENSITY_TIFF_PATH = "./zinkou.tif";

      // GeoTIFFを読み込み、ラスタデータをキャッシュ
      async function loadPopulationDensityTiff() {
        ui.showLoadingOverlay("人口密度データを読み込み中...");
        try {
          const tiff = await GeoTIFF.fromUrl(POPULATION_DENSITY_TIFF_PATH);
          const image = await tiff.getImage();

          let bbox = image.getBoundingBox();
          if (!Array.isArray(bbox)) {
            bbox = [bbox.left, bbox.bottom, bbox.right, bbox.top];
          }
          populationDensityGeoTransform = bbox;
          populationDensityWidth = image.getWidth();
          populationDensityHeight = image.getHeight();

          // 全ピクセルを読み込んで1次元配列に保持 (RangeError対策)
          const raster = await image.readRasters();
          populationDensityData = raster[0]; // raster[0] はすでに型付き配列

          console.log("TIFF Width:", populationDensityWidth);
          console.log("TIFF Height:", populationDensityHeight);
          console.log(
            "Raster data length:",
            populationDensityData ? populationDensityData.length : "null"
          ); // ここで長さを確認

          ui.showMessage(
            "人口密度データの読み込みが完了しました。",
            "success",
            false,
            3000
          );
          console.log(
            "Population Density TIFF loaded:",
            populationDensityGeoTransform,
            "Width:",
            populationDensityWidth,
            "Height:",
            populationDensityHeight
          );

          // 駅の収益倍率を更新
          for (let i = 0; i < state.stations.length; i++) {
            setStationRevenueMultiplier(state.stations[i]);
          }

          // 人口密度レイヤーを初期表示
          // addPopulationDensityLayer(); // 初期表示はオフにする
        } catch (error) {
          console.error("人口密度TIFFの読み込みに失敗しました:", error);
          ui.showMessage(
            "人口密度データの読み込みに失敗しました。ファイルパスを確認してください。",
            "error",
            false,
            7000
          );
        } finally {
          ui.hideLoadingOverlay();
        }
      }

      // 緯度経度 → ラスタ座標
      function latLngToPixel(latlng) {
        const [minX, minY, maxX, maxY] = populationDensityGeoTransform;
        // 経度方向の範囲が0の場合の対策
        const lngRange = maxX - minX;
        const latRange = maxY - minY;

        let x = 0;
        if (lngRange !== 0) {
          x = ((latlng.lng - minX) / lngRange) * populationDensityWidth;
        }
        let y = 0;
        if (latRange !== 0) {
          y = ((maxY - latlng.lat) / latRange) * populationDensityHeight;
        }

        return [Math.floor(x), Math.floor(y)];
      }

      // 人口密度を取得（キャッシュ配列から同期で取得）
      function getPopulationDensity(latlng) {
        if (
          !populationDensityData ||
          populationDensityWidth === 0 ||
          populationDensityHeight === 0 ||
          !populationDensityGeoTransform
        )
          return 0;

        // 緯度経度がGeoTIFFの範囲外の場合のチェック
        const [minX, minY, maxX, maxY] = populationDensityGeoTransform;
        if (
          latlng.lng < minX ||
          latlng.lng > maxX ||
          latlng.lat < minY ||
          latlng.lat > maxY
        ) {
          return 0; // 範囲外
        }

        const [x, y] = latLngToPixel(latlng);

        // 範囲チェックを強化
        if (
          x < 0 ||
          x >= populationDensityWidth ||
          y < 0 ||
          y >= populationDensityHeight
        ) {
          // console.warn("Pixel coordinates out of bounds:", x, y, "for LatLng:", latlng.lat, latlng.lng);
          return 0;
        }

        // 計算されるインデックスが配列の範囲内にあるか最終チェック
        const index = y * populationDensityWidth + x;
        if (index < 0 || index >= populationDensityData.length) {
          // console.error("Calculated index out of bounds:", index, "Array length:", populationDensityData.length, "for LatLng:", latlng.lat, latlng.lng);
          return 0;
        }

        return populationDensityData[index];
      }

      // 駅の収益倍率を設定
      function setStationRevenueMultiplier(station) {
        const density = getPopulationDensity(station.latlng);
        let multiplier = 1.0;

        if (density > 10000) multiplier = 2.5;
        else if (density > 5000) multiplier = 2.0;
        else if (density > 1000) multiplier = 1.5;
        else if (density > 500) multiplier = 1.0;
        else multiplier = 0.5;

        station.revenueMultiplier = multiplier;

        // 新規追加: 駅のポップアップに待機乗客数と最大待機乗客数、人口密度を表示
        if (station.marker && station.marker.getPopup()) {
          station.marker
            .getPopup()
            .setContent(
              `<b>${station.name}</b><br>` +
                `プラットフォーム長: ${station.platformLength.toFixed(
                  1
                )}m<br>` +
                `人口密度: ${Math.round(density).toLocaleString()}人/km²<br>` +
                `収益倍率: ${station.revenueMultiplier.toFixed(2)}<br>` +
                `待機乗客: ${station.passengersWaiting.length}人<br>` +
                `最大待機乗客: ${station.maxWaitingPassengers}人`
            );
        }
      }

      // 人口密度カラー取得
      function getDensityColor(density) {
        if (density <= 0) return "rgba(0,0,0,0)";
        let r, g, b, a;
        if (density < 50) {
          const ratio = density / 50;
          r = 100 * ratio;
          g = 150 * ratio;
          b = 255;
          a = 0.1 + 0.3 * ratio;
        } else if (density < 500) {
          const ratio = (density - 50) / 450;
          r = 100 + 155 * ratio;
          g = 150 * (1 - ratio);
          b = 255 * (1 - ratio);
          a = 0.4 + 0.2 * ratio;
        } else if (density < 2000) {
          const ratio = (density - 500) / 1500;
          r = 255;
          g = Math.floor(100 * (1 - ratio)); // 修正: gを減らす
          b = Math.floor(100 * (1 - ratio)); // 修正: bを減らす
          a = 0.6 + 0.2 * ratio;
        } else {
          const ratio = Math.min(1, (density - 2000) / 8000);
          r = 255;
          g = Math.floor(100 * (1 - ratio));
          b = 100 + 155 * ratio;
          a = 0.8 + 0.1 * ratio;
        }
        return `rgba(${Math.floor(r)},${Math.floor(b)},${Math.floor(g)},${a})`; /* RGB順序を調整 */
      }

      // Leaflet人口密度レイヤー
      L.GridLayer.PopulationDensity = L.GridLayer.extend({
        options: { tileSize: 256, opacity: 0.6, samplingResolution: 24 },
        createTile: function (coords) {
          const tile = L.DomUtil.create("canvas", "leaflet-tile");
          tile.width = tile.height = this.options.tileSize;
          const ctx = tile.getContext("2d");
          if (!populationDensityData) return tile;

          const step = this.options.tileSize / this.options.samplingResolution; // より細かいグリッドで描画
          for (let x = 0; x < this.options.tileSize; x += step) {
            for (let y = 0; y < this.options.tileSize; y += step) {
              const mapPixelX = coords.x * this.options.tileSize + x;
              const mapPixelY = coords.y * this.options.tileSize + y;
              const latlng = map.unproject([mapPixelX, mapPixelY], coords.z);
              const density = getPopulationDensity(latlng);
              if (density > 0) {
                ctx.fillStyle = getDensityColor(density);
                ctx.fillRect(x, y, step, step);
              }
            }
          }
          return tile;
        },
      });

      L.gridLayer.populationDensity = function (options) {
        return new L.GridLayer.PopulationDensity(options);
      };

      function addPopulationDensityLayer() {
        if (populationDensityLayer) map.removeLayer(populationDensityLayer);
        populationDensityLayer = L.gridLayer
          .populationDensity({ opacity: 0.6 })
          .addTo(map);
        populationDensityLayer.setZIndex(1);
      }

      // ===================================================================
      // ミッションシステム機能
      // ===================================================================

      /**
       * ゲーム開始時に初期ミッションをアクティブにする。
       */
      function initializeMissions() {
        for (var i = 0; i < CONFIG.missions.length; i++) {
          var missionConfig = CONFIG.missions[i];
          if (!missionConfig.unlockedBy) {
            // 前提条件がないミッションをアクティブにする
            state.missions.push({
              id: missionConfig.id,
              title: missionConfig.title,
              description: missionConfig.description,
              type: missionConfig.type,
              target: missionConfig.target,
              currentProgress: 0,
              reward: missionConfig.reward,
              isCompleted: false,
              isActive: true,
              unlockedBy: null,
            });
          } else {
            // ロックされたミッションとして追加
            state.missions.push({
              id: missionConfig.id,
              title: missionConfig.title,
              description: missionConfig.description,
              type: missionConfig.type,
              target: missionConfig.target,
              currentProgress: 0,
              reward: missionConfig.reward,
              isCompleted: false,
              isActive: false,
              unlockedBy: missionConfig.unlockedBy,
            });
          }
        }
        ui.renderMissions();
      }

      /**
       * ミッションの進行状況をチェックし、更新する。
       * @param {string} missionType - チェックするミッションのタイプ。
       */
      function checkMissionProgress(missionType) {
        var progressValue = 0;
        switch (missionType) {
          case "build_track_length":
            progressValue = state.totalTrackLengthBuilt;
            break;
          case "build_station_count":
            progressValue = state.totalStationsBuilt;
            break;
          case "build_line_count":
            progressValue = state.totalLinesBuilt;
            break;
          case "buy_train_count":
            progressValue = state.totalTrainsBought;
            break;
          case "transport_passengers":
            progressValue = state.totalPassengersTransported;
            break;
          case "reach_assets":
            progressValue = state.assets;
            break;
          default:
            return;
        }

        for (var i = 0; i < state.missions.length; i++) {
          var mission = state.missions[i];
          if (
            mission.type === missionType &&
            mission.isActive &&
            !mission.isCompleted
          ) {
            mission.currentProgress = progressValue;
            if (mission.currentProgress >= mission.target) {
              mission.isCompleted = true;
              state.assets += mission.reward;
              ui.showMessage(
                "ミッション完了: " +
                  mission.title +
                  "！ 報酬: $" +
                  mission.reward.toLocaleString(),
                "success",
                false,
                5000
              );
              ui.updateFinance();
              unlockNextMissions(mission.id); // 次のミッションをアンロック
            }
          }
        }
        ui.renderMissions(); // UIを更新
      }

      /**
       * 完了したミッションに基づいて次のミッションをアンロックする。
       * @param {string} completedMissionId - 完了したミッションのID。
       */
      function unlockNextMissions(completedMissionId) {
        for (var i = 0; i < state.missions.length; i++) {
          var mission = state.missions[i];
          if (mission.unlockedBy === completedMissionId && !mission.isActive) {
            mission.isActive = true;
            ui.showMessage(
              "新しいミッションがアンロックされました: " + mission.title,
              "info",
              false,
              4000
            );
          }
        }
        ui.renderMissions();
      }

      // ===================================================================
      // チュートリアル機能
      // ===================================================================
      var tutorialSteps = [
        {
          title: "Rail Builder Proへようこそ！",
          icon: "fas fa-train",
          text: "このゲームでは、線路や駅を建設し、列車を運行して都市を発展させます。まずは基本的な操作を学びましょう。",
        },
        {
          title: "1. 線路の建設",
          icon: "fas fa-road",
          text: "左側の「建設メニュー」から「地上線」「高架線」「トンネル」を選び、マップ上でドラッグして線路を建設します。線路は自動的に滑らかなカーブになります。建設コストに注意しましょう。",
        },
        {
          title: "2. 駅の建設",
          icon: "fas fa-train-station",
          text: "「建設メニュー」から「駅」を選び、マップ上でドラッグして駅のプラットフォームを建設します。駅は乗客の乗り降りや収益の拠点となります。",
        },
        {
          title: "3. 列車ショップ",
          icon: "fas fa-cart-shopping",
          text: "「列車ショップ」では、様々な種類の列車を購入できます。資金と相談して、最適な列車を選びましょう。",
        },
        {
          title: "4. 路線設定",
          icon: "fas fa-route",
          text: "「路線設定」モードで駅を順番にクリックし、路線を作成します。作成した路線に列車を割り当てることで運行が開始されます。",
        },
        {
          title: "5. 解体モード",
          icon: "fas fa-hammer",
          text: "「解体モード」では、建設済みの線路や駅を撤去できます。不要な施設を整理し、都市計画を見直しましょう。",
        },
        {
          title: "6. ミッション",
          icon: "fas fa-scroll",
          text: "左側の「ミッション」パネルで、達成すべき目標を確認できます。ミッションをクリアすると報酬が得られます。ゲームの進行に合わせて新しいミッションがアンロックされます。",
        },
        {
          title: "7. 人口密度表示",
          icon: "fas fa-layer-group",
          text: "左側の「マップ表示」にある「人口密度表示」ボタンで、マップ上の人口密度を可視化できます。人口密度の高い地域は、より多くの乗客と収益をもたらします。",
        },
        {
          title: "8. 資金、時間、維持費",
          icon: "fas fa-dollar-sign",
          text: "右上の「資産」はあなたの資金です。ゲーム内時間で1日ごとに、線路、駅、列車の「維持費」が自動的に徴収されます。収益と維持費のバランスを考えて経営しましょう。",
        },
        {
          title: "ゲーム開始！",
          icon: "fas fa-play",
          text: "これで基本的な操作はマスターしました。さあ、あなただけの鉄道王国を築き上げましょう！",
        },
      ];
      var currentTutorialStep = 0;

      function showTutorial() {
        document.getElementById("tutorial-overlay").classList.add("show");
        showTutorialStep(0);
        // チュートリアル中はマップ操作を無効化
        map.dragging.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
        if (map.touchZoom) map.touchZoom.disable();
        if (map.zoomControl) map.zoomControl.disable();
      }

      function hideTutorial() {
        document.getElementById("tutorial-overlay").classList.remove("show");
        localStorage.setItem("hasSeenTutorial", "true");
        // チュートリアル終了後、マップ操作を有効化
        map.dragging.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
        if (map.tap) map.tap.enable();
        if (map.touchZoom) map.tap.enable(); // tapを有効化
        if (map.zoomControl) map.zoomControl.enable();
      }

      function showTutorialStep(stepIndex) {
        if (stepIndex < 0 || stepIndex >= tutorialSteps.length) return;

        currentTutorialStep = stepIndex;
        var step = tutorialSteps[currentTutorialStep];

        document.getElementById("tutorial-title").textContent = step.title;
        document.getElementById("tutorial-icon").className =
          step.icon + " tutorial-icon";
        document.getElementById("tutorial-text").textContent = step.text;

        document.getElementById("tutorial-prev-btn").disabled =
          currentTutorialStep === 0;
        document.getElementById("tutorial-next-btn").textContent =
          currentTutorialStep === tutorialSteps.length - 1
            ? "完了"
            : "次へ";
        document.getElementById("tutorial-next-btn").querySelector("i").className =
          currentTutorialStep === tutorialSteps.length - 1
            ? "fas fa-check"
            : "fas fa-chevron-right";
      }

      function initTutorial() {
        document
          .getElementById("tutorial-next-btn")
          .addEventListener("click", function () {
            if (currentTutorialStep === tutorialSteps.length - 1) {
              hideTutorial();
            } else {
              showTutorialStep(currentTutorialStep + 1);
            }
          });

        document
          .getElementById("tutorial-prev-btn")
          .addEventListener("click", function () {
            showTutorialStep(currentTutorialStep - 1);
          });

        document
          .getElementById("tutorial-skip-btn")
          .addEventListener("click", hideTutorial);

        if (!localStorage.getItem("hasSeenTutorial")) {
          showTutorial();
        }
      }

      // --- INITIAL LOAD ---
      document.addEventListener("DOMContentLoaded", function () {
        loadPopulationDensityTiff().then(function () {
          initializeMissions(); // 新規追加: ミッションを初期化
          setGameSpeed(1); // 初期速度は1倍
          initTutorial(); // チュートリアルを初期化
          requestAnimationFrame(gameLoop); // ゲームループを開始
        });
      });
    </script>
  </body>
</html>
